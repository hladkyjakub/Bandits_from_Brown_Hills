#This is for testing WML purpose (MEGA usefull)
#alias e3=lua wesnoth.require("wml-utils").handle_event_commands(wml.tovconfig(wml.load("~add-ons/Bandits_from_Brown_Hills/test_WML_event_3.cfg")))
#  [store_unit]
#      [filter]
#          type=Orcish Archer
#      [/filter]
#  [/store_unit]
#  [foreach]
#      array=unit.attack
#      [do]
#          [if]
#              [variable]
#                  name=unit.attack[$i].name
#                  equals=$unit.attack[1].name
#              [/variable]
#              [then]
#                  [message]
#                      speaker=narrator
#                      message="The condition is true!"
#                  [/message]
#                  [message]
#                      speaker=narrator
#                      message="$unit.attack[$i].name"
#                  [/message]
#                  [message]
#                      speaker=narrator
#                      message="$unit.attack[1].name"
#                  [/message]
#              [/then]
#          [/if]
#      [/do]
#  [/foreach]

    #  [store_unit]
    #      [filter]
    #          x,y=8,19
    #      [/filter]
    #      variable=unit
    #  [/store_unit]
    #  [store_unit]
    #      [filter]
    #          x,y=9,19
    #      [/filter]
    #      variable=second_unit
    #  [/store_unit]
#      [event] #TODO #NOW put this even inside unit_placed event, even in filter to prevent duping
#          name=unit_placed
#          first_time_only=yes
#          [lua]
#              code = <<
#  local ecx = wesnoth.current.event_context
#  local unit = wesnoth.units.get(ecx.x1, ecx.y1)

#  BfBH.unit.variables.add_to_list(unit, "my_list", "apple")
#  BfBH.unit.variables.add_to_list(unit, "my_list", "banana")
#  BfBH.unit.variables.add_to_list(unit, "my_list", "cherry")
#  local retrieved_list = unit.variables["my_list"]
#  local items = {}
#  for item in string.gmatch(retrieved_list, "[^,]+") do
#      std_print(item)
#      table.insert(items, item)
#  end
#  --BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
#  >>
#          [/lua]
#      [/event]

#  [lua]
#      code = <<
#  local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills" --Idk how to use it???
#  std_print(os.time())
#  local f_os_time = os.time
#  function os.time()
#  	local g = f_os_time()
#  	std_print(100)
#  	return g
#  end
#  >>
#  [/lua]

#  local coroutine = require("coroutine")

#  function sleep(seconds)
#      local start = os.time()
#      while os.time() - start < seconds do
#          coroutine.yield()
#      end
#  end

#  function my_fc()
#      print("Starting my_fc")
#      print("Pausing for 5 minutes")
#      sleep(300)  -- 300 seconds = 5 minutes
#      print("Resuming my_fc after 5 minutes")
#      -- Rest of your function code here
#  end

#  -- Create a coroutine
#  local co = coroutine.create(my_fc)

#  -- Function to resume the coroutine
#  local function resume_coroutine()
#      if coroutine.status(co) ~= "dead" then
#          coroutine.resume(co)
#      end
#  end

#  -- Main loop
#  while coroutine.status(co) ~= "dead" do
#      resume_coroutine()
#      -- You might want to add a small delay here to prevent busy-waiting
#      -- For example: os.execute("sleep 0.1")
#  end






#  [lua]
#      [args]
#          {WEAPON_SPECIAL_BLEED}
#          {ABILITY_ADAPTIVE_ARMOR}
#          {WEAPON_SPECIAL_BULLSEYE}
#          {WEAPON_SPECIAL_TEMPO_SURGE}
#          {WEAPON_SPECIAL_KNOCKBACK}
#          #...
#      [args]
#      code=<<
#  local effects = {}
#  local ecx = wesnoth.current.event_context
#  local unit = wesnoth.units.get(ecx.x1, ecx.y1)
#  unit:add_modification("object", effects)
#      >>
#  [/lua]





#  [event]
#      name=attack
#      first_time_only=yes
#      [store_unit]
#          [filter]
#              x,y=$x1,$y1
#          [/filter]
#          variable=unit
#      [/store_unit]
#      [store_unit]
#          [filter]
#              x,y=$x2,$y2
#          [/filter]
#          variable=second_unit
#      [/store_unit]
#  [lua]
#      code=<<
#      function printTable(t, indent)
#          indent = indent or 0
#          local indentation = string.rep("  ", indent)

#          if type(t) ~= "table" then
#              std_print(indentation .. tostring(t))
#              return
#          end

#          print(indentation .. "{")
#          for key, value in pairs(t) do
#              local formattedKey
#              if type(key) == "number" then
#                  formattedKey = "[" .. key .. "]"
#              else
#                  formattedKey = tostring(key)
#              end

#              if type(value) == "table" then
#                  std_print(indentation .. "  " .. formattedKey .. " =")
#                  printTable(value, indent + 1)
#              else
#                  std_print(indentation .. "  " .. formattedKey .. " = " .. tostring(value))
#              end
#          end
#          std_print(indentation .. "}")
#      end

#  local function choose_defender_weapon(attacker, defender, attacker_weapon)
#      local i = 0
#      while wml.variables[""..defender.."[0].attack["..i.."]"] ~= nil do
#          if wml.variables[""..defender.."[0].attack["..i.."].range"] == wml.variables[""..attacker.."[0].attack["..attacker_weapon.."].range"] then
#              local a1, b1, c1, d1 =wesnoth.simulate_combat(wesnoth.units.get(wml.variables[""..attacker.."[0].id"]),(attacker_weapon + 1), wesnoth.units.get(wml.variables[""..defender.."[0].id"]))
#              local a2, b2, c2, d2 =wesnoth.simulate_combat(wesnoth.units.get(wml.variables[""..attacker.."[0].id"]),(attacker_weapon + 1), wesnoth.units.get(wml.variables[""..defender.."[0].id"]), (i + 1))
#              if BfBH.table.deep_compare(a1,a2) and BfBH.table.deep_compare(b1,b2) and BfBH.table.deep_compare(c1,c2) and BfBH.table.deep_compare(d1,d2) then
#                  return i
#              end
#          end
#          i = i + 1
#      end
#      return false
#  end
#  std_print(choose_defender_weapon("unit", "second_unit", 1))
[event]
    name=fire
    [store_unit]
        [filter]
            [has_attack]
                special_type_active="sample"
            [/has_attack]
        [/filter]
        variable="WML_event_stored_unit_sample_active"
    [/store_unit]
    [store_unit]
        [filter]
            [has_attack]
                special_type="sample"
            [/has_attack]
        [/filter]
        variable="WML_event_stored_unit_sample"
    [/store_unit]
[/event]
[lua]
    code=<<
-- function wesnoth.effects.weapons_real_range(unit, cfg)
--     local unit_cfg = unit.__cfg
--     for i, weapon in ipairs(unit.attacks) do
--         if weapon.range == "ranged" then
--             weapon_cfg = wml.get_nth_child(unit_cfg, "attack", i)
--             weapon_cfg.max_range=cfg.new_max_range
--             weapon_cfg.min_range=cfg.new_min_range
--         end
--     end
--     --wesnoth.units.extract(unit)
--     wesnoth.units.to_map(unit_cfg)
-- end
-- wesnoth.wml_actions.modify_unit({{"object", {take_only_once=false,id="real_ranged_weapons",{"filter",{}},{"effect",{apply_to="weapons_real_range",new_max_range=3,new_min_range=2}}}}})
-- units = wesnoth.units.find_on_map({})
-- for _, unit in ipairs(units) do
--     unit_cfg = unit.__cfg
--     for i, weapon in ipairs(unit.attacks) do
--         if weapon.range == "ranged" then
--             weapon_cfg = wml.get_nth_child(unit_cfg, "attack", i)
--             weapon_cfg.max_range=3
--             weapon_cfg.min_range=2
--         end
--     end
--     wesnoth.units.extract(unit)
--     wesnoth.units.to_map(unit_cfg)
-- end
>>
[/lua]
#  [object]
#      take_only_once=no
#      id=real_ranged_weapons
#      [filter]
#      [/filter]
#      [effect]
#          apply_to=weapons_real_range
#          new_max_range=3
#          new_min_range=2
#      [/effect]
#  [/object]
#  [event]
#      name=unit placed, post_advance
#      first_time_only=no
#      id=real_ranged_attacks_grant
#      [filter]
#          [not]
#              id=$last_unit_placed_ranged_attack_id
#          [/not]
#          [or]
#              [not]
#                  type=$last_unit_placed_ranged_attack_type
#                  max_hitpoints=$last_unit_placed_ranged_attack_max_hitpoints
#              [/not]
#          [/or]
#      [/filter]
#      [lua]
#          code=<<
#  local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
#  unit_cfg = unit.__cfg
#  for i, weapon in ipairs(unit.attacks) do
#      if weapon.range == "ranged" then
#          weapon_cfg = wml.get_nth_child(unit_cfg, "attack", i)
#          weapon_cfg.max_range=3
#          weapon_cfg.min_range=2
#      end
#  end
#  wml.variables["last_unit_placed_ranged_attack_id"] = unit.id
#  wml.variables["last_unit_placed_ranged_attack_type"] = unit.type
#  wml.variables["last_unit_placed_ranged_attack_max_hitpoints"] = unit.max_hitpoints
#  wesnoth.units.extract(unit)
#  wesnoth.units.to_map(unit_cfg)
#  >>
#      [/lua]
#  [/event]
[lua]
    code=<<
    BfBH.unit.cool_move = function (cfg)
    local coordinate_error = "invalid location in BfBH.unit.cool_move"
	local path
	if cfg.to_location then
		path = {location_id = cfg.to_location}
	elseif cfg.dir then
		path = {dir = cfg.dir}
	else
		path = {to_x = cfg.to_x, to_y = cfg.to_y}
	end
	if not path then
		wml.error(coordinate_error)
	end
	local fire_event = cfg.fire_event
	local unshroud = cfg.clear_shroud
	local muf_force_scroll = cfg.force_scroll
	local check_passability = cfg.check_passability
	if check_passability == nil then check_passability = true end
	cfg = wml.literal(cfg)
	cfg.to_location, cfg.to_x, cfg.to_y, cfg.fire_event, cfg.clear_shroud = nil, nil, nil, nil, nil
	local units = wesnoth.units.find_on_map(cfg)

	for current_unit_index, current_unit in ipairs(units) do
		if not fire_event or current_unit.valid then
			local locs = BfBH.unit.path_locs(path)
			local x_list = {current_unit.x}
			local y_list = {current_unit.y}
			local pass_check = nil
			if check_passability then pass_check = current_unit end

			current_unit:extract()
			local x, y = locs(current_unit)
			local prevX, prevY = tonumber(current_unit.x), tonumber(current_unit.y)
			while true do
				x = tonumber(x) or current_unit:to_map(false) or wml.error(coordinate_error)
				y = tonumber(y) or current_unit:to_map(false) or wml.error(coordinate_error)
				if not (x == prevX and y == prevY) then x, y = wesnoth.paths.find_vacant_hex(x, y, pass_check) end
				if not x or not y then wml.error("Could not find a suitable hex near to one of the target hexes in [move_unit].") end
				table.insert(x_list, x)
				table.insert(y_list, y)
				local next_x, next_y = locs(current_unit)
				if not next_x and not next_y then break end
				prevX, prevY = x, y
				x, y = next_x, next_y
			end

			if current_unit.x < x then current_unit.facing = "se"
			elseif current_unit.x > x then current_unit.facing = "sw"
			end

			local current_unit_cfg = current_unit.__cfg
            current_unit:to_map(false)
            local path_found
            local animator = wesnoth.units.create_animator()
			for i = 1, (#x_list - 1) do
                path_found = wesnoth.paths.find_path(x_list[i], y_list[i], x_list[i+1], y_list[i+1])
                for i2 = 1, (#path_found - 1) do
                    local distance = wesnoth.map.distance_between({path_found[i2][1],path_found[i2][2]},{path_found[i2+1][1],path_found[i2+1][2]})
                    std_print(distance)
                    if distance == 1 then
                        current_unit.facing=wesnoth.map.get_relative_dir({path_found[i2][1],path_found[i2][2]},{path_found[i2+1][1],path_found[i2+1][2]})
                        wesnoth.wml_actions.redraw {clear_shroud=true}
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2][1],path_found[i2][2]}) then
                            wesnoth.game_events.fire("exit_hex", {path_found[i2][1],path_found[i2][2]}, {path_found[i2+1][1],path_found[i2+1][2]})
                        end
                        animator:add(current_unit, "movement", "miss", {value= {i2-1,#path_found - i2}})
                        animator:run()
                        animator:clear()
                        current_unit:extract()
                        current_unit.x, current_unit.y = path_found[i2+1][1], path_found[i2+1][2]
                        --std_print(path_found[i2+1][1], path_found[i2+1][2])
                        current_unit:to_map(false)
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2+1][1],path_found[i2+1][2]}) then
                            wesnoth.game_events.fire("enter_hex", {path_found[i2+1][1],path_found[i2+1][2]}, {path_found[i2][1],path_found[i2][2]})
                        end
                    elseif distance > 1 then
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2][1],path_found[i2][2]}) then
                            wesnoth.game_events.fire("exit_hex", {path_found[i2][1],path_found[i2][2]}, {path_found[i2+1][1],path_found[i2+1][2]})
                        end
                        animator:add(current_unit, "pre_teleport", "hit", {})
                        animator:run()
                        animator:clear()
                        current_unit:extract()
                        current_unit.x, current_unit.y = path_found[i2+1][1], path_found[i2+1][2]
                        animator:add(current_unit, "post_teleport", "hit", {})
                        animator:run()
                        animator:clear()
                        current_unit:to_map(false)
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2+1][1],path_found[i2+1][2]}) then
                            wesnoth.game_events.fire("enter_hex", {path_found[i2+1][1],path_found[i2+1][2]}, {path_found[i2][1],path_found[i2][2]})
                        end
                    else
                        --it's the same location, nothing should happen, not even moveto if only those moves hapened
                    end
                end
            end
			local x2, y2 = current_unit.x, current_unit.y
			--current_unit.x, current_unit.y = x, y
			--current_unit:to_map(false)
			if unshroud then
				wesnoth.wml_actions.redraw {clear_shroud=true}
			end

			if fire_event then
				wesnoth.game_events.fire("moveto", x, y, x2, y2)
			end
		end
	end
end
-- BfBH.unit.cool_move({to_x='22', to_y='24',x = 8, y=18})
-- BfBH.unit.cool_move({to_x='21', to_y='24',x = 7, y=19})
>>
[/lua]
[lua]
    code=<<
local BC = wesnoth.require "~add-ons/Bandits_from_Brown_Hills/ai/lua/battle_calcs.lua"
-- wesnoth.game_events.on_mouse_move = function(x, y)
--     if not(wesnoth.interface.get_selected_hex() and wesnoth.interface.get_hovered_hex()) then
--         return false
--     end
--     local unit = wesnoth.units.get(wesnoth.interface.get_selected_hex() )
--     local second_unit = wesnoth.units.get(wesnoth.interface.get_hovered_hex() )
--     if not(unit and second_unit and unit.side == wml.variables["side_number"] and wesnoth.sides.is_enemy(unit.side,second_unit.side)) then
--         return false
--     end
--     local distance = wesnoth.map.distance_between(unit.loc, second_unit.loc)
--     if distance == 1 then
--         return false
--     end
--     local attack = "empty"
--     local attacking_weapon_index
--     for i = 1, #unit.attacks do
--         if unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range then
--             attack = unit.attacks[i] --for the menu, then I guess
--             attacking_weapon_index = i - 1
--         end
--     end
--     if attack == "empty" then
--         return false
--     end
--     std_print("need custom display(instead of the melee attack one (with move))")
--     return true
-- end
wesnoth.game_events.on_mouse_button = function(x, y, button, event)
    if not (button == "left" and event == "click") then
        return false
    end
    if not(wesnoth.interface.get_selected_hex() and wesnoth.interface.get_hovered_hex()) then
        return false
    end
    local unit = wesnoth.units.get(wesnoth.interface.get_selected_hex() )
    local second_unit = wesnoth.units.get(wesnoth.interface.get_hovered_hex() )
    if not(unit and second_unit and unit.side == wml.variables["side_number"] and wesnoth.sides.is_enemy(unit.side,second_unit.side)) then
        return false
    end
    local AH = wesnoth.require "~add-ons/Bandits_from_Brown_Hills/ai/lua/ai_helper.lua"
    if not AH.is_visible_unit(unit.side, second_unit) then
        return false
    end
    local distance = wesnoth.map.distance_between(unit.loc, second_unit.loc)
    -- if distance == 1 then --todo comment out
    --     return false
    -- end
    local attack = "empty"
    local attacking_weapon_index
    for i = 1, #unit.attacks do
        if unit.attacks[i].attacks_used <= unit.attacks_left and unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range and unit.attacks[i]:matches({special_type_active="disable"}) == false then
            local _,_,attacker_stats,_ = wesnoth.simulate_combat(unit, i, second_unit)
            if attacker_stats.num_blows ~= 0 then
                std_print("attack is being set")
                attack = unit.attacks[i]
                attacking_weapon_index = i - 1
            end
        end
    end
    local attack_location = unit.loc
    local move_and_attack = false
    if attack == "empty" then
        local weapon_ranges={}
        for i,weapon in ipairs(unit.attacks) do
            if unit.attacks[i].attacks_used <= unit.attacks_left then
                weapon_ranges[i] = {weapon.__cfg.max_range,weapon.__cfg.min_range}
            end
        end
        local map=wesnoth.paths.find_cost_map(unit,{},{ignore_units=false, ignore_teleport=false,  viewing_side=unit.side})
        local best_cost = {0,0,unit.max_moves + 1}
        for i = 1, #map do
            if map[i][3] <= unit.max_moves and map[i][3] ~= -1 then
                local dist = wesnoth.map.distance_between({map[i][1],map[i][2]},second_unit.loc)
                --std_print(dist)
                --std_print(map[i][1],map[i][2],map[i][3])
                if map[i][3] < best_cost[3] and wesnoth.units.get({map[i][1],map[i][2]}) == nil then
                    for i2,range in ipairs(weapon_ranges) do
                        if range[1] >= dist and range[2] <= dist and dist ~= 1 then --hardcoded TODO (theres a mainline dialog if dist=1)
                            best_cost={map[i][1],map[i][2],map[i][3]}
                        end
                    end
                end
            end
        end
        if best_cost[3] == unit.max_moves + 1 then
            return false
        else
            move_and_attack = true
            attack_location=wesnoth.named_tuple({best_cost[1],best_cost[2]}, {'x', 'y'})
            --distance = wesnoth.map.distance_between(attack_location, second_unit.loc)
        end
    end
    local unit_attack = wml.load '~add-ons/Bandits_from_Brown_Hills/gui/unit_attack.cfg'
    local attack_predictions = wml.load '~add-ons/Bandits_from_Brown_Hills/gui/attack_predictions.cfg'
    local red_green_scale="df0000,e20000,e40000,e70000,ea0000,ec0000,ef0000,f20000,f40000,f70000,fa0000,fc0000,ff0000,ff0500,ff0b00,ff1000,ff1500,ff1b00,ff2000,ff2500,ff2b00,ff3000,ff3500,ff3a00,ff4000,ff4500,ff4a00,ff5000,ff5500,ff5a00,ff6000,ff6500,ff6a00,ff7000,ff7500,ff7a00,ff8000,ff8500,ff8a00,ff8f00,ff9500,ff9a00,ff9f00,ffa500,ffaa00,ffaf00,ffb500,ffba00,ffbf00,ffc500,ffca00,ffcf00,ffd500,ffda00,ffdf00,ffe400,ffea00,ffef00,fff400,fffa00,ffff00,faff00,f4ff00,efff00,eaff00,e4ff00,dfff00,daff00,d5ff00,cfff00,caff00,c5ff00,bfff00,baff00,b5ff00,afff00,aaff00,a5ff00,9fff00,9aff00,95ff00,8fff00,8aff00,85ff00,80ff00,7aff00,75ff00,70ff00,6aff00,65ff00,60ff00,5aff00,55ff00,50ff00,4aff00,45ff00,40ff00,3aff00,35ff00,30ff00,2bff00,25ff00,20ff00,1bff00,15ff00,10ff00,0bff00,05ff00,00ff00,00fc00,00fa00,00f700,00f400,00f200,00ef00,00ec00,00ea00,00e700,00e400,00e200,00df00"
    local unit_type_color="f5e6c1"
    local good_dmg_color     ={130,240,50,255}
	local bad_dmg_color      ={250,140,80,255}
    local function rgba_to_hex(color)
        return string.format("#%02X%02X%02X%02X", color[1], color[2], color[3], color[4])
    end
    local function xp_color(xp_to_advance,can_advance,has_amla)
        local near_advance_color ={255,255,255,255}
        local mid_advance_color  ={150,255,255,255}
        local far_advance_color  ={0,205,205,255}
        local normal_color       ={0,160,225,255}
        local near_amla_color    ={225,0,255,255}
        local mid_amla_color     ={169,30,255,255}
        local far_amla_color     ={139,0,237,255}
        local amla_color         ={170,0,255,255}

        local near_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience
        local mid_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience * 2
        local far_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience * 3

        local color = normal_color
        if can_advance then
            if near_advance then
                color = near_advance_color
            elseif mid_advance then
                color = mid_advance_color
            elseif far_advance then
                color = far_advance_color
            end
        else
            if has_amla then
                if near_advance then
                    color = near_amla_color
                elseif mid_advance then
                    color = mid_amla_color
                elseif far_advance then
                    color = far_amla_color
                else
                    color = amla_color
                end
            end
        end
        return(color)
    end
    local function red_green_scale_function(value)
        value = math.max(0.0, math.min(100.0, value))
        local colors = {}
        for color in red_green_scale:gmatch("[^,]+") do
            table.insert(colors, color)
        end
        local index = math.floor(value / 100 * (#colors - 1)) + 1
        return colors[index]
    end
    function hp_color(hitpoints, max_hitpoints)
        local unit_energy = 0.0
        local energy_color = {0, 0, 0, 255}  -- {r, g, b, a}

        if max_hitpoints > 0 then
            unit_energy = hitpoints / max_hitpoints
        end

        if unit_energy == 1.0 then
            energy_color[1] = 33
            energy_color[2] = 225
            energy_color[3] = 0
        elseif unit_energy > 1.0 then
            energy_color[1] = 100
            energy_color[2] = 255
            energy_color[3] = 100
        elseif unit_energy >= 0.75 then
            energy_color[1] = 170
            energy_color[2] = 255
            energy_color[3] = 0
        elseif unit_energy >= 0.5 then
            energy_color[1] = 255
            energy_color[2] = 175
            energy_color[3] = 0
        elseif unit_energy >= 0.25 then
            energy_color[1] = 255
            energy_color[2] = 155
            energy_color[3] = 0
        else
            energy_color[1] = 255
            energy_color[2] = 0
            energy_color[3] = 0
        end

        return energy_color
    end
    function table_to_string(input)
        local result = {}
        for i, v in ipairs(input) do
            table.insert(result, tostring(v))
        end
        return table.concat(result, ", ")
    end
    local leader_crown = "misc/leader-crown.png"
    local size_normal=17
    local size_small = 15 * (size_normal / 17)
    local function unit_attack_info(unit, cache) --FROM battle.calcs
        local cind = 'UI-' .. unit.id .. unit.max_hitpoints .. unit.side

        -- If cache for this unit exists, return it
        if cache and cache[cind] then
            return cache[cind]
        end

        -- Otherwise collect the information
        local unit_info = {
            attacks = {},
            resist_mod = {},
            alignment = unit.alignment
        }
        local attacks = unit.attacks
        for i_a = 1,#attacks do
            local attack = attacks[i_a]
            -- Extract information for specials; we do this first because some
            -- custom special might have the same name as one of the default scalar fields
            local a = {}
            for _,sp in ipairs(attack.specials) do
                if (sp[1] == 'damage') then  -- this is 'backstab'
                    if (sp[2].id == 'backstab') then
                        a.backstab = true
                    else
                        if (sp[2].id == 'charge') then a.charge = true end
                    end
                else
                    if (sp[1] == 'chance_to_hit') then
                        a[sp[2].id or 'no_id'] = true
                    else
                        a[sp[1]] = true
                    end
                end
            end
            a.damage = attack.damage
            a.type = attack.type
            a.range = attack.range
            a.number = attack.number or 0
            table.insert(unit_info.attacks, a)
        end
        local attack_types = { "arcane", "blade", "cold", "fire", "impact", "pierce" }
        for _,attack_type in ipairs(attack_types) do
            unit_info.resist_mod[attack_type] = 1 - unit:resistance_against(attack_type) / 100.
        end
        if cache then cache[cind] = unit_info end
        return unit_info
    end
    local function strike_damage(attacker, defender, att_weapon, def_weapon, dst, cache)
        local att_lawful_bonus = wesnoth.schedule.get_illumination(dst).lawful_bonus
        local def_lawful_bonus = wesnoth.schedule.get_illumination(defender).lawful_bonus
        local cind = 'SD-' .. attacker.id .. attacker.max_hitpoints .. attacker.side
        cind = cind .. 'x' .. defender.id .. defender.max_hitpoints .. defender.side
        cind = cind .. '-' .. att_weapon .. 'x' .. def_weapon
        cind = cind .. '-' .. att_lawful_bonus .. 'x' .. def_lawful_bonus
        if cache and cache[cind] then
            return cache[cind].att_damage, cache[cind].def_damage, cache[cind].att_attack, cache[cind].def_attack
        end
        local attacker_info = unit_attack_info(attacker, cache)
        local defender_info = unit_attack_info(defender, cache)
        local att_damage = attacker_info.attacks[att_weapon].damage
        local att_multiplier = defender_info.resist_mod[attacker_info.attacks[att_weapon].type] or 1
        att_multiplier = att_multiplier * AH.get_unit_time_of_day_bonus(attacker_info.alignment, att_lawful_bonus)
        local def_damage, def_multiplier = 0, 1.
        if (def_weapon ~= 0) then
            def_damage = defender_info.attacks[def_weapon].damage
            def_multiplier = attacker_info.resist_mod[defender_info.attacks[def_weapon].type] or 1
            def_multiplier = def_multiplier * AH.get_unit_time_of_day_bonus(defender_info.alignment, def_lawful_bonus)
        end
        if attacker_info.attacks[att_weapon].charge then
            att_damage = att_damage * 2
            def_damage = def_damage * 2
        end
        if (att_multiplier > 1) then
            att_damage = mathx.round(att_damage * att_multiplier - 0.001)
        else
            att_damage = mathx.round(att_damage * att_multiplier + 0.001)
        end
        if (def_weapon ~= 0) then
            if (def_multiplier > 1) then
                def_damage = mathx.round(def_damage * def_multiplier - 0.001)
            else
                def_damage = mathx.round(def_damage * def_multiplier + 0.001)
            end
        end
        if cache then
            cache[cind] = {
                att_damage = att_damage,
                def_damage = def_damage,
                att_attack = attacker_info.attacks[att_weapon],
                def_attack = defender_info.attacks[def_weapon]
            }
        end
        return att_damage, def_damage, attacker_info.attacks[att_weapon], defender_info.attacks[def_weapon]
    end
    local function draw_hp_graph(hp_graph, attacker,attack_location, defender, attacker_weapon_index, for_unit)
        local for_unit = for_unit or "attacker"
        local background_color_disabled = "64, 64, 64, 64"
        local font_color_disabled = "128, 128, 128, 255"
        local graph_width = 270
        local graph_height = 170
        local graph_max_rows = 10
        local fs = size_small
        local hp_sep = 30
        local percent_sep = 50
        local bar_space = graph_width - hp_sep - percent_sep - 4
        local contents = {wml.tag.rectangle
        {
            x = 0,
            y = 0,
            w = "(width)",
            h = "(height)",
            fill_color = background_color_disabled,
            border_thickness = 2,
            border_color = font_color_disabled
        },wml.tag.rectangle
        {
            x =hp_sep,
            y = 0,
            w = 2,
            h = "(height - 2)",
            fill_color =font_color_disabled
        },wml.tag.rectangle
        {
            x = "(width-2)"..-percent_sep,
            y = 0,
            w = 2,
            h = "(height - 2)",
            fill_color =font_color_disabled
        }
        }
        std_print(attacker_weapon_index)
        local attacker_condition,defender_condition,attacker_stats,defender_stats = BC.simulate_combat_loc(attacker,attack_location,defender,attacker_weapon_index)
        local unit = attacker
        local unit_condition = attacker_condition
        local unit_stats = attacker_stats
        local second_unit =  defender
        local second_unit_condition = defender_condition
        local second_unit_stats = defender_stats
        if for_unit ~= "attacker" then
            unit = defender
            unit_condition = defender_condition
            unit_stats = defender_stats
            second_unit =  attacker
            second_unit_condition = attacker_condition
            second_unit_stats = attacker_stats
        end
        local pair_table = {}
        for index, value in pairs(unit_condition.hp_chance) do
            if value ~= 0 then
                table.insert(pair_table, {value = value, index = index})
            end
        end
        table.sort(pair_table, function(a, b) return a.value > b.value end)
        local top_ten = {}
        for i = 1, math.min(10, #pair_table) do
            table.insert(top_ten, pair_table[i])
        end
        table.sort(top_ten, function(a, b) return a.index > b.index end)
        for i = 1, math.min(10, #top_ten) do
            local hp = top_ten[i].index
            local prob = top_ten[i].value
            local row_color
            if hp == 0 then
                row_color = {229, 0, 0}
            elseif hp < unit.hitpoints then
                if second_unit_stats.petrifies then
                    row_color = {154, 154, 154}
                else
                    row_color = {244, 201, 0}
                end
            else
                row_color = {8, 202, 0}
            end
            local bar_len = math.max(math.floor((prob * (bar_space - 4)) + 0.5), 2)
            table.insert(contents,wml.tag.rectangle
            {
                x = hp_sep + 4,
                y = 6 + (fs + 2) * (i - 1),
                w = bar_len,
                h = 8,
                fill_color = string.format("%d, %d, %d", row_color[1], row_color[2], row_color[3]),
            })
            table.insert(contents,wml.tag.text
            {
                text = tostring(hp),
                x = 4,
                y = 2 + (fs + 2) * (i - 1),
                w = "(text_width)",
                h = "(text_height)",
                font_size = 12,
                color = "255, 255, 255, 255",
                text_alignment = "(text_alignment)",
            })
            table.insert(contents,wml.tag.text
            {
                text = string.format("%.1f", (prob*100)).."%",
                x = graph_width - percent_sep + 2,
                y = 2 + (fs + 2) * (i - 1),
                w = "(text_width)",
                h = "(text_height)",
                font_size = 12,
                color = "255, 255, 255, 255",
                text_alignment = "(text_alignment)",
            })
        end
        hp_graph:set_canvas(1,contents)
    end
    local weapon_index_list={}
    local attack_locations={}
    local distances = {}
    local selected_index
    function preshow(dialog) --#TODO missing specials, abilities (both in weapon list and combat statistics), no idea what label_helper is, skipping, end no-mainline-dialog, get rid of the gray and selected units, ORBS if unit can attack
        local unit_advances_to = unit.advances_to[1] ~= nil
        local unit_amla = unit.advancements[1] ~= nil
        local unit_mods = "~RC(magenta>" ..wesnoth.sides[unit.side].color .. ")"..unit.image_mods
        if unit.canrecruit then
            unit_mods = unit_mods .. "~BLIT(" .. leader_crown .. ")"
        end
        for i2 = 1, #unit.overlays do
            unit_mods = unit_mods .. "~BLIT(" .. unit.overlays[i2] .. ")"
        end
        dialog["attacker_pane"].type_image.label=unit.__cfg.image .. unit_mods
        dialog["attacker_pane"].type_details_minimal.use_markup = true
        dialog["attacker_pane"].type_details_minimal.label="<span size='large'>"..unit.name.."</span>\n"
        .."<span color='#"..unit_type_color.."'>"..unit.__cfg.language_name.."</span>\n"
        .."Lvl "..unit.level.."\n"
        ..unit.alignment.."\n"
        ..table_to_string(unit.traits).."\n"
        .."<span color='"..rgba_to_hex(hp_color(unit.hitpoints,unit.max_hitpoints)).."'>HP: "..unit.hitpoints.."/"..unit.max_hitpoints.."</span>\n"
        .."<span color='"..rgba_to_hex(xp_color(unit.max_experience - unit.experience,unit_advances_to,unit_amla)).."'>XP: "..unit.experience.."/"..unit.max_experience.."</span>"
        --dialog["attacker_pane"].type_name.label="type_name"
        dialog["attacker_pane"].type_profile.on_button_click= function() gui.show_help("unit_"..unit.type) end

        local second_unit_advances_to = second_unit.advances_to[1] ~= nil
        local second_unit_amla = second_unit.advancements[1] ~= nil
        local second_unit_mods = "~RC(magenta>" ..wesnoth.sides[second_unit.side].color .. ")"..second_unit.image_mods
        if second_unit.canrecruit then
            second_unit_mods = second_unit_mods .. "~BLIT(" .. leader_crown .. ")"
        end
        for i2 = 1, #second_unit.overlays do
            second_unit_mods = second_unit_mods .. "~BLIT(" .. second_unit.overlays[i2] .. ")"
        end
        second_unit_mods = second_unit_mods .. "~FL(horiz)"
        dialog["defender_pane"].type_image.label=second_unit.__cfg.image .. second_unit_mods
        dialog["defender_pane"].type_details_minimal.use_markup = true
        dialog["defender_pane"].type_details_minimal.label="<span size='large'>"..second_unit.name.."</span>\n"
        .."<span color='#"..unit_type_color.."'>"..second_unit.__cfg.language_name.."</span>\n"
        .."Lvl "..second_unit.level.."\n"
        ..second_unit.alignment.."\n"
        ..table_to_string(second_unit.traits).."\n"
        .."<span color='"..rgba_to_hex(hp_color(second_unit.hitpoints,second_unit.max_hitpoints)).."'>HP: "..second_unit.hitpoints.."/"..second_unit.max_hitpoints.."</span>\n"
        .."<span color='"..rgba_to_hex(xp_color(second_unit.max_experience - second_unit.experience,second_unit_advances_to,second_unit_amla)).."'>XP: "..second_unit.experience.."/"..second_unit.max_experience.."</span>"
        dialog["defender_pane"].type_profile.on_button_click= function() gui.show_help("unit_"..second_unit.type) end

        local weapon_row = 1
        for i = 1, #unit.attacks do
            attack_locations[i]=-1
            distances[i]=-1
            if unit.attacks[i].attacks_used <= unit.attacks_left then
                local seek_paths = true
                if unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range and unit.attacks[i]:matches({special_type_active="disable"}) == false then
                    local _,_,attacker_stats,_ = wesnoth.simulate_combat(unit,i , second_unit)
                    if attacker_stats.num_blows ~= 0 then
                        seek_paths = false
                    end
                    std_print("max, distance, min:"..unit.attacks[i].__cfg.max_range.." >= "..distance.." >= "..unit.attacks[i].__cfg.min_range)
                    attack_locations[i]=wesnoth.named_tuple({unit.x,unit.y}, {'x', 'y'})
                    distances[i]=wesnoth.map.distance_between(unit.loc, second_unit.loc)
                end
                if seek_paths then
                    local map=wesnoth.paths.find_cost_map(unit,{},{ignore_units=false, ignore_teleport=false,  viewing_side=unit.side})
                    local best_cost = {0,0,unit.max_moves + 1}
                    for map_iter = 1, #map do
                        if map[map_iter][3] <= unit.max_moves and map[map_iter][3] ~= -1 then
                            local dist = wesnoth.map.distance_between({map[map_iter][1],map[map_iter][2]},second_unit.loc)
                            if map[map_iter][3] < best_cost[3] and wesnoth.units.get({map[map_iter][1],map[map_iter][2]}) == nil then
                                if unit.attacks[i].__cfg.max_range >= dist and unit.attacks[i].__cfg.min_range <= dist then
                                    best_cost={map[map_iter][1],map[map_iter][2],map[map_iter][3]}
                                end
                            end
                        end
                    end

                    if best_cost[3] ~= unit.max_moves + 1 then
                        attack_locations[i]=wesnoth.named_tuple({best_cost[1],best_cost[2]}, {'x', 'y'})
                        distances[i] = wesnoth.map.distance_between(attack_locations[i], second_unit.loc)
                    end
                end
            end
            --std_print("Best attack tile and coset: "..attack_locations[i][1],attack_locations[i][2],attack_locations[i][3])
            --std_print("counted if weapon usable "..attack_locations[i])
            if attack_locations[i] ~= -1 then
                std_print("making weapon row")
                BfBH.table.std_print(attack_locations[i])
                local weapon = unit.attacks[i]
                local _,_,attacker_stats,defender_stats = BC.simulate_combat_loc(unit, attack_locations[i], second_unit, i)
                std_print("attacker stats chance to hit: "..attacker_stats.chance_to_hit)
                local second_weapon = nil
                if defender_stats.attack_num ~= -1 then
                    second_weapon = second_unit.attacks[defender_stats.attack_num + 1]
                end
                weapon_index_list[#weapon_index_list + 1] = {i, defender_stats.attack_num + 1}
                dialog["weapon_list"][weapon_row].attacker_weapon.use_markup = true
                dialog["weapon_list"][weapon_row].attacker_weapon_icon.label = weapon.icon
                dialog["weapon_list"][weapon_row].attacker_weapon.label="<b>"..weapon.name.."</b>\n"
                ..weapon.type.."\n"
                ..mathx.round(attacker_stats.damage).."×"..mathx.round(attacker_stats.num_blows).."\n"
                .."<span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..mathx.round(attacker_stats.chance_to_hit).."%</span>"
                dialog["weapon_list"][weapon_row].attacker_weapon.tooltip="Weapon: <b>"..weapon.name.."</b>\n"
                .."Type: "..weapon.type.."\n"
                .."Damage: "..mathx.round(attacker_stats.damage).."\n"
                .."Attacks: "..mathx.round(attacker_stats.num_blows).."\n"
                .."Chance to hit: <span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..mathx.round(attacker_stats.chance_to_hit).."%</span>"
                dialog["weapon_list"][weapon_row].range.use_markup = true
                dialog["weapon_list"][weapon_row].range.label="<span color='#a69275'>— "..weapon.range.." —</span>"
                dialog["weapon_list"][weapon_row].defender_weapon.use_markup = true
                if second_weapon ~= nil then
                    dialog["weapon_list"][weapon_row].defender_weapon_icon.label = second_weapon.icon
                    dialog["weapon_list"][weapon_row].defender_weapon.label="<b>"..second_weapon.name.."</b>\n"
                    ..second_weapon.type.."\n"
                    ..mathx.round(defender_stats.damage).."×"..mathx.round(defender_stats.num_blows).."\n"
                    .."<span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..mathx.round(defender_stats.chance_to_hit).."%</span>"
                    dialog["weapon_list"][weapon_row].defender_weapon.tooltip="Weapon: <b>"..second_weapon.name.."</b>\n"
                    .."Type: "..second_weapon.type.."\n"
                    .."Damage: "..mathx.round(defender_stats.damage).."\n"
                    .."Attacks: "..mathx.round(defender_stats.num_blows).."\n"
                    .."Chance to hit: <span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..mathx.round(defender_stats.chance_to_hit).."%</span>"
                else
                    dialog["weapon_list"][weapon_row].defender_weapon_icon.label = "attacks/blank-attack.png"
                    dialog["weapon_list"][weapon_row].defender_weapon.label="<b>".."".."</b>\n"
                    .."".."\n"
                    .."0".."×".."0".."\n"
                    .."<span color='#"..red_green_scale_function(0).."'>".."0".."%</span>"
                end
                weapon_row = weapon_row + 1
                --BfBH.table.std_print(attacker_stats)
            end
        end

        local best_rating=nil
        for iter=1, #weapon_index_list do
            local rating = BC.ranged_attack_rating(unit, second_unit, { attack_locations[weapon_index_list[iter][1]].x, attack_locations[weapon_index_list[iter][1]].y }, {att_weapon = weapon_index_list[iter][1], def_weapon = weapon_index_list[iter][2]} )
            if best_rating == nil or rating > best_rating then
                best_rating=rating
                dialog["weapon_list"].selected_index = iter
            end
        end

        dialog.damage_calculation.on_button_click= function()
            function preshow(dialog_2)
                local weapon_index = weapon_index_list[dialog["weapon_list"].selected_index][1]
                local weapon = unit.attacks[weapon_index]
                local attacker_condition,defender_condition,attacker_stats,defender_stats = BC.simulate_combat_loc(unit,attack_locations[weapon_index],second_unit,weapon_index)
                local opp_weapon_index = nil
                local opp_weapon = nil
                if defender_stats.attack_num ~= -1 then
                    opp_weapon_index = weapon_index_list[dialog["weapon_list"].selected_index][2]
                    opp_weapon = second_unit.attacks[opp_weapon_index]
                end
                draw_hp_graph(dialog_2["attacker_hp_graph"],unit,attack_locations[weapon_index],second_unit,weapon_index)
                draw_hp_graph(dialog_2["defender_hp_graph"],unit,attack_locations[weapon_index],second_unit,weapon_index,"defender")
                dialog_2["attacker_chance_unscathed"].label = "<span color='#"..red_green_scale_function(attacker_condition.untouched * 100).."'>"..string.format("%.1f", (attacker_condition.untouched * 100)).."%</span>"
                if unit.attacks[weapon_index] then
                    dialog_2["attacker_base_damage"].label = unit.attacks[weapon_index].damage.." (<i>"..unit.attacks[weapon_index].name.."</i>)"
                    local resistance_modifier = 100 - wesnoth.units.resistance_against(second_unit, weapon.type)
                    if resistance_modifier ~= 100 then
                        local ss = ""
                        if resistance_modifier < 100 then
                            ss = ss..("Attacker resistance vs").." " --#TODOmake it translate-able string
                        else
                            ss = ss..("Attacker vulnerability vs").." " --#TODO make it translate-able string
                        end
                        dialog_2["attacker_resis"].label = "×" .. math.floor(resistance_modifier / 100) .. "." .. math.floor((resistance_modifier % 100) / 10)
                        dialog_2["attacker_resis_label"].label=ss .. weapon.type
                        dialog_2["attacker_resis_label"].visible="visible"
                    else
                        dialog_2["attacker_resis"].label = ""
                        dialog_2["attacker_resis_label"].label = ""
                        dialog_2["attacker_resis_label"].visible = "hidden"
                    end
                    --wesnoth.map.get(unit.loc).illuminated_time --#TODO
                    --unit.alignment
                    --#wesnoth.units.find({fearless=true,x=unit.x,y=unit.y})
                    dialog_2["attacker_tod_modifier"].label = ""
                    dialog_2["attacker_tod_modifier_label"].label = ""
                    dialog_2["attacker_tod_modifier_label"].visible = "hidden"
                    dialog_2["attacker_leadership_modifier"].label = ""
                    dialog_2["attacker_leadership_modifier_label"].label = ""
                    dialog_2["attacker_leadership_modifier_label"].visible = "hidden"
                    dialog_2["attacker_slowed_modifier"].label = ""
                    dialog_2["attacker_slowed_modifier_label"].label = ""
                    dialog_2["attacker_slowed_modifier_label"].visible = "hidden"
                    local ss = math.floor(attacker_stats.damage)
                    if attacker_stats.damage > weapon.damage then
                        ss="<span color='"..rgba_to_hex(good_dmg_color).."'>" .. ss .. "</span>"
                    elseif attacker_stats.damage < weapon.damage then
                        ss="<span color='"..rgba_to_hex(bad_dmg_color).."'>" .. ss .. "</span>"
                    end
                    dialog_2["attacker_total_damage"].label = ss .."×"..math.floor(attacker_stats.num_blows)
                    dialog_2["attacker_chance_to_hit"].label = "<span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..attacker_stats.chance_to_hit.. "%</span>"
                end
                dialog_2["defender_chance_unscathed"].label = "<span color='#"..red_green_scale_function(defender_condition.untouched * 100).."'>"..string.format("%.1f", (defender_condition.untouched * 100)).."%</span>"
                std_print(opp_weapon_index)
                std_print(opp_weapon)
                if opp_weapon then
                    dialog_2["defender_base_damage"].label = second_unit.attacks[opp_weapon_index].damage.." (<i>"..second_unit.attacks[opp_weapon_index].name.."</i>)"
                    local resistance_modifier = 100 - wesnoth.units.resistance_against(unit, opp_weapon.type)
                    if resistance_modifier ~= 100 then
                        local ss = ""
                        if resistance_modifier < 100 then
                            ss = ss..("Defender resistance vs").." " --#TODOmake it translate-able string
                        else
                            ss = ss..("Defender vulnerability vs").." " --#TODO make it translate-able string
                        end
                        dialog_2["defender_resis"].label = "×" .. math.floor(resistance_modifier / 100) .. "." .. math.floor((resistance_modifier % 100) / 10)
                        dialog_2["defender_resis_label"].label=ss .. opp_weapon.type
                        dialog_2["defender_resis_label"].visible="visible"
                    else
                        dialog_2["defender_resis"].label = ""
                        dialog_2["defender_resis_label"].label = ""
                        dialog_2["defender_resis_label"].visible = "hidden"
                    end
                    --wesnoth.map.get(unit.loc).illuminated_time
                    --unit.alignment
                    --#wesnoth.units.find({fearless=true,x=unit.x,y=unit.y}) --nefunguje, filtrovat trait
                    dialog_2["defender_tod_modifier"].label = ""
                    dialog_2["defender_tod_modifier_label"].label = ""
                    dialog_2["defender_tod_modifier_label"].visible = "hidden"
                    dialog_2["defender_leadership_modifier"].label = ""
                    dialog_2["defender_leadership_modifier_label"].label = ""
                    dialog_2["defender_leadership_modifier_label"].visible = "hidden"
                    dialog_2["defender_slowed_modifier"].label = ""
                    dialog_2["defender_slowed_modifier_label"].label = ""
                    dialog_2["defender_slowed_modifier_label"].visible = "hidden"
                    local ss = math.floor(defender_stats.damage)
                    if defender_stats.damage > opp_weapon.damage then
                        ss="<span color='"..rgba_to_hex(good_dmg_color).."'>" .. ss .. "</span>"
                    elseif defender_stats.damage < opp_weapon.damage then
                        ss="<span color='"..rgba_to_hex(bad_dmg_color).."'>" .. ss .. "</span>"
                    end
                    dialog_2["defender_total_damage"].label = ss .."×"..math.floor(defender_stats.num_blows)
                    dialog_2["defender_chance_to_hit"].label = "<span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..defender_stats.chance_to_hit.. "%</span>"
                else
                    dialog_2["defender_base_damage"].label = "No usable weapon"
                    dialog_2["defender_resis"].label = ""
                    dialog_2["defender_resis_label"].label = ""
                    dialog_2["defender_resis_label"].visible = "hidden"
                    dialog_2["defender_tod_modifier"].label = ""
                    dialog_2["defender_tod_modifier_label"].label = ""
                    dialog_2["defender_tod_modifier_label"].visible = "hidden"
                    dialog_2["defender_leadership_modifier"].label = ""
                    dialog_2["defender_leadership_modifier_label"].label = ""
                    dialog_2["defender_leadership_modifier_label"].visible = "hidden"
                    dialog_2["defender_slowed_modifier"].label = ""
                    dialog_2["defender_slowed_modifier_label"].label = ""
                    dialog_2["defender_slowed_modifier_label"].visible = "hidden"
                end
            end
            function postshow(dialog_2)
            end
            gui.show_dialog(wml.get_child(attack_predictions, 'resolution'), preshow, postshow)
        end
    end
    function postshow(dialog)
        selected_index = dialog["weapon_list"].selected_index
    end
    local return_value=gui.show_dialog(wml.get_child(unit_attack, 'resolution'), preshow, postshow)
    if return_value == -1 then
        --wesnoth.interface.select_unit(unit.x,unit.y,false)

        --wesnoth.interface.select_unit(unit.x,unit.y)
        wesnoth.interface.deselect_hex()
        wesnoth.interface.select_unit()
        local path = wesnoth.paths.find_path({unit.x,unit.y},{attack_locations[weapon_index_list[selected_index][1]].x,attack_locations[weapon_index_list[selected_index][1]].y})
        local path_x,path_y = unit.x,unit.y
        for i=2, #path do
            path_x = path_x..","..path[i][1]
            path_y = path_y..","..path[i][2]
        end
        if attack_locations[weapon_index_list[selected_index][1]].x ~= unit.x or attack_locations[weapon_index_list[selected_index][1]].y ~= unit.y then
            wesnoth.wml_actions.do_command({
                {"move",{x=path_x, y=path_y}}
            })
        end
        if unit.x == attack_locations[weapon_index_list[selected_index][1]].x and unit.y == attack_locations[weapon_index_list[selected_index][1]].y then
            wesnoth.wml_actions.do_command({
                {"attack",{weapon = (weapon_index_list[selected_index][1] - 1),defender_weapon = (weapon_index_list[selected_index][2] - 1),{"source", {x = unit.x, y = unit.y}}, {"destination", {x = second_unit.x, y = second_unit.y}}}}
            })
        end
        wesnoth.interface.deselect_hex()
        wesnoth.interface.select_unit()
    else
        wesnoth.interface.deselect_hex()
        wesnoth.units.select(unit)
        --unit:extract()
        -- unit:to_map()
        -- unit.moves=0
        --unit.x=unit.x+1
        --unit.x=unit.x-1
        std_print("NO ATTACK")
        --wesnoth.wml_actions.do_command({{"fire_event",{name="empty_event"}}})
        -- wesnoth.wml_actions.object({id = "__real_ranged_attack_object_TEMP",take_only_once = false,silent = true,
        --     {"filter",{
        --         x = unit.x,
        --         y = unit.y
        --     }},
        --     {"effect",{
        --         apply_to = "new_attack",

        --             movement_used=0,
        --             damage=0,
        --             number=0,
        --             type="blade",
        --             attacks_used=0,


        --     }}
        -- })
        -- wesnoth.wml_actions.object({id = "__real_ranged_attack_object_TEMP",take_only_once = false,silent = true,
        --     {"filter",{
        --         x = unit.x,
        --         y = unit.y
        --     }},
        --     {"effect",{
        --         apply_to = "new_attack",

        --             movement_used=0,
        --             damage=0,
        --             number=0,
        --             type="blade",
        --             attacks_used=0,


        --     }}
        -- })
        -- unit.attacks[(#unit.attacks + 1)] = {type="blade",movement_used=0,attacks_used=0}
        -- second_unit.attacks[(#second_unit.attacks + 1)] = {type="blade",movement_used=0}
        -- wesnoth.wml_actions.do_command({
        --     {"attack",{
        --         weapon = (#unit.attacks - 1),
        --         defender_weapon = (#second_unit.attacks - 1),
        --         {"source", {x = unit.x, y = unit.y}},
        --         {"destination", {x = second_unit.x, y = second_unit.y}}
        --     }}
        -- })
        -- unit.attacks[#unit.attacks] = nil
        -- second_unit.attacks[#second_unit.attacks] = nil

        --unit.attacks_left=0
        --unit:to_map()
        -- wesnoth.wml_actions.do_command({
        --     {"move",{x=tostring(unit.x..","..unit.x),y=tostring(unit.y..","..(unit.y-1))}}
        -- })
        -- wesnoth.wml_actions.do_command({
        --     {"move",{x=tostring(unit.x..","..unit.x),y=tostring(unit.y..","..(unit.y+1))}}
        -- })
        --unit:extract()
        --wesnoth.game_events.fire("empty_event", unit.loc, second_unit.loc)
    end

    return true
end

-- wesnoth.wml_actions.do_command({
--     weapon = 1,
--     defender_weapon = 1,
--     {"attack", {{"source", {x =1, y = 1}}, {"destination", {x = 1, y = 2}}}}
-- }
-- )
-- unit.hitpoints = unit.max_hitpoints
-- unit.experience=0
-- animator = wesnoth.units.create_animator()
-- animator:add(unit,"recruited","hit",{})
-- animator:run()
>>


[/lua]
[event]
    name=unit_placed
    first_time_only=no
    [lua]
        code=<<
std_print("UNIT_PLACED")
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
--unit.attacks_left=1
        >>
    [/lua]
[/event]
[event]
    name=attack_end
    first_time_only=no
    [lua]
        code=<<
std_print("ATTACK END")
        >>
    [/lua]
[/event]
[event]
    name=attack
    first_time_only=no
    [lua]
        code=<<
std_print("ATTACK")
        >>
    [/lua]
[/event]
#  >>
#  [/lua]
    #  [if]
    #      [variable]
    #          name=turn_number
    #          formula="turn_number > 10 and turn_number % 2 = 0"
    #      [/variable]
    #      [then]
    #          [set_variable]
    #              name=gold_bonus
    #              formula="turn_number * 5"
    #          [/set_variable]
    #          [gold]
    #              side=1
    #              amount=$gold_bonus
    #          [/gold]
    #          [message]
    #              speaker=narrator
    #              message="You received a bonus of $gold_bonus gold!"
    #          [/message]
    #      [/then]
    #      [else]
    #          [message]
    #              speaker=narrator
    #              message="No bonus this turn."
    #          [/message]
    #      [/else]
    #  [/if]
#  [/event]
#  [event] #BREAKS THE GAME
#      name=attacker_hits
#  [lua]
#  code=<<
#  local unit = wesnoth.units.get(wml.variables["unit.id"])
#  wesnoth.game_events.fire("my_event", unit.loc, {10,10})
#  std_print(unit)
#  >>
#  [/lua]
#  [/event]
#  [event]
#      name=my_event
#  [kill]
#  id=$unit.id
#  [/kill]
#  [/event]
#  wesnoth.units.to_map({type="Orcish Grunt",x=2,y=1,side=1})
#  wesnoth.wml_actions.object({id = "parry_object",take_only_once = false,silent = true,
#          {"filter",{
#              x = "2",
#              y = "1"
#          }},
#          {"effect",{
#              apply_to = "new_ability",
#              {"abilities",{
#                  {"chance_to_hit",{
#                      id = "sample_effect",
#                      add = "(self.moves + 3)"
#                  }}
#              }}
#          }}
#      })
#  wesnoth.units.to_map({type="Elvish Fighter",x=2,y=2,side=2})
#  wesnoth.wml_actions.terrain({x=2,y=1,terrain='Uh'})
#  wesnoth.wml_actions.terrain({x=2,y=2,terrain='Uh'})
#  wesnoth.wml_actions.terrain({x=3,y=2,terrain='Uh'})
#  u=wesnoth.units.get({2,1})
#  u2=wesnoth.units.get({2,2})
#  _,_,att_st1,_ = wesnoth.simulate_combat(u, u2)
#  print("real attackers chance to hit: "..att_st1.chance_to_hit.."%")
#  u_dst = u:clone()
#  u_dst.x, u_dst.y = 3,2
#  _,_,att_st2,_ = wesnoth.simulate_combat(u_dst, u2)
#  print("virtual attackers (on 3,2) chance to hit: "..att_st2.chance_to_hit.."%")
#  u_dst:to_map()
#  _,_,att_st3,_ = wesnoth.simulate_combat(u_dst, u2)
#  print("real attackers (on 3,2) chance to hit: "..att_st3.chance_to_hit.."%")
