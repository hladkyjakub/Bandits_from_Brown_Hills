#This is for testing WML purpose (MEGA usefull)
#alias e3=lua wesnoth.require("wml-utils").handle_event_commands(wml.tovconfig(wml.load("~add-ons/Bandits_from_Brown_Hills/test_WML_event_3.cfg")))
#  [store_unit]
#      [filter]
#          type=Orcish Archer
#      [/filter]
#  [/store_unit]
#  [foreach]
#      array=unit.attack
#      [do]
#          [if]
#              [variable]
#                  name=unit.attack[$i].name
#                  equals=$unit.attack[1].name
#              [/variable]
#              [then]
#                  [message]
#                      speaker=narrator
#                      message="The condition is true!"
#                  [/message]
#                  [message]
#                      speaker=narrator
#                      message="$unit.attack[$i].name"
#                  [/message]
#                  [message]
#                      speaker=narrator
#                      message="$unit.attack[1].name"
#                  [/message]
#              [/then]
#          [/if]
#      [/do]
#  [/foreach]

    #  [store_unit]
    #      [filter]
    #          x,y=8,19
    #      [/filter]
    #      variable=unit
    #  [/store_unit]
    #  [store_unit]
    #      [filter]
    #          x,y=9,19
    #      [/filter]
    #      variable=second_unit
    #  [/store_unit]
#      [event] #TODO #NOW put this even inside unit_placed event, even in filter to prevent duping
#          name=unit_placed
#          first_time_only=yes
#          [lua]
#              code = <<
#  local ecx = wesnoth.current.event_context
#  local unit = wesnoth.units.get(ecx.x1, ecx.y1)

#  BfBH.unit.variables.add_to_list(unit, "my_list", "apple")
#  BfBH.unit.variables.add_to_list(unit, "my_list", "banana")
#  BfBH.unit.variables.add_to_list(unit, "my_list", "cherry")
#  local retrieved_list = unit.variables["my_list"]
#  local items = {}
#  for item in string.gmatch(retrieved_list, "[^,]+") do
#      std_print(item)
#      table.insert(items, item)
#  end
#  --BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
#  >>
#          [/lua]
#      [/event]

#  [lua]
#      code = <<
#  local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills" --Idk how to use it???
#  std_print(os.time())
#  local f_os_time = os.time
#  function os.time()
#  	local g = f_os_time()
#  	std_print(100)
#  	return g
#  end
#  >>
#  [/lua]

#  local coroutine = require("coroutine")

#  function sleep(seconds)
#      local start = os.time()
#      while os.time() - start < seconds do
#          coroutine.yield()
#      end
#  end

#  function my_fc()
#      print("Starting my_fc")
#      print("Pausing for 5 minutes")
#      sleep(300)  -- 300 seconds = 5 minutes
#      print("Resuming my_fc after 5 minutes")
#      -- Rest of your function code here
#  end

#  -- Create a coroutine
#  local co = coroutine.create(my_fc)

#  -- Function to resume the coroutine
#  local function resume_coroutine()
#      if coroutine.status(co) ~= "dead" then
#          coroutine.resume(co)
#      end
#  end

#  -- Main loop
#  while coroutine.status(co) ~= "dead" do
#      resume_coroutine()
#      -- You might want to add a small delay here to prevent busy-waiting
#      -- For example: os.execute("sleep 0.1")
#  end






#  [lua]
#      [args]
#          {WEAPON_SPECIAL_BLEED}
#          {ABILITY_ADAPTIVE_ARMOR}
#          {WEAPON_SPECIAL_BULLSEYE}
#          {WEAPON_SPECIAL_TEMPO_SURGE}
#          {WEAPON_SPECIAL_KNOCKBACK}
#          #...
#      [args]
#      code=<<
#  local effects = {}
#  local ecx = wesnoth.current.event_context
#  local unit = wesnoth.units.get(ecx.x1, ecx.y1)
#  unit:add_modification("object", effects)
#      >>
#  [/lua]





#  [event]
#      name=attack
#      first_time_only=yes
#      [store_unit]
#          [filter]
#              x,y=$x1,$y1
#          [/filter]
#          variable=unit
#      [/store_unit]
#      [store_unit]
#          [filter]
#              x,y=$x2,$y2
#          [/filter]
#          variable=second_unit
#      [/store_unit]
#  [lua]
#      code=<<
#      function printTable(t, indent)
#          indent = indent or 0
#          local indentation = string.rep("  ", indent)
    
#          if type(t) ~= "table" then
#              std_print(indentation .. tostring(t))
#              return
#          end
    
#          print(indentation .. "{")
#          for key, value in pairs(t) do
#              local formattedKey
#              if type(key) == "number" then
#                  formattedKey = "[" .. key .. "]"
#              else
#                  formattedKey = tostring(key)
#              end
            
#              if type(value) == "table" then
#                  std_print(indentation .. "  " .. formattedKey .. " =")
#                  printTable(value, indent + 1)
#              else
#                  std_print(indentation .. "  " .. formattedKey .. " = " .. tostring(value))
#              end
#          end
#          std_print(indentation .. "}")
#      end

#  local function choose_defender_weapon(attacker, defender, attacker_weapon)
#      local i = 0
#      while wml.variables[""..defender.."[0].attack["..i.."]"] ~= nil do
#          if wml.variables[""..defender.."[0].attack["..i.."].range"] == wml.variables[""..attacker.."[0].attack["..attacker_weapon.."].range"] then
#              local a1, b1, c1, d1 =wesnoth.simulate_combat(wesnoth.units.get(wml.variables[""..attacker.."[0].id"]),(attacker_weapon + 1), wesnoth.units.get(wml.variables[""..defender.."[0].id"]))
#              local a2, b2, c2, d2 =wesnoth.simulate_combat(wesnoth.units.get(wml.variables[""..attacker.."[0].id"]),(attacker_weapon + 1), wesnoth.units.get(wml.variables[""..defender.."[0].id"]), (i + 1))
#              if BfBH.table.deep_compare(a1,a2) and BfBH.table.deep_compare(b1,b2) and BfBH.table.deep_compare(c1,c2) and BfBH.table.deep_compare(d1,d2) then
#                  return i
#              end
#          end
#          i = i + 1
#      end
#      return false
#  end
#  std_print(choose_defender_weapon("unit", "second_unit", 1))
[lua]
    code=<<
    BfBH.unit.cool_move = function (cfg)
    local coordinate_error = "invalid location in BfBH.unit.cool_move"
	local path
	if cfg.to_location then
		path = {location_id = cfg.to_location}
	elseif cfg.dir then
		path = {dir = cfg.dir}
	else
		path = {to_x = cfg.to_x, to_y = cfg.to_y}
	end
	if not path then
		wml.error(coordinate_error)
	end
	local fire_event = cfg.fire_event
	local unshroud = cfg.clear_shroud
	local muf_force_scroll = cfg.force_scroll
	local check_passability = cfg.check_passability
	if check_passability == nil then check_passability = true end
	cfg = wml.literal(cfg)
	cfg.to_location, cfg.to_x, cfg.to_y, cfg.fire_event, cfg.clear_shroud = nil, nil, nil, nil, nil
	local units = wesnoth.units.find_on_map(cfg)

	for current_unit_index, current_unit in ipairs(units) do
		if not fire_event or current_unit.valid then
			local locs = BfBH.unit.path_locs(path)
			local x_list = {current_unit.x}
			local y_list = {current_unit.y}
			local pass_check = nil
			if check_passability then pass_check = current_unit end

			current_unit:extract()
			local x, y = locs(current_unit)
			local prevX, prevY = tonumber(current_unit.x), tonumber(current_unit.y)
			while true do
				x = tonumber(x) or current_unit:to_map(false) or wml.error(coordinate_error)
				y = tonumber(y) or current_unit:to_map(false) or wml.error(coordinate_error)
				if not (x == prevX and y == prevY) then x, y = wesnoth.paths.find_vacant_hex(x, y, pass_check) end
				if not x or not y then wml.error("Could not find a suitable hex near to one of the target hexes in [move_unit].") end
				table.insert(x_list, x)
				table.insert(y_list, y)
				local next_x, next_y = locs(current_unit)
				if not next_x and not next_y then break end
				prevX, prevY = x, y
				x, y = next_x, next_y
			end

			if current_unit.x < x then current_unit.facing = "se"
			elseif current_unit.x > x then current_unit.facing = "sw"
			end
            
			local current_unit_cfg = current_unit.__cfg
            current_unit:to_map(false)
            local path_found
            local animator = wesnoth.units.create_animator()
			for i = 1, (#x_list - 1) do
                path_found = wesnoth.paths.find_path(x_list[i], y_list[i], x_list[i+1], y_list[i+1])
                for i2 = 1, (#path_found - 1) do
                    local distance = wesnoth.map.distance_between({path_found[i2][1],path_found[i2][2]},{path_found[i2+1][1],path_found[i2+1][2]})
                    std_print(distance)
                    if distance == 1 then
                        current_unit.facing=wesnoth.map.get_relative_dir({path_found[i2][1],path_found[i2][2]},{path_found[i2+1][1],path_found[i2+1][2]})
                        wesnoth.wml_actions.redraw {clear_shroud=true}
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2][1],path_found[i2][2]}) then
                            wesnoth.game_events.fire("exit_hex", {path_found[i2][1],path_found[i2][2]}, {path_found[i2+1][1],path_found[i2+1][2]})
                        end
                        animator:add(current_unit, "movement", "miss", {value= {i2-1,#path_found - i2}})
                        animator:run()
                        animator:clear()
                        current_unit:extract()
                        current_unit.x, current_unit.y = path_found[i2+1][1], path_found[i2+1][2]
                        --std_print(path_found[i2+1][1], path_found[i2+1][2])
                        current_unit:to_map(false)
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2+1][1],path_found[i2+1][2]}) then
                            wesnoth.game_events.fire("enter_hex", {path_found[i2+1][1],path_found[i2+1][2]}, {path_found[i2][1],path_found[i2][2]})
                        end
                    elseif distance > 1 then
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2][1],path_found[i2][2]}) then
                            wesnoth.game_events.fire("exit_hex", {path_found[i2][1],path_found[i2][2]}, {path_found[i2+1][1],path_found[i2+1][2]})
                        end
                        animator:add(current_unit, "pre_teleport", "hit", {})
                        animator:run()
                        animator:clear()
                        current_unit:extract()
                        current_unit.x, current_unit.y = path_found[i2+1][1], path_found[i2+1][2]
                        animator:add(current_unit, "post_teleport", "hit", {})
                        animator:run()
                        animator:clear()
                        current_unit:to_map(false)
                        if current_unit.valid == 'map' and BfBH.table.deep_compare(current_unit.loc, {path_found[i2+1][1],path_found[i2+1][2]}) then
                            wesnoth.game_events.fire("enter_hex", {path_found[i2+1][1],path_found[i2+1][2]}, {path_found[i2][1],path_found[i2][2]})
                        end
                    else
                        --it's the same location, nothing should happen, not even moveto if only those moves hapened
                    end
                end
            end
			local x2, y2 = current_unit.x, current_unit.y
			--current_unit.x, current_unit.y = x, y
			--current_unit:to_map(false)
			if unshroud then
				wesnoth.wml_actions.redraw {clear_shroud=true}
			end

			if fire_event then
				wesnoth.game_events.fire("moveto", x, y, x2, y2)
			end
		end
	end
end
-- BfBH.unit.cool_move({to_x='22', to_y='24',x = 8, y=18})
-- BfBH.unit.cool_move({to_x='21', to_y='24',x = 7, y=19})
--wesnoth.wml_actions.move_unit({to_x=10, to_y=20,id="jareth"})


-- Create a coroutine for the movement
-- local co = coroutine.create(function()
--     -- Start the fake movement
--     wesnoth.wml_actions.move_unit_fake({
--         type = "Elvish Archer",
--         x = "1,2,3,10",
--         y = "1,1,1,10"
--     })
    
--     -- Yield the coroutine to allow for the delay
--     coroutine.yield()
    
--     -- Code to execute after jumping back
--     -- For example, you might want to remove the unit or perform other actions
--     std_print("Movement completed and jumped back!")
-- end)


-- -- Create the coroutine
-- -- local co = coroutine.create(function()
-- --     while true do
-- --         std_print("Coroutine is running")
-- --         coroutine.yield()
-- --     end
-- -- end)
-- local function getTime()
--     return os.time() * 1000 + os.clock() * 1000
-- end
-- coroutine.resume(co)
-- local start = getTime()
-- while getTime() - start < 200 do
-- end
-- std_print("Coroutine stopped")
my_function = function()
    while true do
      -- This function will run indefinitely
    end
  end
  
--   local function run_with_timeout(func, timeout)
--     local co = coroutine.create(func)
    
--     local start_time = os.time()
--     debug.sethook(co, function()
--       if os.time() - start_time >= timeout then
--         error("timeout")
--       end
--     end, "", 1000)  -- Check time every 1000 instructions
    
--     local status, err = coroutine.resume(co)
--     debug.sethook(co)  -- Clear the hook
    
--     if err == "timeout" then
--       print("Function stopped after " .. timeout .. " second(s)")
--     elseif err then
--       print("Error: " .. tostring(err))
--     end
--   end
  
--   print("Start time:", os.time())
--   run_with_timeout(my_function, 4)
--   print("End time:", os.time())
>>
[/lua]

[event]
    name=side turn end
    first_time_only=yes
    [floating_text]
        x,y=20,20
        text="<span color='#cccc33'>" + _ "Your text here" + "</span>"
     [/floating_text]
[/event]
[lua]
    code=<<
wesnoth.game_events.on_mouse_move = function(x, y)
    if not(wesnoth.interface.get_selected_hex() and wesnoth.interface.get_hovered_hex()) then
        return false
    end
    local unit = wesnoth.units.get(wesnoth.interface.get_selected_hex() )
    local second_unit = wesnoth.units.get(wesnoth.interface.get_hovered_hex() )
    if not(unit and second_unit and unit.side == wml.variables["side_number"] and wesnoth.sides.is_enemy(unit.side,second_unit.side)) then
        return false
    end
    local distance = wesnoth.map.distance_between(unit.loc, second_unit.loc)
    if distance == 1 then
        return false
    end
    local attack = "empty"
    local attacking_weapon_index
    for i = 1, #unit.attacks do
        if unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range then
            attack = unit.attacks[i] --for the menu, then I guess
            attacking_weapon_index = i - 1
        end
    end
    if attack == "empty" then
        return false
    end
    std_print("need custom display(instead of the melee attack one (with move))")
    return true
end
wesnoth.game_events.on_mouse_button = function(x, y, button, event)
    if not (button == "left" and event == "click") then
        return false
    end
    if not(wesnoth.interface.get_selected_hex() and wesnoth.interface.get_hovered_hex()) then
        return false
    end
    local unit = wesnoth.units.get(wesnoth.interface.get_selected_hex() )
    local second_unit = wesnoth.units.get(wesnoth.interface.get_hovered_hex() )
    if not(unit and second_unit and unit.side == wml.variables["side_number"] and wesnoth.sides.is_enemy(unit.side,second_unit.side)) then
        return false
    end
    local distance = wesnoth.map.distance_between(unit.loc, second_unit.loc)
    if distance == 1 then
        return false
    end
    local attack = "empty"
    local attacking_weapon_index
    for i = 1, #unit.attacks do
        if unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range then
            attack = unit.attacks[i] --for the menu, then I guess
            attacking_weapon_index = i - 1
        end
    end
    if attack == "empty" then
        return false
    end
    local unit_attack = wml.load '~add-ons/Bandits_from_Brown_Hills/gui/unit_attack.cfg'
    local attack_predictions = wml.load '~add-ons/Bandits_from_Brown_Hills/gui/attack_predictions.cfg'
    local red_green_scale="df0000,e20000,e40000,e70000,ea0000,ec0000,ef0000,f20000,f40000,f70000,fa0000,fc0000,ff0000,ff0500,ff0b00,ff1000,ff1500,ff1b00,ff2000,ff2500,ff2b00,ff3000,ff3500,ff3a00,ff4000,ff4500,ff4a00,ff5000,ff5500,ff5a00,ff6000,ff6500,ff6a00,ff7000,ff7500,ff7a00,ff8000,ff8500,ff8a00,ff8f00,ff9500,ff9a00,ff9f00,ffa500,ffaa00,ffaf00,ffb500,ffba00,ffbf00,ffc500,ffca00,ffcf00,ffd500,ffda00,ffdf00,ffe400,ffea00,ffef00,fff400,fffa00,ffff00,faff00,f4ff00,efff00,eaff00,e4ff00,dfff00,daff00,d5ff00,cfff00,caff00,c5ff00,bfff00,baff00,b5ff00,afff00,aaff00,a5ff00,9fff00,9aff00,95ff00,8fff00,8aff00,85ff00,80ff00,7aff00,75ff00,70ff00,6aff00,65ff00,60ff00,5aff00,55ff00,50ff00,4aff00,45ff00,40ff00,3aff00,35ff00,30ff00,2bff00,25ff00,20ff00,1bff00,15ff00,10ff00,0bff00,05ff00,00ff00,00fc00,00fa00,00f700,00f400,00f200,00ef00,00ec00,00ea00,00e700,00e400,00e200,00df00"
    local unit_type_color="f5e6c1"
    local good_dmg_color     ={130,240,50,255}
	local bad_dmg_color      ={250,140,80,255}
    local function rgba_to_hex(color)
        return string.format("#%02X%02X%02X%02X", color[1], color[2], color[3], color[4])
    end
    local function xp_color(xp_to_advance,can_advance,has_amla)
        local near_advance_color ={255,255,255,255}
        local mid_advance_color  ={150,255,255,255}
        local far_advance_color  ={0,205,205,255}
        local normal_color       ={0,160,225,255}
        local near_amla_color    ={225,0,255,255}
        local mid_amla_color     ={169,30,255,255}
        local far_amla_color     ={139,0,237,255}
        local amla_color         ={170,0,255,255}

        local near_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience
        local mid_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience * 2
        local far_advance = math.floor(xp_to_advance) <= wesnoth.game_config.kill_experience * 3

        local color = normal_color
        if can_advance then
            if near_advance then
                color = near_advance_color
            elseif mid_advance then
                color = mid_advance_color
            elseif far_advance then
                color = far_advance_color
            end
        else
            if has_amla then
                if near_advance then
                    color = near_amla_color
                elseif mid_advance then
                    color = mid_amla_color
                elseif far_advance then
                    color = far_amla_color
                else
                    color = amla_color
                end
            end
        end
        return(color)
    end
    local function red_green_scale_function(value)
        value = math.max(0.0, math.min(100.0, value))
        local colors = {}
        for color in red_green_scale:gmatch("[^,]+") do
            table.insert(colors, color)
        end
        local index = math.floor(value / 100 * (#colors - 1)) + 1
        return colors[index]
    end
    function hp_color(hitpoints, max_hitpoints)
        local unit_energy = 0.0
        local energy_color = {0, 0, 0, 255}  -- {r, g, b, a}
    
        if max_hitpoints > 0 then
            unit_energy = hitpoints / max_hitpoints
        end
    
        if unit_energy == 1.0 then
            energy_color[1] = 33
            energy_color[2] = 225
            energy_color[3] = 0
        elseif unit_energy > 1.0 then
            energy_color[1] = 100
            energy_color[2] = 255
            energy_color[3] = 100
        elseif unit_energy >= 0.75 then
            energy_color[1] = 170
            energy_color[2] = 255
            energy_color[3] = 0
        elseif unit_energy >= 0.5 then
            energy_color[1] = 255
            energy_color[2] = 175
            energy_color[3] = 0
        elseif unit_energy >= 0.25 then
            energy_color[1] = 255
            energy_color[2] = 155
            energy_color[3] = 0
        else
            energy_color[1] = 255
            energy_color[2] = 0
            energy_color[3] = 0
        end
    
        return energy_color
    end
    function table_to_string(input)
        local result = {}
        for i, v in ipairs(input) do
            table.insert(result, tostring(v))
        end
        return table.concat(result, ", ")
    end
    local leader_crown = "misc/leader-crown.png"
    local size_normal=17
    local size_small = 15 * (size_normal / 17)
    local AH = wesnoth.require "ai/lua/ai_helper.lua"
    local function unit_attack_info(unit, cache) --FROM battle.calcs
        local cind = 'UI-' .. unit.id .. unit.max_hitpoints .. unit.side
    
        -- If cache for this unit exists, return it
        if cache and cache[cind] then
            return cache[cind]
        end
    
        -- Otherwise collect the information
        local unit_info = {
            attacks = {},
            resist_mod = {},
            alignment = unit.alignment
        }
        local attacks = unit.attacks
        for i_a = 1,#attacks do
            local attack = attacks[i_a]
            -- Extract information for specials; we do this first because some
            -- custom special might have the same name as one of the default scalar fields
            local a = {}
            for _,sp in ipairs(attack.specials) do
                if (sp[1] == 'damage') then  -- this is 'backstab'
                    if (sp[2].id == 'backstab') then
                        a.backstab = true
                    else
                        if (sp[2].id == 'charge') then a.charge = true end
                    end
                else
                    if (sp[1] == 'chance_to_hit') then
                        a[sp[2].id or 'no_id'] = true
                    else
                        a[sp[1]] = true
                    end
                end
            end
            a.damage = attack.damage
            a.type = attack.type
            a.range = attack.range
            a.number = attack.number or 0
            table.insert(unit_info.attacks, a)
        end
        local attack_types = { "arcane", "blade", "cold", "fire", "impact", "pierce" }
        for _,attack_type in ipairs(attack_types) do
            unit_info.resist_mod[attack_type] = 1 - unit:resistance_against(attack_type) / 100.
        end
        if cache then cache[cind] = unit_info end
        return unit_info
    end    
    local function strike_damage(attacker, defender, att_weapon, def_weapon, dst, cache)
        local att_lawful_bonus = wesnoth.schedule.get_illumination(dst).lawful_bonus
        local def_lawful_bonus = wesnoth.schedule.get_illumination(defender).lawful_bonus
        local cind = 'SD-' .. attacker.id .. attacker.max_hitpoints .. attacker.side
        cind = cind .. 'x' .. defender.id .. defender.max_hitpoints .. defender.side
        cind = cind .. '-' .. att_weapon .. 'x' .. def_weapon
        cind = cind .. '-' .. att_lawful_bonus .. 'x' .. def_lawful_bonus
        if cache and cache[cind] then
            return cache[cind].att_damage, cache[cind].def_damage, cache[cind].att_attack, cache[cind].def_attack
        end
        local attacker_info = unit_attack_info(attacker, cache)
        local defender_info = unit_attack_info(defender, cache)
        local att_damage = attacker_info.attacks[att_weapon].damage
        local att_multiplier = defender_info.resist_mod[attacker_info.attacks[att_weapon].type] or 1
        att_multiplier = att_multiplier * AH.get_unit_time_of_day_bonus(attacker_info.alignment, att_lawful_bonus)
        local def_damage, def_multiplier = 0, 1.
        if (def_weapon ~= 0) then
            def_damage = defender_info.attacks[def_weapon].damage
            def_multiplier = attacker_info.resist_mod[defender_info.attacks[def_weapon].type] or 1
            def_multiplier = def_multiplier * AH.get_unit_time_of_day_bonus(defender_info.alignment, def_lawful_bonus)
        end
        if attacker_info.attacks[att_weapon].charge then
            att_damage = att_damage * 2
            def_damage = def_damage * 2
        end
        if (att_multiplier > 1) then
            att_damage = mathx.round(att_damage * att_multiplier - 0.001)
        else
            att_damage = mathx.round(att_damage * att_multiplier + 0.001)
        end
        if (def_weapon ~= 0) then
            if (def_multiplier > 1) then
                def_damage = mathx.round(def_damage * def_multiplier - 0.001)
            else
                def_damage = mathx.round(def_damage * def_multiplier + 0.001)
            end
        end
        if cache then
            cache[cind] = {
                att_damage = att_damage,
                def_damage = def_damage,
                att_attack = attacker_info.attacks[att_weapon],
                def_attack = defender_info.attacks[def_weapon]
            }
        end
        return att_damage, def_damage, attacker_info.attacks[att_weapon], defender_info.attacks[def_weapon]
    end
    local function best_weapons(attacker, defender, dst, cache)
        local att_lawful_bonus = wesnoth.schedule.get_illumination(dst).lawful_bonus
        local def_lawful_bonus = wesnoth.schedule.get_illumination(defender).lawful_bonus
        local cind = 'BW-' .. attacker.id .. attacker.max_hitpoints .. attacker.side
        cind = cind .. 'x' .. defender.id .. defender.max_hitpoints .. defender.side
        cind = cind .. '-' .. att_lawful_bonus .. 'x' .. def_lawful_bonus
        if cache and cache[cind] then
            return cache[cind].best_att_weapon, cache[cind].best_def_weapon
        end
        local attacker_info = unit_attack_info(attacker, cache)
        local defender_info = unit_attack_info(defender, cache)
        local max_rating, best_att_weapon, best_def_weapon = - math.huge, 0, 0
        for att_weapon_number,att_weapon in ipairs(attacker_info.attacks) do
            local att_damage = strike_damage(attacker, defender, att_weapon_number, 0, { dst[1], dst[2] }, cache)
            local max_def_rating, tmp_best_def_weapon = - math.huge, 0
            for def_weapon_number,def_weapon in ipairs(defender_info.attacks) do
                if (def_weapon.range == att_weapon.range) then
                    local def_damage = strike_damage(defender, attacker, def_weapon_number, 0, { defender.x, defender.y }, cache)
                    local def_rating = def_damage * def_weapon.number
                    if (def_rating > max_def_rating) then
                        max_def_rating, tmp_best_def_weapon = def_rating, def_weapon_number
                    end
                end
            end
            local rating = att_damage * att_weapon.number
            if (max_def_rating > - math.huge) then rating = rating - max_def_rating / 2. end
            if (rating > max_rating) then
                max_rating, best_att_weapon, best_def_weapon = rating, att_weapon_number, tmp_best_def_weapon
            end
        end
        if cache then
            cache[cind] = { best_att_weapon = best_att_weapon, best_def_weapon = best_def_weapon }
        end
        return best_att_weapon, best_def_weapon
    end
    local function draw_hp_graph(hp_graph, attacker, defender, attacker_weapon_index, for_unit)
        local for_unit = for_unit or "attacker"
        local background_color_disabled = "64, 64, 64, 64"
        local font_color_disabled = "128, 128, 128, 255"
        local graph_width = 270
        local graph_height = 170
        local graph_max_rows = 10
        local fs = size_small
        local hp_sep = 30
        local percent_sep = 50
        local bar_space = graph_width - hp_sep - percent_sep - 4
        local contents = {wml.tag.rectangle
        {
            x = 0,
            y = 0,
            w = "(width)",
            h = "(height)",
            fill_color = background_color_disabled,
            border_thickness = 2,
            border_color = font_color_disabled
        },wml.tag.rectangle
        {
            x =hp_sep,
            y = 0,
            w = 2,
            h = "(height - 2)",
            fill_color =font_color_disabled
        },wml.tag.rectangle
        {
            x = "(width-2)"..-percent_sep,
            y = 0,
            w = 2,
            h = "(height - 2)",
            fill_color =font_color_disabled
        }
        }
        std_print(attacker_weapon_index)
        local attacker_condition,defender_condition,attacker_stats,defender_stats = wesnoth.simulate_combat(attacker,attacker_weapon_index,defender)
        local unit = attacker
        local unit_condition = attacker_condition
        local unit_stats = attacker_stats
        local second_unit =  defender
        local second_unit_condition = defender_condition
        local second_unit_stats = defender_stats
        if for_unit ~= "attacker" then
            unit = defender
            unit_condition = defender_condition
            unit_stats = defender_stats
            second_unit =  attacker
            second_unit_condition = attacker_condition
            second_unit_stats = attacker_stats
        end
        local pair_table = {}
        for index, value in pairs(unit_condition.hp_chance) do
            if value ~= 0 then
                table.insert(pair_table, {value = value, index = index})
            end
        end
        table.sort(pair_table, function(a, b) return a.value > b.value end)
        local top_ten = {}
        for i = 1, math.min(10, #pair_table) do
            table.insert(top_ten, pair_table[i])
        end
        table.sort(top_ten, function(a, b) return a.index > b.index end)
        for i = 1, math.min(10, #top_ten) do
            local hp = top_ten[i].index
            local prob = top_ten[i].value
            local row_color
            if hp == 0 then
                row_color = {229, 0, 0}
            elseif hp < unit.hitpoints then
                if second_unit_stats.petrifies then
                    row_color = {154, 154, 154}
                else
                    row_color = {244, 201, 0}
                end
            else
                row_color = {8, 202, 0}
            end
            local bar_len = math.max(math.floor((prob * (bar_space - 4)) + 0.5), 2)
            table.insert(contents,wml.tag.rectangle
            {
                x = hp_sep + 4,
                y = 6 + (fs + 2) * (i - 1),
                w = bar_len,
                h = 8,
                fill_color = string.format("%d, %d, %d", row_color[1], row_color[2], row_color[3]),
            })
            table.insert(contents,wml.tag.text 
            {
                text = tostring(hp),
                x = 4,
                y = 2 + (fs + 2) * (i - 1),
                w = "(text_width)",
                h = "(text_height)",
                font_size = 12,
                color = "255, 255, 255, 255",
                text_alignment = "(text_alignment)",
            })
            table.insert(contents,wml.tag.text 
            {
                text = string.format("%.1f", (prob*100)).."%",
                x = graph_width - percent_sep + 2,
                y = 2 + (fs + 2) * (i - 1),
                w = "(text_width)",
                h = "(text_height)",
                font_size = 12,
                color = "255, 255, 255, 255",
                text_alignment = "(text_alignment)",
            })
        end
        hp_graph:set_canvas(1,contents)
    end
    local weapon_index_list={}
    local selected_index
    function preshow(dialog) --#TODO missing specials, abilities (both in weapon list and combat statistics), no idea what label_helper is, skipping, end no-mainline-dialog, get rid of the gray and selected units
        local unit_advances_to = unit.advances_to[1] ~= nil
        local unit_amla = unit.advancements[1] ~= nil
        local unit_mods = "~RC(magenta>" ..wesnoth.sides[unit.side].color .. ")"..unit.image_mods
        if unit.canrecruit then
            unit_mods = unit_mods .. "~BLIT(" .. leader_crown .. ")"
        end
        for i2 = 1, #unit.overlays do
            unit_mods = unit_mods .. "~BLIT(" .. unit.overlays[i2] .. ")"
        end
        dialog["attacker_pane"].type_image.label=unit.__cfg.image .. unit_mods
        dialog["attacker_pane"].type_details_minimal.use_markup = true
        dialog["attacker_pane"].type_details_minimal.label="<span size='large'>"..unit.name.."</span>\n"
        .."<span color='#"..unit_type_color.."'>"..unit.__cfg.language_name.."</span>\n"
        .."Lvl "..unit.level.."\n"
        ..unit.alignment.."\n"
        ..table_to_string(unit.traits).."\n"
        .."<span color='"..rgba_to_hex(hp_color(unit.hitpoints,unit.max_hitpoints)).."'>HP: "..unit.hitpoints.."/"..unit.max_hitpoints.."</span>\n"
        .."<span color='"..rgba_to_hex(xp_color(unit.max_experience - unit.experience,unit_advances_to,unit_amla)).."'>XP: "..unit.experience.."/"..unit.max_experience.."</span>"
        --dialog["attacker_pane"].type_name.label="type_name"
        dialog["attacker_pane"].type_profile.on_button_click= function() gui.show_help("unit_"..unit.type) end
        
        local second_unit_advances_to = second_unit.advances_to[1] ~= nil
        local second_unit_amla = second_unit.advancements[1] ~= nil
        local second_unit_mods = "~RC(magenta>" ..wesnoth.sides[second_unit.side].color .. ")"..second_unit.image_mods
        if second_unit.canrecruit then
            second_unit_mods = second_unit_mods .. "~BLIT(" .. leader_crown .. ")"
        end
        for i2 = 1, #second_unit.overlays do
            second_unit_mods = second_unit_mods .. "~BLIT(" .. second_unit.overlays[i2] .. ")"
        end
        second_unit_mods = second_unit_mods .. "~FL(horiz)"
        dialog["defender_pane"].type_image.label=second_unit.__cfg.image .. second_unit_mods
        dialog["defender_pane"].type_details_minimal.use_markup = true
        dialog["defender_pane"].type_details_minimal.label="<span size='large'>"..second_unit.name.."</span>\n"
        .."<span color='#"..unit_type_color.."'>"..second_unit.__cfg.language_name.."</span>\n"
        .."Lvl "..second_unit.level.."\n"
        ..second_unit.alignment.."\n"
        ..table_to_string(second_unit.traits).."\n"
        .."<span color='"..rgba_to_hex(hp_color(second_unit.hitpoints,second_unit.max_hitpoints)).."'>HP: "..second_unit.hitpoints.."/"..second_unit.max_hitpoints.."</span>\n"
        .."<span color='"..rgba_to_hex(xp_color(second_unit.max_experience - second_unit.experience,second_unit_advances_to,second_unit_amla)).."'>XP: "..second_unit.experience.."/"..second_unit.max_experience.."</span>"
        dialog["defender_pane"].type_profile.on_button_click= function() gui.show_help("unit_"..second_unit.type) end
        
        
        local weapon_row = 1
        for i = 1, #unit.attacks do
            if unit.attacks[i].__cfg.max_range >= distance and distance >= unit.attacks[i].__cfg.min_range then
                local weapon = unit.attacks[i]
                local _,_,attacker_stats,defender_stats = wesnoth.simulate_combat(unit, i, second_unit)
                local second_weapon = nil
                if defender_stats.attack_num ~= -1 then
                    second_weapon = second_unit.attacks[defender_stats.attack_num + 1]
                end
                weapon_index_list[#weapon_index_list + 1] = {i, defender_stats.attack_num + 1}
                dialog["weapon_list"][weapon_row].attacker_weapon.use_markup = true
                dialog["weapon_list"][weapon_row].attacker_weapon_icon.label = weapon.icon
                dialog["weapon_list"][weapon_row].attacker_weapon.label="<b>"..weapon.name.."</b>\n"
                ..weapon.type.."\n"
                ..mathx.round(attacker_stats.damage).."×"..mathx.round(attacker_stats.num_blows).."\n"
                .."<span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..mathx.round(attacker_stats.chance_to_hit).."%</span>"
                dialog["weapon_list"][weapon_row].attacker_weapon.tooltip="Weapon: <b>"..weapon.name.."</b>\n"
                .."Type: "..weapon.type.."\n"
                .."Damage: "..mathx.round(attacker_stats.damage).."\n"
                .."Attacks: "..mathx.round(attacker_stats.num_blows).."\n"
                .."Chance to hit: <span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..mathx.round(attacker_stats.chance_to_hit).."%</span>"
                dialog["weapon_list"][weapon_row].range.use_markup = true
                dialog["weapon_list"][weapon_row].range.label="<span color='#a69275'>— "..weapon.range.." —</span>"
                dialog["weapon_list"][weapon_row].defender_weapon.use_markup = true
                if second_weapon ~= nil then 
                    dialog["weapon_list"][weapon_row].defender_weapon_icon.label = second_weapon.icon
                    dialog["weapon_list"][weapon_row].defender_weapon.label="<b>"..second_weapon.name.."</b>\n"
                    ..second_weapon.type.."\n"
                    ..mathx.round(defender_stats.damage).."×"..mathx.round(defender_stats.num_blows).."\n"
                    .."<span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..mathx.round(defender_stats.chance_to_hit).."%</span>"
                    dialog["weapon_list"][weapon_row].defender_weapon.tooltip="Weapon: <b>"..second_weapon.name.."</b>\n"
                    .."Type: "..second_weapon.type.."\n"
                    .."Damage: "..mathx.round(defender_stats.damage).."\n"
                    .."Attacks: "..mathx.round(defender_stats.num_blows).."\n"
                    .."Chance to hit: <span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..mathx.round(defender_stats.chance_to_hit).."%</span>"
                else
                    dialog["weapon_list"][weapon_row].defender_weapon_icon.label = "attacks/blank-attack.png"
                    dialog["weapon_list"][weapon_row].defender_weapon.label="<b>".."".."</b>\n"
                    .."".."\n"
                    .."0".."×".."0".."\n"
                    .."<span color='#"..red_green_scale_function(0).."'>".."0".."%</span>"
                end
                weapon_row = weapon_row + 1
                BfBH.table.std_print(attacker_stats)
            end
        end
        local best_weapon= best_weapons(unit, second_unit, unit.loc)
        local iter = 1
        while weapon_index_list[iter][1] ~= best_weapon do 
            iter=iter+1
        end
        dialog["weapon_list"].selected_index = iter
        dialog.damage_calculation.on_button_click= function()
            function preshow(dialog_2)
                local weapon_index = weapon_index_list[dialog["weapon_list"].selected_index][1]
                local weapon = unit.attacks[weapon_index]
                local attacker_condition,defender_condition,attacker_stats,defender_stats = wesnoth.simulate_combat(unit,weapon_index,second_unit)
                local opp_weapon_index = nil
                local opp_weapon = nil
                if defender_stats.attack_num ~= -1 then
                    opp_weapon_index = weapon_index_list[dialog["weapon_list"].selected_index][2]
                    opp_weapon = second_unit.attacks[opp_weapon_index]
                end
                draw_hp_graph(dialog_2["attacker_hp_graph"],unit,second_unit,weapon_index)
                draw_hp_graph(dialog_2["defender_hp_graph"],unit,second_unit,weapon_index,"defender")
                dialog_2["attacker_chance_unscathed"].label = "<span color='#"..red_green_scale_function(attacker_condition.untouched * 100).."'>"..string.format("%.1f", (attacker_condition.untouched * 100)).."%</span>"
                if unit.attacks[weapon_index] then
                    dialog_2["attacker_base_damage"].label = unit.attacks[weapon_index].damage.." (<i>"..unit.attacks[weapon_index].name.."</i>)"
                    local resistance_modifier = 100 - wesnoth.units.resistance_against(second_unit, weapon.type)
                    if resistance_modifier ~= 100 then
                        local ss = ""
                        if resistance_modifier < 100 then
                            ss = ss..("Attacker resistance vs").." " --#TODOmake it translate-able string
                        else
                            ss = ss..("Attacker vulnerability vs").." " --#TODO make it translate-able string
                        end
                        dialog_2["attacker_resis"].label = "×" .. math.floor(resistance_modifier / 100) .. "." .. math.floor((resistance_modifier % 100) / 10)
                        dialog_2["attacker_resis_label"].label=ss .. weapon.type
                        dialog_2["attacker_resis_label"].visible="visible"
                    else
                        dialog_2["attacker_resis"].label = ""
                        dialog_2["attacker_resis_label"].label = ""
                        dialog_2["attacker_resis_label"].visible = "hidden"
                    end
                    --wesnoth.map.get(unit.loc).illuminated_time --#TODO
                    --unit.alignment
                    --#wesnoth.units.find({fearless=true,x=unit.x,y=unit.y})
                    dialog_2["attacker_tod_modifier"].label = ""
                    dialog_2["attacker_tod_modifier_label"].label = ""
                    dialog_2["attacker_tod_modifier_label"].visible = "hidden"
                    dialog_2["attacker_leadership_modifier"].label = ""
                    dialog_2["attacker_leadership_modifier_label"].label = ""
                    dialog_2["attacker_leadership_modifier_label"].visible = "hidden"
                    dialog_2["attacker_slowed_modifier"].label = ""
                    dialog_2["attacker_slowed_modifier_label"].label = ""
                    dialog_2["attacker_slowed_modifier_label"].visible = "hidden"
                    local ss = math.floor(attacker_stats.damage)
                    if attacker_stats.damage > weapon.damage then
                        ss="<span color='"..rgba_to_hex(good_dmg_color).."'>" .. ss .. "</span>"
                    elseif attacker_stats.damage < weapon.damage then
                        ss="<span color='"..rgba_to_hex(bad_dmg_color).."'>" .. ss .. "</span>"
                    end
                    dialog_2["attacker_total_damage"].label = ss .."×"..math.floor(attacker_stats.number)
                    dialog_2["attacker_chance_to_hit"].label = "<span color='#"..red_green_scale_function(attacker_stats.chance_to_hit).."'>"..attacker_stats.chance_to_hit.. "%</span>"
                end
                dialog_2["defender_chance_unscathed"].label = "<span color='#"..red_green_scale_function(defender_condition.untouched * 100).."'>"..string.format("%.1f", (defender_condition.untouched * 100)).."%</span>"
                std_print(opp_weapon_index)
                std_print(opp_weapon)
                if opp_weapon then
                    dialog_2["defender_base_damage"].label = second_unit.attacks[opp_weapon_index].damage.." (<i>"..second_unit.attacks[opp_weapon_index].name.."</i>)"
                    local resistance_modifier = 100 - wesnoth.units.resistance_against(unit, opp_weapon.type)
                    if resistance_modifier ~= 100 then
                        local ss = ""
                        if resistance_modifier < 100 then
                            ss = ss..("Defender resistance vs").." " --#TODOmake it translate-able string
                        else
                            ss = ss..("Defender vulnerability vs").." " --#TODO make it translate-able string
                        end
                        dialog_2["defender_resis"].label = "×" .. math.floor(resistance_modifier / 100) .. "." .. math.floor((resistance_modifier % 100) / 10)
                        dialog_2["defender_resis_label"].label=ss .. opp_weapon.type
                        dialog_2["defender_resis_label"].visible="visible"
                    else
                        dialog_2["defender_resis"].label = ""
                        dialog_2["defender_resis_label"].label = ""
                        dialog_2["defender_resis_label"].visible = "hidden"
                    end
                    --wesnoth.map.get(unit.loc).illuminated_time
                    --unit.alignment
                    --#wesnoth.units.find({fearless=true,x=unit.x,y=unit.y}) --nefunguje, filtrovat trait
                    dialog_2["defender_tod_modifier"].label = ""
                    dialog_2["defender_tod_modifier_label"].label = ""
                    dialog_2["defender_tod_modifier_label"].visible = "hidden"
                    dialog_2["defender_leadership_modifier"].label = ""
                    dialog_2["defender_leadership_modifier_label"].label = ""
                    dialog_2["defender_leadership_modifier_label"].visible = "hidden"
                    dialog_2["defender_slowed_modifier"].label = ""
                    dialog_2["defender_slowed_modifier_label"].label = ""
                    dialog_2["defender_slowed_modifier_label"].visible = "hidden"
                    local ss = math.floor(defender_stats.damage)
                    if defender_stats.damage > opp_weapon.damage then
                        ss="<span color='"..rgba_to_hex(good_dmg_color).."'>" .. ss .. "</span>"
                    elseif defender_stats.damage < opp_weapon.damage then
                        ss="<span color='"..rgba_to_hex(bad_dmg_color).."'>" .. ss .. "</span>"
                    end
                    dialog_2["defender_total_damage"].label = ss .."×"..math.floor(defender_stats.number)
                    dialog_2["defender_chance_to_hit"].label = "<span color='#"..red_green_scale_function(defender_stats.chance_to_hit).."'>"..defender_stats.chance_to_hit.. "%</span>"
                else
                    dialog_2["defender_base_damage"].label = "No usable weapon"
                    dialog_2["defender_resis"].label = ""
                    dialog_2["defender_resis_label"].label = ""
                    dialog_2["defender_resis_label"].visible = "hidden"
                    dialog_2["defender_tod_modifier"].label = ""
                    dialog_2["defender_tod_modifier_label"].label = ""
                    dialog_2["defender_tod_modifier_label"].visible = "hidden"
                    dialog_2["defender_leadership_modifier"].label = ""
                    dialog_2["defender_leadership_modifier_label"].label = ""
                    dialog_2["defender_leadership_modifier_label"].visible = "hidden"
                    dialog_2["defender_slowed_modifier"].label = ""
                    dialog_2["defender_slowed_modifier_label"].label = ""
                    dialog_2["defender_slowed_modifier_label"].visible = "hidden"
                end
            end
            function postshow(dialog_2)
            end
            gui.show_dialog(wml.get_child(attack_predictions, 'resolution'), preshow, postshow)
        end
    end
    function postshow(dialog)
        selected_index = dialog["weapon_list"].selected_index
    end
    local return_value=gui.show_dialog(wml.get_child(unit_attack, 'resolution'), preshow, postshow)
    if return_value == -1 then
        --wesnoth.interface.select_unit(unit.x,unit.y,false)
        
        --wesnoth.interface.select_unit(unit.x,unit.y)
        wesnoth.interface.deselect_hex()
        wesnoth.interface.select_unit()
        wesnoth.wml_actions.do_command({
            {"attack",{weapon = (weapon_index_list[selected_index][1] - 1),defender_weapon = (weapon_index_list[selected_index][2] - 1),{"source", {x = unit.x, y = unit.y}}, {"destination", {x = second_unit.x, y = second_unit.y}}}}
        })
        wesnoth.interface.deselect_hex()
        wesnoth.interface.select_unit()
        
    else
        wesnoth.interface.deselect_hex()
        wesnoth.units.select(unit)
        -- unit:extract()
        -- unit:to_map()
        -- unit.moves=0
        --unit.x=unit.x+1
        
        std_print("NO ATTACK")
        -- wesnoth.wml_actions.do_command({
        --     {"attack",{weapon = #unit.attacks,defender_weapon = (weapon_index_list[selected_index][2] - 1),{"source", {x = unit.x, y = unit.y}}, {"destination", {x = second_unit.x, y = second_unit.y}}}}
        -- })
        --unit:extract()
        --wesnoth.game_events.fire("empty_event", unit.loc, second_unit.loc)
    end
    
    return true
end

-- wesnoth.wml_actions.do_command({
--     weapon = 1,
--     defender_weapon = 1,
--     {"attack", {{"source", {x =1, y = 1}}, {"destination", {x = 1, y = 2}}}}
-- }
-- )
-- unit.hitpoints = unit.max_hitpoints
-- unit.experience=0
-- animator = wesnoth.units.create_animator()
-- animator:add(unit,"recruited","hit",{})
-- animator:run()
>>


[/lua]
#  [event]
#      name="empty_event"
#      id=empty_event
#      first_time_only=no
#      [store_unit]
#          [filter]
#              id=$unit.id
#          [/filter]
#          kill=yes
#          variable=my_var
#      [/store_unit]
#  [/event]
#  [event]
#      name=exit_hex
#      [kill]
#          id=$unit.id
#      [/kill]
#  [/event]
#  >>
#  [/lua]
    #  [if]
    #      [variable]
    #          name=turn_number
    #          formula="turn_number > 10 and turn_number % 2 = 0"
    #      [/variable]
    #      [then]
    #          [set_variable]
    #              name=gold_bonus
    #              formula="turn_number * 5"
    #          [/set_variable]
    #          [gold]
    #              side=1
    #              amount=$gold_bonus
    #          [/gold]
    #          [message]
    #              speaker=narrator
    #              message="You received a bonus of $gold_bonus gold!"
    #          [/message]
    #      [/then]
    #      [else]
    #          [message]
    #              speaker=narrator
    #              message="No bonus this turn."
    #          [/message]
    #      [/else]
    #  [/if]
#  [/event]
#  [event] #BREAKS THE GAME
#      name=attacker_hits
#  [lua]
#  code=<<
#  local unit = wesnoth.units.get(wml.variables["unit.id"])
#  wesnoth.game_events.fire("my_event", unit.loc, {10,10})
#  std_print(unit)
#  >>
#  [/lua]
#  [/event]
#  [event]
#      name=my_event
#  [kill]
#  id=$unit.id
#  [/kill]
#  [/event]