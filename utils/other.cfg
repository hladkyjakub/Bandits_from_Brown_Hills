#textdomain wesnoth-Bandits_from_Brown_Hills


#define UNHIDE_FILTER
[and]
    formula="find(locations_in_radius(loc(unit.x,unit.y),3),'loc',find(unit_at(loc).abilities,self='reveals') !=null() and enemy_of(unit,unit_at(loc)) ) = null()
    where
        unit=self
    "
[/and]
#enddef
#define LIGHTNING_OVERLAY INTERVAL PROB
    [terrain_graphics]
        map="
            *,*,*,*
            ,*,*,*
            *,*,*,*
            ,*,*,*
            *,*,*,*
            ,*,*,*
            *,*,*,*
            ,*,*,*"
        [tile]
            #  x=0
            #  y=0
            type=!,X*^*,U*^*,Q*^*,Cu*^*,Ku*^*
            set_flag=lightning
            no_flag=lightning
        [/tile]
        probability={PROB}
        [image] #TODO
            center=90,168
            name="blank-hex.png:{INTERVAL},lightning/lightning-bolt-1-[1~4].png:80"#"blank-hex.png:{INTERVAL},lightning/lightning-bolt-1-[1~4].png:100,blank-hex.png:{INTERVAL},lightning/lightning-bolt-2-[1~4].png:100,blank-hex.png:{INTERVAL},lightning/lightning-bolt-3-[1~4].png:100"
            layer=100
        [/image]
    [/terrain_graphics]
#enddef
#define DROP_ONE_OVERLAY INTERVAL PROB
    [terrain_graphics]
        map="
1
,2
2
,1
"
        [tile]
            pos=1
            type=W* #TODO overlays are out, becouse of bridges
            set_flag=overlay
            no_flag=overlay
        [/tile]
        [tile]
            pos=2
            type=W*
            # flag deliberately left out
        [/tile]
        probability={PROB}
        [image]
            name="blank-hex.png:{INTERVAL},drop-1/drop-1-01.png:90,drop-1/drop-1-02.png:90,drop-1/drop-1-03.png:90,drop-1/drop-1-04.png:90,drop-1/drop-1-05.png:90,drop-1/drop-1-06.png:90,drop-1/drop-1-07.png:90,drop-1/drop-1-09.png:90,drop-1/drop-1-10.png:90,drop-1/drop-1-11.png:90,drop-1/drop-1-12.png:90,drop-1/drop-1-13.png:90,drop-1/drop-1-14.png:90,drop-1/drop-1-15.png:90,drop-1/drop-1-16.png:90,drop-1/drop-1-17.png:90"
        [/image]
    [/terrain_graphics]
#enddef
#define RAIN
    [terrain_graphics]
        map="
1
,1
1
,1"
        [tile]
            pos=1
            type=!,X*^*,U*^*,Q*^*,Cu*^*,Ku*^*
            set_flag=rain
            no_flag=rain
        [/tile]
        [image]
            layer=1
            name=rain/rain-1.png~O(0.5):100,rain/rain-2.png~O(0.5):100,rain/rain-3.png~O(0.5):100,rain/rain-4.png~O(0.5):100,rain/rain-5.png~O(0.5):100
            random_start=yes
        [/image]
    [/terrain_graphics]
    [terrain_graphics]
        [tile]
            x=0
            y=0
            type=!,X*^*,U*^*,Q*^*,Cu*^*,Ku*^*
            set_flag=rain
            no_flag=rain
        [/tile]
        [image]
            layer=1
            name=rain/rain-1.png~O(0.5):100,rain/rain-2.png~O(0.5):100,rain/rain-3.pngv:100,rain/rain-4.png~O(0.5):100,rain/rain-5.png~O(0.5):100 # that "pngv" is not a typo. I don't know what it does
            random_start=yes
        [/image]
    [/terrain_graphics]
    #  [sound_source]
    #      id=rain
    #      sounds="rain-lightning.mp3"
    #      delay=0
    #      chance=100
    #      loop=-1
    #      x,y=1,1
    #      full_range=9999
    #      check_fogged=no
    #      check_shrouded=no
    #  [/sound_source]
#enddef
#define RAIN_SOUND ID X Y FULL FADE
    [sound_source]
        id={ID}
        sounds="rain-lightning.mp3"
        delay=0
        chance=100
        loop=-1
        x,y={X},{Y}
        full_range={FULL}
        fade_range={FADE}
        check_fogged=no
        check_shrouded=no
    [/sound_source]
#enddef
#define ITEM X Y IMAGE
    [item]
        x,y={X},{Y}
        image={IMAGE}
    [/item]
#enddef
#define ACHIEVE ID
    [set_achievement]
        content_for=Bandits_from_Brown_Hills
        id=BfBH_{ID}
    [/set_achievement]
#enddef
#define REDRAW
    [redraw][/redraw]
#enddef
#define SET_GLOBAL_VARIABLE NAMESPACE VARNAME LOCAL VALUE
    [set_variable]
        name={LOCAL}
        value={VALUE}
    [/set_variable]

    [set_global_variable]
        namespace={NAMESPACE}
        from_local={LOCAL}
        to_global={VARNAME}
        side=1
        immediate=yes
    [/set_global_variable]
    {CLEAR_VARIABLE global_tmp}
#enddef
#define GET_GLOBAL_VARIABLE NAMESPACE VARNAME LOCAL
    [get_global_variable]
        namespace={NAMESPACE}
        from_global={VARNAME}
        to_local={LOCAL}
        side=1
    [/get_global_variable]
#enddef
#define SAVESCUM_MESSAGE ID CONDITION TITLE IMAGE SUBMIT_TEXT MESSAGE
    {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.dialogs {ID} dialog_tmp_get_{ID}}
    [if] {VARIABLE_CONDITIONAL dialog_tmp_get_{ID} not_equals yes}
        [and] {CONDITION} [/and]
        [then]
            {SET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.dialogs {ID} dialog_tmp_set_{ID} yes}
            [display_tip]
                title={TITLE}
                image={IMAGE}
                message={MESSAGE}
                submit_text={SUBMIT_TEXT}
            [/display_tip]
        [/then]
    [/if]
    {CLEAR_VARIABLE dialog_tmp_set_{ID},dialog_tmp_get_{ID}}
#enddef
#define CANCELLED_ATTACK_FILTER
    [and]
        [variable]
            name=attack_was_cancelled
            equals=no
        [/variable]
    [/and]
#enddef
#define FIRE_NO_ATTACK_END_EVENT_FILTER
    [and]
        [variable]
            name=fire_no_attack_end_event
            equals=no
        [/variable]
    [/and]
#enddef
#define IMPLEMENT_UNWALKABLE_VISION_COST
[event]
    name=unit placed
    first_time_only=no
    [filter]
        side=1
    [/filter]
    [object]
        silent=yes
        id=unwalkable_vision_costs_2
        take_only_once=no
        [filter]
            x,y=$x1,$y1
            [not]
                [filter_wml]
                    [modifications]
                        [object]
                            id="unwalkable_vision_costs_2"
                        [/object]
                    [/modifications]
                [/filter_wml]
            [/not]
        [/filter]
        [effect]
            apply_to=vision_costs
            replace=yes
            [vision_costs]
                unwalkable=2
            [/vision_costs]
        [/effect]
    [/object]
[/event]
#enddef
#define IMPLEMENT_DWARVISH_CANNONER_ENEMY_ONLY
    [event]
        name=turn refresh
        first_time_only=no
        [store_unit]
            [filter]
                side=$side_number
                type=Dwarvish Cannoner
            [/filter]
            variable=dwarvish_cannoner
        [/store_unit]
        [foreach]
            array=dwarvish_cannoner
            [do]
                {CLEAR_VARIABLE bombard_targets}
                {VARIABLE radius 50}
                [store_unit]
                    [filter]
                        side=1
                        [filter_location]
                            x=$dwarvish_cannoner[$i].x
                            y=$dwarvish_cannoner[$i].y
                            radius=$radius
                        [/filter_location]
                    [/filter]
                    variable=bombard_targets
                [/store_unit]
                {VARIABLE lua_line_of_sight_start_x $dwarvish_cannoner[$i].x}
                {VARIABLE lua_line_of_sight_start_y $dwarvish_cannoner[$i].y}
                {VARIABLE lua_line_of_sight_blocking_terrains X} # TODO filter it better
                {VARIABLE bombard_targets_adjecent_units_count -1}
                [for]
                    start=$($bombard_targets.length - 1)
                    step=-1
                    variable=i2
                    end=0
                    [do]
                        {VARIABLE lua_line_of_sight_end_x $bombard_targets[$i2].x}
                        {VARIABLE lua_line_of_sight_end_y $bombard_targets[$i2].y}
                        [lua]
                            code="wesnoth.dofile '~add-ons/Bandits_from_Brown_Hills/lua/is_line_of_sight_blocked.lua'"
                        [/lua]
                        [if]
                            [variable]
                                name=is_line_of_sight_blocked
                                equals=yes
                            [/variable]
                            [or]
                                [variable]
                                    name=bombard_targets[$i2].id
                                    equals=$last_bombarded_unit_id
                                [/variable]
                            [/or]
                            [then]
                                {CLEAR_VARIABLE bombard_targets[$i2]}
                            [/then]
                            [else]
                                [store_unit]
                                    [filter]
                                        [not]
                                            x,y=$bombard_targets[$i2].x, $bombard_targets[$i2].y
                                        [/not]
                                        [filter_location]
                                            x,y=$bombard_targets[$i2].x, $bombard_targets[$i2].y
                                            radius=1
                                        [/filter_location]
                                        [filter_side]
                                            [enemy_of]
                                                side=$dwarvish_cannoner[$i].side
                                            [/enemy_of]
                                        [/filter_side]
                                    [/filter]
                                    variable=bombard_targets_adjecent_units
                                [/store_unit]
                                [if]
                                    [variable]
                                        name=bombard_targets_adjecent_units_count
                                        less_than=$bombard_targets_adjecent_units.length
                                    [/variable]
                                    [then]
                                        {VARIABLE bombard_targets_adjecent_units_count $bombard_targets_adjecent_units.length}
                                    [/then]
                                    [else]
                                        {CLEAR_VARIABLE bombard_targets[$i2]}
                                    [/else]
                                [/if]
                            [/else]
                        [/if]
                    [/do]
                [/for]
                [if]
                    [variable]
                        name=bombard_targets[0].id
                        not_equals=""
                    [/variable]
                    [then]
                        {VARIABLE last_bombarded_unit_id $bombard_targets[0].id}
                        [if]
                            [have_unit]
                                x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                [filter_vision]
                                    side=1
                                [/filter_vision]
                            [/have_unit]
                            [then]
                                [scroll_to]
                                    x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                [/scroll_to]
                                [modify_unit]
                                    [filter]
                                        x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                    [/filter]
                                    [status]
                                        cannon_empty=yes
                                    [/status]
                                [/modify_unit]
                                [delay]
                                    time=500
                                    accelerate=no
                                [/delay]
                            [/then]
                        [/if]
                        ###TODO if seen animate the unit, first bombard-> message jareth, hitted unit, if survived and one other unit
                        [modify_unit]
                            [filter]
                                x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                            [/filter]
                            moves=0
                        [/modify_unit]
                        [scroll_to]
                            x,y=$bombard_targets[0].x, $bombard_targets[0].y
                        [/scroll_to]
                        [store_unit]
                            variable=bombard_secondary_targets
                            [filter]
                                [not]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                [/not]
                                [filter_location]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                    radius=1
                                [/filter_location]
                            [/filter]
                        [/store_unit]
                        [remove_time_area] #attack destruct torches on main tile
                            id="torch_$bombard_targets[0].x|_$bombard_targets[0].y"
                        [/remove_time_area]
                        [terrain]
                            x,y=$bombard_targets[0].x, $bombard_targets[0].y
                            layer=overlay
                            terrain=""
                        [/terrain]
                        [if]
                            [have_location]
                                x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                [not]
                                    terrain=W*^*,S*^*,
                                [/not]
                            [/have_location]
                            [then]
                                [terrain]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                    terrain=^Dr
                                    layer=overlay
                                [/terrain]
                            [/then]
                        [/if]
                        [redraw]
                            side=1
                        [/redraw]
                        [sound]
                            name=explosion.mp3
                        [/sound]
                        [lua]
                            code=<<
--making vars , v for shorter code
local v=wml.variables
local kill_list={}
local kill_list_count=0
local primary_medium_damage=20
local secondary_medium_damage=10
local second_unit = wesnoth.units.get(v["dwarvish_cannoner["..v["i"].."].id"])

--random damage generation, replay friendly
wml.fire("set_variable", { name = "primary_raw_damage", rand = string.format("%d..%d", (primary_medium_damage - 10), (primary_medium_damage + 10)) })
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    wml.fire("set_variable", { name = "secondary_raw_damage["..i.."].d", rand = string.format("%d..%d", (secondary_medium_damage - 5), (secondary_medium_damage + 5)) })
end

--explosion
wesnoth.interface.add_hex_overlay(v["bombard_targets[0].x"], v["bombard_targets[0].y"], {halo="projectiles/fireball-impact-[1~16].png~SCALE(200,300), misc/blank-hex.png:[60*16,999999]"})

--defend animation and damage numbers
local animation=wesnoth.units.create_animator()
unit_to_animate=wesnoth.units.get(v["bombard_targets[0].x"], v["bombard_targets[0].y"])
real_damage=math.floor(v["primary_raw_damage"]*(100-wesnoth.units.resistance_against(unit_to_animate, "fire"))/100)
animation:add(unit_to_animate, "defend", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
wesnoth.interface.float_label(v["bombard_targets[0].x"], v["bombard_targets[0].y"], "<span color='red'>"..real_damage.."</span>")
if real_damage>=v["bombard_targets[0].hitpoints"] then
    kill_list_count=kill_list_count+1
    kill_list[kill_list_count]=unit_to_animate
end
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    unit_to_animate=wesnoth.units.get(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"])
    real_damage=math.floor(v["secondary_raw_damage["..i.."].d"]*(100-wesnoth.units.resistance_against(unit_to_animate, "fire"))/100)
    animation:add(unit_to_animate, "defend", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
    wesnoth.interface.float_label(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"], "<span color='red'>"..real_damage.."</span>")
    if real_damage>=v["bombard_secondary_targets["..i.."].hitpoints"] then
        kill_list_count=kill_list_count+1
        kill_list[kill_list_count]=unit_to_animate
    end
end
animation:run()
animation:clear()

-- deal damage to all units
unit_to_damage=wesnoth.units.get(v["bombard_targets[0].x"], v["bombard_targets[0].y"])
real_damage=math.floor(v["primary_raw_damage"]*(100-wesnoth.units.resistance_against(unit_to_damage, "fire"))/100)
unit_to_damage.hitpoints=unit_to_damage.hitpoints-real_damage
local animation=wesnoth.units.create_animator()
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    unit_to_damage=wesnoth.units.get(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"])
    real_damage=math.floor(v["secondary_raw_damage["..i.."].d"]*(100-wesnoth.units.resistance_against(unit_to_damage, "fire"))/100)
    unit_to_damage.hitpoints=unit_to_damage.hitpoints-real_damage
end

--animate death
for k,unit_to_die in pairs(kill_list) do
    unit_to_die.hitpoints=0
    animation:add(unit_to_die, "death", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
end
animation:run()
animation:clear()

--kill units
for k,unit_to_die in pairs(kill_list) do
    wesnoth.wml_actions.kill { id = unit_to_die.id, animate = false, fire_event = true}
end
                            >>
                        [/lua]
                        [delay]
                            time=100
                        [/delay]
                        [delay]
                            time=2000
                        [/delay]
                        [lua]
                            code=<<
local v=wml.variables
wesnoth.interface.remove_hex_overlay(v["bombard_targets[0].x"], v["bombard_targets[0].y"], {halo="projectiles/fireball-impact-[1~16].png~SCALE(200,300), misc/blank-hex.png:[60*16,999999]"})
                            >>
                        [/lua]
                    [/then]
                    [else]
                        {VARIABLE last_bombarded_unit_id 0}
                    [/else]
                [/if]
            [/do]
        [/foreach]
        [foreach]
            array=dwarvish_cannoner
            [do]
                [modify_unit]
                    [filter]
                        x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                    [/filter]
                    [status]
                        cannon_empty=no
                    [/status]
                [/modify_unit]
            [/do]
        [/foreach]
    [/event]
#enddef
#define IMPLEMENT_DWARVEN_MAGIC_ITEM_DROPPABLE
    [switch]
        variable=dwarven_magic_item
        [case]
            value="Boots of speed"
            {GLOBAL__DROPPABLE_BOOTS_OF_SPEED boots_of_speed_dwarven_leader}
        [/case]
        [case]
            value="Breastplate of the mighty"
            {GLOBAL__DROPPABLE_BREASTPLATE_OF_THE_MIGHTY breastplate_of_the_mighty_dwarven_leader}
        [/case]
        [case]
            value="Diadem of intelligence"
            {GLOBAL__DROPPABLE_DIADEM_OF_INTELLIGENCE diadem_of_intelligence_dwarven_leader}
        [/case]
        [case]
            value="Ring of strengt"
            {GLOBAL__DROPPABLE_RING_OF_STRENGT ring_of_strengt_dwarven_leader}
        [/case]
        [case]
            value="Huntsmans hat"
            {GLOBAL__DROPPABLE_HUNTSMANS_HAT huntsmans_hat_dwarven_leader}
        [/case]
        [case]
            value="Ankh"
            {GLOBAL__DROPPABLE_ANKH ankh_dwarven_leader}
        [/case]
    [/switch]
#enddef
#define BLEEDING_OBJECT
        [object]
            silent=yes
            duration=scenario
            id=bleeding_object
            take_only_once=no
            [effect]
                apply_to=image_mod
                replace="CS(50,0,0)"
            [/effect]
            [effect]
                apply_to=movement
                increase="-2"
            [/effect]
            [effect]
                apply_to=attack
                increase_damage="-15%"
            [/effect]
        [/object]
    #enddef
#define IMPLEMENT_ABILITIES_CUSTOM
    [event]
        name=preload
        first_time_only=no
        [lua]
            [args]
                [abilities]
                    {ABILITY_LONE_WOLF}
                    {ABILITY_MARK}
                    {ABILITY_FLEE}
                    {ABILITY_DISENGAGE}
                [/abilities]
                [specials]
                    {WEAPON_SPECIAL_CRIPPLING_BLOW}
                    {WEAPON_SPECIAL_MARK}
                [/specials]
            [/args]
            code = <<
local abilities = {}
local specials= {}
local args = wml.tovconfig(...)
local abilities_vconfig = wml.tovconfig(wml.get_child(args, "abilities"))
local specials_vconfig = wml.tovconfig(wml.get_child(args, "specials"))
local i = 1
while abilities_vconfig[i] do
    abilities[abilities_vconfig[i][2].id] = {
        id = abilities_vconfig[i][2].id,
        wml.tag.effect {
            apply_to = "new_ability",
            wml.tag.abilities {
                wml.tag[abilities_vconfig[i][1]](abilities_vconfig[i][2])
            }
        }
    }
    i = i + 1
end
i = 1
while specials_vconfig[i] do
    specials[specials_vconfig[i][2].id] = {
        id = specials_vconfig[i][2].id,
        wml.tag.effect {
            apply_to = "attack",
            wml.tag.set_specials {
                mode = "append",
                wml.tag[specials_vconfig[i][1]](specials_vconfig[i][2])
            }
        }
    }
    i = i + 1
end
BfBH.reanimated.base_unit_functions = { --TODO abilities with more parts need extra care
    [""] = function(unit)
        std_print("No base unit found, this ability needs a little bit of extra attention for evey unit tree.")
    end,
    ["BfBH Footpad"] = function(unit)
        unit:add_modification("object", abilities["flee"])
    end,
    ["BfBH Outlaw"] = function(unit)
        unit:add_modification("object", abilities["disengage"])
    end,
    ["BfBH Thug"] = function(unit)
        unit:add_modification("object", specials["crippling_blow"])
    end,
    ["BfBH Bandit"] = function(unit)
        --TODO
    end,
    ["BfBH Poacher"] = function(unit)
        unit:add_modification("object", abilities["lone_wolf"])
        unit:add_modification("object", abilities["lone_wolf_chance_to_hit"])
    end,
    ["BfBH Trapper"] = function(unit)
        unit:add_modification("object", abilities["mark"]) --TODO zombie gets too many marks after attacking
        unit:add_modification("object", specials["mark"])
    end
}
BfBH.reanimated.base_units = {
    ["BfBH Walking Corpse"] = {"BfBH Footpad", "BfBH Thug", "BfBH Poacher", "BfBH Goblin Spearman", "BfBH Spearman"},
    ["BfBH Soulless"] = {"BfBH Outlaw", "BfBH Bandit", "BfBH Trapper"}
}
BfBH.unit_tree.move_down = {}
for k,unit in pairs(wesnoth.unit_types) do
	for i = 1, #unit.advances_to do
        BfBH.unit_tree.move_down[unit.advances_to[i]] = BfBH.unit_tree.move_down[unit.advances_to[i]] or {}
        table.insert(BfBH.unit_tree.move_down[unit.advances_to[i]], k)
    end
end
            >>
        [/lua]
    [/event]
    [event]
        name=prestart
        id=kamikaze_event_reset
        {VARIABLE attack_was_cancelled no}
        {VARIABLE fire_no_attack_end_event no}
    [/event]
    [event]
        name=attacker_hits
        id=kamikaze_event
        first_time_only=no
        priority=-999
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=kamikaze
        [/filter_attack]
        [kill]
            x,y=$x1,$y1
            animate=no
            fire_event=yes
        [/kill]
        [if]
            [variable]
                name=second_unit.hitpoints
                less_than_equal_to=0
            [/variable]
            [then]
                [kill]
                    id=$second_unit.id
                    animate=yes
                    fire_event=yes
                [/kill]
            [/then]
        [/if]
    [/event]
    [event]
        name=attacker_hits, attacker_misses, attack
        id=critical_attack
        first_time_only=no
        [filter_attack]
            special_id=critical
        [/filter_attack]
        {VARIABLE_OP critical_random rand "1..100"}
        [if]
            [variable]
                name=critical_random
                less_than=11
            [/variable]
            [then]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
            [else]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/else]
        [/if]
    [/event]
    [event]
        name=defender_hits, defender_misses, attack
        id=critical_defend
        first_time_only=no
        [filter_second_attack]
            special_id=critical
        [/filter_second_attack]
        {VARIABLE_OP critical_random rand "1..100"}
        [if]
            [variable]
                name=critical_random
                less_than=11
            [/variable]
            [then]
                [lua]
                    code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
            [else]
                [lua]
                    code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/else]
        [/if]
    [/event]
    [event]
        name=attack_end
        id=critical_attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=critical
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        id=critical_defend_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second_attack]
            special_id=critical
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=surprise_event
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{{"has_attack",{special_id = "surprise"}},{"or",{ability="stonefoot"}}}}})
for _,u in ipairs(units) do
    u.variables.side_turn_loc={x=u.x,y=u.y,loc=u.loc}
end
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=started_invisible
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{{"has_attack",{special_id = "shadowstrike"}}}}})
for _,u in ipairs(units) do
    if u:matches({wml.tag.filter_vision{visible=false,{"enemy_of",{side=u.side}}} },u.loc) then
        u.variables.started_invisible=true
    else
        u.variables.started_invisible=false
    end
end
>>
        [/lua]
    [/event]
    [event]
        name=turn refresh
        first_time_only=no
        id=stalker_event
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="stalker"})
for _,u in ipairs(units) do
    local range = u.max_moves
    local enemies = wesnoth.units.find_on_map({{"filter_side",{{"enemy_of",{side=u.side}}}},{"filter_location",{x=u.x,y=u.y,radius=(range+1)}}})
    local loc = nil
    local locs = nil
    if #enemies == 0 then
        local e = find_closest_enemy(u.loc,u.side)
        if e ~= nil then
            locs = sort_loc_by_distance(e.loc, wesnoth.map.find({x=u.x,y=u.y,radius=range}))
        end
    else
        local target
        local min_value = 999999999
        for _,e in ipairs(enemies) do
            std_print(e.level)
            local value = e.level == 0 and (e.hitpoints / 0.5) or (e.hitpoints / e.level)
            if value < min_value then
                min_value=value
                target=e
            end
        end
        locs = sort_loc_by_distance(target.loc, wesnoth.map.find({x=u.x,y=u.y,radius=range}))
    end
    if locs ~= nil then
        for _,l in ipairs(locs) do
            if wesnoth.units.get(l) == nil and u:matches({wml.tag.filter_vision{visible=false,{"enemy_of",{side=u.side}}} },l) and wesnoth.current.map:on_border(l) == false and wesnoth.units.movement_on(u,wesnoth.current.map[l]) ~= 99 then
                loc=l
                break
            end
        end
        if loc ~= nil then
            local animator = wesnoth.units.create_animator()
            local side_filter = {} --TODO TODO TODO only sides who see the ghost
            wesnoth.wml_actions.scroll_to({x=u.x,y=u.y,{"filter_side",side_filter}})
            animator:add(u, "pre_teleport", "hit",{with_bars = false})
            animator:run()
            animator:clear()
            wesnoth.wml_actions.scroll_to({x=u.x,y=u.y,{"filter_side",side_filter}})
            u.loc = loc
            wesnoth.wml_actions.redraw({})
            animator:add(u, "post_teleport", "hit",{with_bars = false})
            animator:run()
            animator:clear()
        end
    end
end
>>
        [/lua]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        id=corrode_event_attack
        [filter_attack]
            special_id=corrode
        [/filter_attack]
        [filter_second]
            [not]
                ability=corroded
            [/not]
        [/filter_second]
        [modify_unit]
            [filter]
                x=$x2
                y=$y2
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [unit_overlay]
            x,y=$x2,$y2
            ability=corroded
            image="overlays/corrode.png"
        [/unit_overlay]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        id=corrode_event_defend
        [filter_second_attack]
            special_id=corrode
        [/filter_second_attack]
        [filter]
            [not]
                ability=corroded
            [/not]
        [/filter]
        [modify_unit]
            [filter]
                x=$x1
                y=$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [unit_overlay]
            x,y=$x1,$y1
            ability=corroded
            image="overlays/corrode.png"
        [/unit_overlay]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=corrode_event_village
        [store_locations]
            [filter]
                side=$side_number
                ability=corroded
            [/filter]
            terrain=*^V*
            variable=uninjure_by_village_on
            mode=append
        [/store_locations]
        {VARIABLE i 0}
        [while]
            [variable]
                name=i
                less_than=$uninjure_by_village_on.length
            [/variable]
            [do]
                [store_unit]
                    [filter]
                        x=$uninjure_by_village_on[$i].x
                        y=$uninjure_by_village_on[$i].y
                    [/filter]
                    variable=uninjure_by_healing_on
                    mode=append
                [/store_unit]
                [set_variable]
                    name=i
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE i}
        {VARIABLE j 0}
        [while]
            [variable]
                name=j
                less_than=$uninjure_by_healing_on.length
            [/variable]
            [do]
                [unstore_unit]
                    variable=uninjure_by_healing_on[$j]
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    [/filter]
                    [effect]
                        apply_to=remove_ability
                        [abilities]
                            {ABILITY_CORRODED}
                        [/abilities]
                    [/effect]
                [/modify_unit]
                [remove_unit_overlay]
                    x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    image="overlays/corrode.png"
                [/remove_unit_overlay]
                [animate_unit]
                    flag=healed
                    [filter]
                        x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    [/filter]
                    text= _ "armor repaired"
                    red=0
                    green=255
                    blue=0
                [/animate_unit]
                [set_variable]
                    name=j
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE j}
        {CLEAR_VARIABLE uninjure_by_healing_on}
        {CLEAR_VARIABLE uninjure_by_village_on}
    [/event]
    [event]
        name=pre advance
        first_time_only=no
        id=corrode_event_advance
        [filter]
            ability=corroded
        [/filter]
        [modify_unit]
            [filter]
                x,y=$unit.x,$unit.y
            [/filter]
            [effect]
                apply_to=remove_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [remove_unit_overlay]
            x,y=$unit.x,$unit.y
            image="overlays/corrode.png"
        [/remove_unit_overlay]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=hit_and_run
        [/filter_attack]
        {UNIT_SKIRIMSHER x,y=$x1,$y1}
    [/event]
    [event]
        name=defender_hits
        first_time_only=no
        [filter_second_attack]
            special_id=stagger
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u ~= nil then
    std_print(u.name,"got hit, sets to true")
    u.variables.staggered=30
end
>>
        [/lua]
    [/event]
    [event]
        name=attacker_hits, attacker_misses
        first_time_only=no
        [filter_second_attack]
            special_id=stagger
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u ~= nil then
    std_print(u.name, "attacks, set to false")
    u.variables.staggered=0
end
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second_attack]
            special_id=stagger
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u ~= nil then
    std_print(u.name, "attack end, set to false")
    u.variables.staggered=0
end
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            ability=endurance
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if u_table.hitpoints == u_table.max_hitpoints then
    variables.endurance = true
else
    variables.endurance = false
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second]
            ability=endurance
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if u_table.hitpoints == u_table.max_hitpoints then
    variables.endurance = true
else
    variables.endurance = false
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender_hits
        first_time_only=no
        [filter]
            ability=endurance
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if unit.hitpoints <= 0 and unit.variables.endurance then unit.hitpoints = 1 end
>>
        [/lua]
    [/event]
    [event]
        name=attacker_hits
        first_time_only=no
        [filter_second]
            ability=endurance
        [/filter_second]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if unit.hitpoints <= 0 and unit.variables.endurance then unit.hitpoints = 1 end
>>
        [/lua]
    [/event]
    [event]
        name=pre attack
        first_time_only=no
        priority=1000
        [filter_condition]
            [not]
                [variable]
                    name=living_shield.length
                    greater_than=0
                [/variable]
            [/not]
        [/filter_condition]
        [filter]
            [filter_adjacent]
                is_enemy=yes
                ability=living_shield
            [/filter_adjacent]
        [/filter]
        [filter_second]
            [filter_adjacent]
                is_enemy=no
                ability=living_shield
            [/filter_adjacent]
        [/filter_second]
        [store_unit]
            [filter]
                ability=living_shield
                [filter_adjacent]
                    x,y=$unit.x,$unit.y
                    is_enemy=yes
                [/filter_adjacent]
                [and]
                    [filter_adjacent]
                        x,y=$second_unit.x,$second_unit.y
                        is_enemy=no
                        [and]
                            formula="level > other.level"
                            [or]
                                formula="level = other.level"
                                [not]
                                    ability=living_shield
                                [/not]
                            [/or]
                        [/and]
                    [/filter_adjacent]
                [/and]
            [/filter]
            variable=living_shield
        [/store_unit]
        [if]
            [variable]
                name=living_shield.length
                greater_than=0
            [/variable]
            [then]
                [lua]
                    code=<<
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
wml.variables["attacking_weapon_index"] = i
attacker = wesnoth.units.get(wml.variables["unit[0].id"])
defender = wesnoth.units.get(wml.variables["living_shield[0].id"])
local _,_,_,defender_stats = wesnoth.simulate_combat(attacker, i + 1, defender)
wml.variables["defending_weapon_index"] = defender_stats.attack_num
>>
                [/lua]
                [cancel_action]
                [/cancel_action]
                [do_command]
                    [attack]
                        [source]
                            x,y=$x1,$y1
                        [/source]
                        [destination]
                            x,y=$living_shield.x,$living_shield.y
                        [/destination]
                        weapon=$attacking_weapon_index
                        defender_weapon=$defending_weapon_index
                    [/attack]
                [/do_command]
                {VARIABLE attack_was_cancelled yes}
            [/then]
        [/if]
        {CLEAR_VARIABLE living_shield,attacking_weapon_index,defending_weapon_index}
    [/event]
    [event]
        priority=-1000000
        name=attack_end
        first_time_only=no
        {VARIABLE attack_was_cancelled no}
    [/event]
#      [event] #REWORKED, renamed
#          name=attack_end
#          first_time_only=no
#          [filter_condition]
#              {CANCELLED_ATTACK_FILTER}
#              {FIRE_NO_ATTACK_END_EVENT_FILTER}
#          [/filter_condition]
#          [filter]
#              ability=adaptive_armor
#          [/filter]
#          [lua]
#              code=<<
#  local u_table = wml.variables["unit"]
#  local variables = wml.get_child(u_table, "variables")
#  variables.adaptive_armor = wml.variables["second_weapon"].type
#  wesnoth.units.erase(u_table.x,u_table.y)
#  wesnoth.units.to_map(u_table)
#  >>
#          [/lua]
#      [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second]
            ability=ethereal
        [/filter_second]
        [lua]
            code=<<
local x2 = wesnoth.current.event_context.x2
local y2 = wesnoth.current.event_context.y2
local u2 = wesnoth.units.get(x2,y2)
local w = wml.get_child(wesnoth.current.event_context,"data")
local type = wml.get_child(w,"first").type
--TODO for loop, if weapon has more types?
local t = u2.variables.ethereal or {}
t[type] = true
u2.variables.ethereal = t
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{ability="ethereal"}}})
for _,u in ipairs(units) do
    u.variables.ethereal = {}
end
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({})
for _,u in ipairs(units) do
    u.variables.current_team_name = wesnoth.sides[wesnoth.current.side].team_name
end
>>
        [/lua]
    [/event]
    [event]
        name=unit_placed
        first_time_only=no
        [lua]
            code=<<
local x1 = wesnoth.current.event_context.x1
local y1 = wesnoth.current.event_context.y1
local u = wesnoth.units.get(x1,y1)
u.variables.current_team_name = wesnoth.sides[wesnoth.current.side].team_name
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=mark
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.marked_unit = wml.variables["second_unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event] #TODO attack assing a prommenou, na konci fightu pak pridej movement points na max, (ted nefunguje)
        name=attack_end
        first_time_only=no
        priority=900
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter]
            ability=disengage
            [not]
                [filter_wml]
                    moves=$this_unit.max_moves
                [/filter_wml]
            [/not]
        [/filter]
        {VARIABLE unit.moves 0}
        [unstore_unit]
            variable=unit
            find_vacant=no
        [/unstore_unit]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        priority=800
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter]
            ability=swift
        [/filter]
        [lua]
            code=<<
local u= wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
u.moves=u.moves+2
            >>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_1
        name=attack, attacker_misses, attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second]
            ability=desperate_dodge
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_2
        name=attack, defender_misses, attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter]
            ability=desperate_dodge
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_3
        name=attacker_hits
        first_time_only=no
        [filter_second]
            ability=desperate_dodge
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = (20 + variables.desperate_dodge)
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_4
        name=defender_hits
        first_time_only=no
        [filter]
            ability=desperate_dodge
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = (20 + variables.desperate_dodge)
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=die
        priority=-1000
        first_time_only=no
        [filter]
            [not]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
            [/not]
            [not]
                formula="self.undead"
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=plague
        [/filter_second_attack]
        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=reanimated_unit
        [/store_unit]
        [kill]
            x,y=$x1,$y1
        [/kill]
        [unit]
            type=BfBH Walking Corpse
            x,y=$x1,$y1
            side=$second_unit.side
            variation=$reanimated_unit.undead_variation
            animate=yes
            attacks_left=0
            moves=0
            [variables]
                reanimated_unit_type=$reanimated_unit.type
            [/variables]
        [/unit]
    [/event]
    [event]
        name=unit_placed
        first_time_only=no
        [filter]
            type=BfBH Walking Corpse, BfBH Soulless
            [filter_condition]
                [not]
                    [variable]
                        name=this_unit.variables.reanimated_gained_as
                        contains=$this_unit.type
                    [/variable]
                [/not]
            [/filter_condition]
        [/filter]
        [modify_unit] #just so one can see the ability in the unit_type and also checks if unit got this already
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object]
                id=hide_reanimated
                take_only_once=no
                silent=yes
                [effect]
                    apply_to=remove_ability
                    [experimental_filter_ability]
                        [reanimated]
                        [/reanimated]
                    [/experimental_filter_ability]
                [/effect]
            [/object]
        [/modify_unit]
        [lua]
            code = <<
local ecx = wesnoth.current.event_context
local unit = wesnoth.units.get(ecx.x1, ecx.y1)
if unit.type == "BfBH Soulless" then --this relies to the fact I have two zombies, needs brush off if more are going to be added (or more these units)
    BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", "BfBH Walking Corpse")
    BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units["BfBH Walking Corpse"]))](unit)
end
BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", unit.type)
BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
            >>
        [/lua]
    [/event]
    [event]
        name=post_advance
        first_time_only=no
        [filter]
            type=BfBH Walking Corpse, BfBH Soulless
            [filter_condition]
                [not]
                    [variable]
                        name=this_unit.variables.reanimated_gained_as
                        contains=$this_unit.type
                    [/variable]
                [/not]
            [/filter_condition]
        [/filter]
        [lua]
            code = <<
local ecx = wesnoth.current.event_context
local unit = wesnoth.units.get(ecx.x1, ecx.y1)
BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", unit.type)
BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_1
        name=attack,defender_hits,defender_misses
        first_time_only=no
        priority=-1000
        [filter]
            ability=flee
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_1")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if defender_stats.damage >= attacker.hitpoints then
    attacker.variables.flee = true
else
    attacker.variables.flee = false
end
std_print(attacker.variables.flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_2
        name=attacker_hits,attacker_misses
        first_time_only=no
        priority=-1000
        [filter]
            ability=flee
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_2")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if defender_stats.damage >= attacker.hitpoints then
    attacker.variables.flee = true
else
    attacker.variables.flee = false
end
std_print(attacker.variables.flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_3
        name=attack,attacker_hits,attacker_misses
        first_time_only=no
        priority=-1000
        [filter]
        [/filter]
        [filter_second]
            ability=flee
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_3")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if attacker_stats.damage >= defender.hitpoints then
    defender.variables.flee = true
else
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_4
        name=defender_hits,defender_misses
        first_time_only=no
        priority=-1000
        [filter]
        [/filter]
        [filter_second]
            ability=flee
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_4")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if attacker_stats.damage >= defender.hitpoints then
    defender.variables.flee = true
else
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_5
        name=defender_misses
        first_time_only=no
        priority=-500
        [filter]
            ability=flee
            [filter_wml]
                [variables]
                    flee=yes
                [/variables]
            [/filter_wml]
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = attacker
local second_unit = defender
local unit_cfg = attacker.__cfg
local second_unit_cfg = defender.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)
local right_weight = if_tile_passable(unit,right, 0.1)
local back_weight = if_tile_passable(unit,back, 0.3)
local left_weight = if_tile_passable(unit,left, 0.1)
local chance_to_flee = (defender_stats.chance_to_hit / (1.0 - (right_weight + back_weight + left_weight))) - defender_stats.chance_to_hit
local total_evaded_or_fleed = 100 - defender_stats.chance_to_hit
local probability_of_flee = (chance_to_flee / total_evaded_or_fleed)*100
local random = mathx.random() * total_evaded_or_fleed
local retreat
if random < probability_of_flee then
    random = mathx.random() * (right_weight + back_weight + left_weight)
    std_print("fleed")
    if random < right_weight then
        retreat=right
    elseif random < right_weight + back_weight then
        retreat=back
    elseif random < right_weight + back_weight + left_weight then
        retreat=left
    else
        std_print("Error in flee ability, unit should flee, but random found no free tile.")
        print("Error in flee ability, unit should flee, but random found no free tile.")
    end
    local loc = unit.loc
    wesnoth.game_events.fire("attack_end", attacker.loc, defender.loc)
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        unit.experience = unit.experience + second_unit_cfg.level
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        if wml.variables["side_number"] == unit.side then
            unit.moves = math.max(0, (unit.moves - wesnoth.units.movement_on(unit, wesnoth.get_terrain(retreat))))
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
    wml.variables["attack_was_cancelled"] = true
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_6
        name=attacker_misses
        first_time_only=no
        priority=-500
        [filter]
        [/filter]
        [filter_second]
            ability=flee
            [filter_wml]
                [variables]
                    flee=yes
                [/variables]
            [/filter_wml]
        [/filter_second]
        [lua]
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = defender
local second_unit = attacker
local unit_cfg = defender.__cfg
local second_unit_cfg = attacker.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)
local right_weight = if_tile_passable(unit,right, 0.1)
local back_weight = if_tile_passable(unit,back, 0.3)
local left_weight = if_tile_passable(unit,left, 0.1)
local chance_to_flee = (attacker_stats.chance_to_hit / (1.0 - (right_weight + back_weight + left_weight))) - attacker_stats.chance_to_hit
local total_evaded_or_fleed = 100 - attacker_stats.chance_to_hit
local probability_of_flee = (chance_to_flee / total_evaded_or_fleed)*100
local random = mathx.random() * total_evaded_or_fleed
local retreat
if random < probability_of_flee then
    random = mathx.random() * (right_weight + back_weight + left_weight)
    std_print("fleed")
    if random < right_weight then
        retreat=right
    elseif random < right_weight + back_weight then
        retreat=back
    elseif random < right_weight + back_weight + left_weight then
        retreat=left
    else
        std_print("Error in flee ability, unit should flee, but random found no free tile.")
        print("Error in flee ability, unit should flee, but random found no free tile.")
    end
    local loc = unit.loc
    wesnoth.game_events.fire("attack_end", attacker.loc, defender.loc)
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        unit.experience = unit.experience + second_unit_cfg.level
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        if wml.variables["side_number"] == unit.side then
            unit.moves = math.max(0, (unit.moves - wesnoth.units.movement_on(unit, wesnoth.get_terrain(retreat))))
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
    wml.variables["attack_was_cancelled"] = true
end
std_print(defender_stats.chance_to_hit)
std_print(chance_to_flee)
std_print(probability_of_flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_7
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [lua]
            code=<<
std_print("ability_flee_event_7")
local attacker= wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local defender= wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if attacker ~= nil then
    attacker.variables.flee = false
end
if defender ~= nil then
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event] #TODO get rid of debug stuff
        name=attack_end
        first_time_only=no
        [lua]
            code=<<
std_print("attack_end")
>>
        [/lua]
        #  [kill]
        #      id=$unit.id
        #  [/kill]
        #  [kill]
        #      id=$second_unit.id
        #  [/kill]
    [/event]
    [event]
        priority=10000
        name=advance
        first_time_only=no
        [lua]
            code=<<
std_print("advance")
>>
        [/lua]
    [/event]
    [event]
    priority=10000
    name=advance
    first_time_only=no
    [lua]
        code=<<
std_print("sighted")
>>
    [/lua]
[/event]
    [event]
        priority=10000
        name=pre_advance
        first_time_only=no
        [lua]
            code=<<
std_print("pre_advance")
>>
        [/lua]
    [/event]
    [event]
        priority=10000
        name=unit_placed
        first_time_only=no
        [lua]
            code=<<
std_print("unit_placed")
>>
        [/lua]
    [/event]
    [event]
        priority=10000
        name=post_advance
        first_time_only=no
        [lua]
            code=<<
std_print("post_advance")
>>
        [/lua]
    [/event]
    [event]
        name=capture
        first_time_only=no
        [lua]
            code=<<
std_print("capture")
>>
        [/lua]
    [/event]
#      [event]
#          name=moveto
#          first_time_only=no
#          [lua]
#              code=<<
#  std_print("moveto")
#  >>
#          [/lua]
#      [/event]
#      [event]
#          name=enter_hex
#          first_time_only=no
#          [lua]
#              code=<<
#  std_print("enter_hex")
#  >>
#          [/lua]
#      [/event]
#      [event]
#          name=exit_hex
#          first_time_only=no
#          [lua]
#              code=<<
#  std_print("exit_hex")
#  >>
#          [/lua]
#      [/event]
    [event]
        name=sighted
        first_time_only=no
        [lua]
            code=<<
std_print("sighted")
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [lua]
            code=<<
std_print("attack")
>>
        [/lua]
    [/event]
    [event]
        name=defender_misses
        first_time_only=no
        [lua]
            code=<<
std_print("defender_misses")
>>
        [/lua]
    [/event]
    [event]
        name=attacker_misses
        first_time_only=no
        [lua]
            code=<<
std_print("attacker_misses")
>>
        [/lua]
    [/event]
    [event]
        id=weapon_special_disruptor_strike_grant
        name=attacker_hits
        first_time_only=no
        [filter_second]
            [not]
                [filter_wml]
                    [variables]
                        disrupted=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter_second]
        [filter_attack]
            special_id=disruptor_strike
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.disrupted = "yes"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [modify_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            [object]
                id=disrupted
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_DISRUPTED}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        id=weapon_special_disruptor_strike_remove
        name=side turn end
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"filter_wml",{{"variables",{disrupted=true}}}}})
for _, u in ipairs(units) do
    u.variables.disrupted=false
end
>>
        [/lua]
        [remove_object]
            side=$side_number
            object_id=disrupted
        [/remove_object]
    [/event]
    [event]
        id=soulreap_collect
        name=die
        first_time_only=no
        [filter_second_attack]
            special_id=soulreap
        [/filter_second_attack]
        [filter]
            [not] #TODO in case of need shift this list
                #UNITS WITH SOULS
                trait="undead"
            [/not]
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
u.variables.souls = (u.variables.souls or 0) + 1
>>
        [/lua]
    [/event]
    [event]
        id=resurrection_create
        name=die
        first_time_only=no
        [filter]
            ability_type=resurrection
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local cfg = u.__cfg
local r = wml.get_child(wml.get_child(cfg,"abilities"),"resurrection")
if mathx.random()*100 < r.chance then --33.3%, == every second unit gets revieved once
    wml.variables["resurrection["..wml.variables["resurrection.length"].."]"]={x=u.x,y=u.y,side=u.side,turn=mathx.random(r.min_turns, r.max_turns),{"unit",cfg}} --mathx.random(3, 5) --TODO adjust turns (0 means next turn)
end
>>
        [/lua]
    [/event]
    [event]
        id=resurrection_summon
        name=turn refresh
        first_time_only=no
        [lua]
            code=<<

local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"filter_wml",{{"variables",{glob_on_resurrection_buff="*"}}}}})
for _, u in ipairs(units) do
    u.variables.resurrection_buff = u.variables.resurrection_buff - 1
    if u.attacks_left <= 0  then
        u.variables.resurrection_buff = nil
    end
end


local ud = wml.array_access.get "resurrection"
for i = #ud, 1, -1 do
    if ud[i].side == wesnoth.current.side then
        if ud[i].turn <= 0 then
            local ut = cleanse_unit_table(wml.get_child(ud[i],"unit"))
            local r = wml.get_child(wml.get_child(ut,"abilities"),"resurrection")
            local x = ud[i].x
            local y = ud[i].y
            --gui.show_inspector({})
            if r.spawn_radius ~= 0 then
                local locs = wesnoth.map.find({x=x,y=y,radius=r.spawn_radius})
                locs = filter_passable_locations(locs, wesnoth.units.create(ut))
                local loc = filter_location_by_adjacent_units(locs,"max",{"filter_side",{{"enemy_of",{side=ut.side}}}})
                x = loc.x
                y = loc.y
            end
            if wesnoth.units.get({x,y}) == nil and x ~= 0 and y ~= 0 then
                wesnoth.interface.scroll_to_hex(x,y)
                wml.variables["resurrection["..(i-1).."]"] = nil

                ut.hitpoints=ut.max_hitpoints * r.hitpoints / 100
                ut.attacks_left=ut.max_attacks
                ut.moves=ut.max_moves
                ut.x = x
                ut.y = y
                local vars = wml.get_child(ut, "variables")
                if r.buff and r.buff ~= 0 then
                    vars.resurrection_buff = r.buff
                end

                wesnoth.audio.play("skeleton-big-die.ogg")
                wesnoth.audio.play("magic-dark.ogg")
                local ms_per_missile_frame = 30

                local animator = wesnoth.units.create_animator()

                local base, per_level = r.instant_damage:match("(%d+)/(%d+)")
                local damage = tonumber(base) + tonumber(per_level) * ut.level


                local w_cfg = {type="arcane",number=1,damage=damage,range="ranged"}
                local w2 = {}
                local w2_index = {}
                local w2_cfg = {}

                local u = wesnoth.units.create(ut)
                u:to_map()

                local enemies=wesnoth.units.find_on_map({{"filter_side",{{"enemy_of",{side=u.side}}}},{"filter_location",{{"filter_adjacent_location",{x=x,y=y}}}}})
                local damage_t={}
                local dying = {}

                for i,e in ipairs(enemies) do
                    e.facing = wesnoth.map.get_relative_dir(e.x, e.y, x, y)
                    w2[i], w2_index[i] = find_weapon(e,{range="ranged"})
                    w2_cfg[i] = {}
                    if w2[i] ~= nil then
                        w2_cfg[i] = w2[i].__cfg
                    end
                    wesnoth.game_events.fire("attack", u.loc, e.loc, {{"first",w_cfg},{"second",w2_cfg[i]}})

                    u.attacks[(#u.attacks + 1)] = w_cfg
                    local _,_,u_s,e_s = wesnoth.simulate_combat(u,#u.attacks, e, w2_index[i])
                    -- gui.show_inspector({})
                    u.attacks[#u.attacks] = nil
                    damage_t[i] = math.floor(u_s.damage)
                    local text2 = damage_t[i]

                    wesnoth.interface.add_hex_overlay(x,y, {halo = "projectiles/darkmissile/"..wesnoth.map.get_relative_dir(x, y, e.x, e.y).."/00[0~20].png~CS(-250,-250,-250):"..ms_per_missile_frame..",misc/blank-hex.png:999999"})
                    wesnoth.interface.add_hex_overlay(e.x, e.y, {halo = "misc/blank-hex.png:150,halo/dark-explosion/final-[6~1].png~CS(-150,-150,-150)~O([40%,50%,60%*2,50%,40%]),misc/blank-hex.png:999999"})

                    animator:add(e, "defend", "hit",{with_bars = true, primary = wesnoth.units.create_weapon(w_cfg), secondary = w2[i], text = text2,color={255,0,0}})
                end
                animator:add(u, "recruited", "hit",{with_bars = false})
                animator:run()
                animator:clear()

                for i,e in ipairs(enemies) do
                    e.hitpoints = e.hitpoints - damage_t[i]
                    wesnoth.game_events.fire("attacker_hits", u.loc, e.loc, {{"first",w_cfg},{"second",w2_cfg[i]},damage_inflicted=damage_t[i]})
                    if e.hitpoints <= 0 then
                        dying[#dying+1] = e
                    end
                end

                for i,e in ipairs(enemies) do
                    wesnoth.game_events.fire("attack_end", u.loc, e.loc, {{"first",w_cfg},{"second",w2_cfg[i]}})
                end

                for i,e in ipairs(dying) do
                    wesnoth.game_events.fire("last_breath", e.loc, u.loc, {{"first",w2_cfg[i]},{"second",w_cfg}}) --INVERTED
                end

                for i,e in ipairs(dying) do
                    animator:add(e, "death", "hit",{with_bars = false, primary = w2[i], secondary = wesnoth.units.create_weapon(w_cfg)}) --inverted TODO unsure!
                end

                animator:run()
                animator:clear()

                local e_level = {}
                local e_id = {}

                for i,e in ipairs(dying) do
                    e_level[i] = e.level
                    e_id[i]= e.id
                    wesnoth.game_events.fire("die", e.loc, u.loc, {{"first",w2_cfg[i]},{"second",w_cfg}}) --inverted
                    wesnoth.wml_actions.kill({ id = e_id[i], animate = false, fire_event = false})
                    if e_level[i] == 0 then
                        u.experience = wesnoth.game_config.kill_experience * 0.5
                    else
                        u.experience = u.experience +(e_level[i] * wesnoth.game_config.kill_experience)
                    end
                    u:advance(true,true)
                end


            end
        else
            wml.variables["resurrection["..(i-1).."].turn"] = wml.variables["resurrection["..(i-1).."].turn"] - 1
        end
    end
end
            >>
        [/lua]
    [/event]
    [event]
        id=ability_trap_lay
        name=side turn end
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="trap",{"filter_location",{{"not",{terrain="*^V*,W*^*,Chw*^*,Chs*^*,Cm*^*,Khw*^*,Khs*^*,Km*^*"}}}}})
for _, u in ipairs(units) do
    if u.attacks_left > 0 and wml.variables["trap[0]."..u.x.."x"..u.y.."y"] == nil then
        wesnoth.interface.add_item_image(u.x,u.y, "items/bear-trap-half-transparent.png")
        wml.variables["trap[0]."..u.x.."x"..u.y.."y"]={side=u.side, damage=10, damage_type="blade", effects="bleed", stop_move=true, creator=u.id, kill=true}
    end
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_trap_activate
        name=enter_hex
        first_time_only=no
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if wml.variables["trap[0]."..u.x.."x"..u.y.."y"] ~= nil and wesnoth.sides.is_enemy(u.side,wml.variables["trap[0]."..u.x.."x"..u.y.."y"].side) then
    local trap = wml.variables["trap[0]."..u.x.."x"..u.y.."y"]
    wesnoth.interface.remove_item(u.x,u.y, "items/bear-trap-half-transparent.png")
    wesnoth.interface.add_item_halo(u.x,u.y, "items/bear-trap-half-transparent.png:100,items/bear-trap-half-transparent-sprung-0[1~4].png:100,misc/blank-hex.png:999999")
    wesnoth.wml_actions.harm_unit({{"filter",{x=u.x,y=u.y}},{"filter_second",{id=trap.creator}},amount=trap.damage,animate="defender",damage_type=trap.damage_type,kill=trap.kill,fire_event=true,experience="kill"})
    if trap.effects == "bleed" then
        --TODO bleed
    end
    u.moves=0
    wesnoth.interface.remove_item(u.x,u.y, "items/bear-trap-half-transparent.png:100,items/bear-trap-half-transparent-sprung-0[1~4].png:100,misc/blank-hex.png:999999")
    wml.variables["trap[0]."..u.x.."x"..u.y.."y"] = nil
else
    wesnoth.wml_actions.allow_undo({})
end
            >>
        [/lua]
    [/event]
    [event]
        id=weapon_special_ink_event_1
        name=attacker_hits
        first_time_only=no
        [filter_second]
            [not]
                [filter_wml]
                    [variables]
                        inked=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter_second]
        [filter_attack]
            special_id=ink
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "yes"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [modify_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            [object]
                id=inked
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_INKED}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        id=weapon_special_ink_event_2
        name=defender_hits
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [variables]
                        inked=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=ink
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "yes"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [modify_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object]
                id=inked
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_INKED}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        id=weapon_special_ink_event_3
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second]
            [filter_wml]
                [variables]
                    inked=yes
                [/variables]
            [/filter_wml]
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "no"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [remove_object]
            x,y=$x2,$y2
            object_id=inked
        [/remove_object]
    [/event]
    [event]
        id=weapon_special_ink_event_4
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter]
            [filter_wml]
                [variables]
                    inked=yes
                [/variables]
            [/filter_wml]
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "no"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [remove_object]
            x,y=$x1,$y1
            object_id=inked
        [/remove_object]
    [/event]
    [event]
        #TODO better animation, don't make the enmy re-appear on map
        id=ability_scavenger_event
        name=die
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [status]
                        undrainable="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second]
            ability=scavenger
        [/filter_second]
        [heal_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            amount=$(floor($unit.max_hitpoints / 4))
            animate=yes
            restore_statuses=no
        [/heal_unit]
    [/event]
    [event]
        id=special_feed_event
        name=last_breath
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [status] #TODO this may be better?
                        undrainable="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=feed
        [/filter_second_attack]
        [heal_unit]
            [filter]
                x,y=$x2,$y2
                [or]
                    [filter_location]
                        [filter_adjacent_location]
                            x,y=$x1,$y1
                        [/filter_adjacent_location]
                    [/filter_location]
                    [filter_side]
                        [allied_with]
                            side=$second_unit.side
                        [/allied_with]
                    [/filter_side]
                    [and]
                        race=wolf
                        [or]
                            ability=wolf_pack
                        [/or]
                    [/and]
                    #  [and]
                    #      [filter_location]
                    #          [filter_adjacent_location]
                    #              x,y=$x1,$y1
                    #          [/filter_adjacent_location]
                    #      [/filter_location]
                    #  [/and]
                [/or]
            [/filter]
            #TODO #TODO #TODO #NOW animate all units juping on the enemy, tearing it's flesh
            amount=$(floor($unit.max_hitpoints * 3/20))
            animate=yes
            restore_statuses=no
        [/heal_unit]
    [/event]
    [event]
        id=weapon_special_disarming_hits
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=disarming
        [/filter_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
u.variables.disarmed=true
u.attacks_left=0
wesnoth.interface.float_label(u.x, u.y, "<span color='#FF0000'>disarmed</span>")
            >>
        [/lua]
    [/event]
    [event]
        id=weapon_special_disarming_remove
        name=turn refresh
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"]})
for _, u in ipairs(units) do
    if u.variables.disarmed then u.variables.disarmed=nil u.attacks_left=0 end
end
>>
        [/lua]
    [/event]
    [event]
        id=weapon_special_fury_kill
        name=die
        first_time_only=no
        [filter_second_attack]
            special_id=fury
        [/filter_second_attack]
        [lua]
            code=<<
local move_bonus = 4
local attack_bonus = 1 --NOTE if set to higher than two, attack -> attacks in string
local fury_increase = 20
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
u.variables.fury=(u.variables.fury or 0) + fury_increase
u.attacks_left=u.attacks_left + attack_bonus
u.moves=u.moves + move_bonus
wesnoth.interface.float_label(u.x, u.y, "<span color='#A80606'>fury</span>")
            >>
        [/lua]
        [object]
            [filter]
                x,y=$x2,$y2
            [/filter]
            id=fury_vulnerability
            take_only_once=yes
            silent=yes
            duration=scenario
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_FURY_VULNERABILITY}
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        id=weapon_special_fury_remove
        name=side turn end
        first_time_only=no
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"]})
for _, u in ipairs(units) do
    if u.variables.fury then u.variables.fury=0 end
end
>>
        [/lua]
        [remove_object]
            side=$side_number
            object_id=fury_vulnerability
        [/remove_object]
    [/event]
    [event] #TODO make it status, give it icon
        id=ability_death_shriek_inflict
        name=die
        first_time_only=no
        [filter]
            ability=death_shriek
        [/filter]
        [modify_unit]
            [filter]
                [filter_side]
                    [enemy_of]
                        side=$unit.side
                    [/enemy_of]
                [/filter_side]
                [filter_location]
                    x,y=$x1,$y1
                    radius=2
                [/filter_location]
            [/filter]
            [object]
                id=ringing_ears
                take_only_once=no
                silent=yes
                duration=scenario
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_RINGING_EARS}
                    [/abilities]
                [/effect]
            [/object]
            [variables]
                ringing_ears_remove_turn="$(if($this_unit.side = $side_number,$( $turn_number + 1 ),$turn_number))"
            [/variables]
        [/modify_unit]
    [/event]
    [event]
        id=ability_death_shriek_remove
        name=side turn end
        first_time_only=no
        [remove_object]
            side=$side_number
            #race="$(if($this_unit.variables.ringing_ears_remove_turn <= $turn_number,1,0))"
            #  [filter_wml]
            #      [variables]
            #          ringing_ears_remove_turn=0 - 10
            #      [/variables]
            #  [/filter_wml]
            #formula="debug_print(self.wml_vars.ringing_ears_remove_turn) <= debug_print(turn_number)"
            lua_function=BfBH.filter.death_shriek
            object_id=ringing_ears
        [/remove_object]
    [/event]
    [event]
        name=die
        id=ability_immortal
        priority=3000
        first_time_only=no
        [filter]
            ability=immortal
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
unit:transform("BfBH Lich")
unit:remove_modifications({id="resilient", wml.tag['or']{id="strong"}, wml.tag['or']{id="intelligent"}, wml.tag['or']{id="quick"}},"trait")
unit.hitpoints = unit.max_hitpoints
unit.experience=0
animator = wesnoth.units.create_animator()
animator:add(unit,"recruited","hit",{})
animator:run()
unit:to_map() --this is for the unit_placed to trigger, if you know better way, suggest it / replacce this
>>
        [/lua]
    [/event]
    [event]
        name=die
        id=ability_avenger
        #  priority=-10000
        first_time_only=no
        [lua]
            code=<<
local x1 = wesnoth.current.event_context.x1
local x2 = wesnoth.current.event_context.x2
local y1 = wesnoth.current.event_context.y1
local y2 = wesnoth.current.event_context.y2
local u = wesnoth.units.get(x1,y1)
local e = wesnoth.units.get(x2,y2)
e.variables.unavenged_kills = list_add_unique(e.variables.unavenged_kills,wesnoth.sides[u.side].team_name)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        id=ability_avenger_2
        #  priority=-10000
        first_time_only=no
        [filter]
            ability=avenger
        [/filter]
        [lua]
            code=<<
local x1 = wesnoth.current.event_context.x1
local x2 = wesnoth.current.event_context.x2
local y1 = wesnoth.current.event_context.y1
local y2 = wesnoth.current.event_context.y2
local u = wesnoth.units.get(x1,y1)
local e = wesnoth.units.get(x2,y2)
e.variables.unavenged_kills = list_remove(e.variables.unavenged_kills,wesnoth.sides[u.side].team_name)
>>
        [/lua]
    [/event]
    [event]
        name=die
        id=ability_ardent
        #  priority=-10000
        first_time_only=no
        [filter_second]
            ability=ardent
            side=$side_number
        [/filter_second]
        [lua]
            code=<<
local move_bonus = 2
local attack_bonus = 1 --NOTE if set to higher than two, attack -> attacks in string
local units = wesnoth.units.find_on_map({side=wesnoth.current.side,{"filter_location",{x=wesnoth.current.event_context.x2, y=wesnoth.current.event_context.y2 ,radius=2}},{"not",{ability="ardent"}}})
for _, unit in ipairs(units) do
    unit.moves =unit.moves + move_bonus
    unit.attacks_left=unit.attacks_left + attack_bonus
    wesnoth.interface.float_label(unit.x, unit.y, "<span color='#00FF00'>+"..attack_bonus.." attack</span>") --..move_bonus.." moves\n+"
end
>>
        [/lua]
    [/event]
    #  [event]
    #      name=unit_placed #add more on hand
    #      id=limited_uses_max
    #      first_time_only=no
    #      [filter]
    #          [has_attack]
    #              special_id=limited_uses_max
    #          [/has_attack]
    #      [/filter]
    #      [modify_unit]
    #          [filter]
    #              id=$unit.id
    #          [/filter]
    #          [object]
    #              duration=forever
    #              silent=yes
    #              id=limited_uses
    #              take_only_once=yes
    #              [effect]
    #                  apply_to=attack
    #                  special_id=limited_uses_max
    #                  [not]
    #                      special_id=limited_uses
    #                  [/not]
    #                  [set_specials]
    #                      mode=append
    #                      {WEAPON_SPECIAL_LIMITED_USES 3}
    #                  [/set_specials]
    #              [/effect]
    #          [/object]
    #      [/modify_unit]
    #  [/event]
    [event]
        name=unit_placed #add more on hand
        id=ability_veil_of_the_void_1
        first_time_only=no
        [filter]
            ability=veil_of_the_void
            formula="self.wml_vars.mist_of_the_void_get = false or self.wml_vars.mist_of_the_void_get = 0"
        [/filter]
        [modify_unit]
            [filter]
                id=$unit.id
            [/filter]
            [object]
                duration=scenario
                silent=yes
                id=veil_of_the_void
                take_only_once=no
                [effect]
                    apply_to=status
                    add=invulnerable
                [/effect]
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_NIGHTSTALK}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
unit.variables.veil_of_the_void = 4
unit.variables.veil_of_the_void_get = -1 -- -1 means never, 0 means immediatelly
>>
        [/lua]
    [/event]
    [event]
        name=side turn end
        id=ability_veil_of_the_void_2
        first_time_only=no
        #side=$side_number
        #ability=veil_of_the_void
        #formula="self.wml_vars.veil_of_the_void > 0"
        [lua]
            code=<<
local units = wesnoth.units.find({side=wml.variables["side_number"], ability="veil_of_the_void", formula="self.wml_vars.veil_of_the_void > 0"})
for i, unit in ipairs(units) do
    unit.variables.veil_of_the_void = unit.variables.veil_of_the_void - 1
    if unit.variables.veil_of_the_void == 0 then
        unit:remove_modifications({id="veil_of_the_void"})
        unit.status.invulnerable=false
        unit.variables.veil_of_the_void_invulnerable = false --#NOTE in case of more invulnerable-granting things
    end
end
>>
        [/lua]#NOTE add ability that resets it into next scenario/after some turns, if needed
    [/event]
    [event]
        name=unit_placed,recruit,recall,post_advance
        id=ability_rested
        first_time_only=no
        [filter]
            ability=rested
            formula="self.wml_vars.rested = false"
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
--if u.variables.rested == nil then end
u.variables.rested = 5*(1+u.level)
local cfg=u.__cfg
local hp_bonus = u.variables.rested
local new_hp_bonus = hp_bonus
if wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}) == nil then
    wesnoth.wml_actions.object({id="hitpoints_bonus",take_only_once=false,{"effect",{apply_to="hitpoints",increase_total=u.variables.rested, increase=u.variables.rested}},{"filter",{id=u.id}}})
end
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=ability_rested_side_turn
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="rested",{"filter_location",{{"not",{terrain="*^V*,C*^*,K*^*"}}}}})
for _,u in ipairs(units) do
    local cfg=u.__cfg
    local hp_bonus = u.variables.rested
    local new_hp_bonus = math.max(0,hp_bonus - 1)
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase_total = new_hp_bonus
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase = new_hp_bonus
    --wml.find_child(wml.get_child(cfg,"abilities"),"rested",{id="rested"}).description= "+"..new_hp_bonus.." HP"--sadly not persistent
    wesnoth.units.to_map(cfg)
    local new_u=wesnoth.units.get(cfg.x,cfg.y)
    new_u.variables.rested = new_hp_bonus
    wesnoth.units.transform(new_u,new_u.type)
end
units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="rested",{"filter_location",{terrain="*^V*"}}})
for _,u in ipairs(units) do
    local cfg=u.__cfg
    local hp_bonus = u.variables.rested
    local new_hp_bonus = math.min(5*(1+u.level),hp_bonus + 5)
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase_total = new_hp_bonus
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase = new_hp_bonus
    --wml.find_child(wml.get_child(cfg,"abilities"),"rested",{id="rested"}).description= "+"..new_hp_bonus.." HP"--sadly not persistent in ability description
    wesnoth.units.to_map(cfg)
    local new_u=wesnoth.units.get(cfg.x,cfg.y)
    new_u.variables.rested = new_hp_bonus
    wesnoth.units.transform(new_u,new_u.type)
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_storming_event
        name=die
        first_time_only=no
        [filter]
            [filter_location]
                terrain=*^V*,C*^*,K*^*
            [/filter_location]
        [/filter]
        [filter_second]
            ability=storming
        [/filter_second]
        [kill]
            id=$unit.id
            animate=no
            [secondary_unit]
                id=$second_unit.id
            [/secondary_unit]
        [/kill]
        [lua]
            code=<<
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local unit = defender
local unit_cfg = defender.__cfg
local context = wesnoth.current.event_context
    local retreat=wesnoth.named_tuple({context.x1, context.y1}, {'x', 'y'})
    local loc = unit.loc
    if wml.variables["unit[0].level"] == 0 then
        unit.experience = wesnoth.game_config.kill_experience * 0.5
        unit:advance(true,true)
    else
        unit.experience = unit.experience +(wml.variables["unit[0].level"] * wesnoth.game_config.kill_experience)
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) and (wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc)) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
>>
        [/lua]
        {MOVE_UNIT (x,y = $x2,$y2) $x1 $y1}
    [/event]
    [event] #TODO finish
            # slow remove and fast remove events!, deal damage only after healing in villages
        name=attacker hits
        first_time_only=no
        [filter_second]
            [not]
                [filter_wml]
                    [status]
                        not_living="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter_second]
        [filter_attack]
            special_id=bleed
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if variables.bleed == nil or variables.bleed == "" then
variables.bleed = 1
else
variables.bleed = (variables.bleed + 1)
end
variables.bleed_inflicted= wml.variables["unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
wml.variables["second_unit"] = u_table
-- wesnoth.interface.float_label(u_table.x, u_table.y, "Bleeding: " .. variables.bleed)
>>
        [/lua]
        [if]
            [have_unit]
                id=$second_unit.id
                [not]
                    [filter_wml]
                        [status]
                            bleeding=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/have_unit]
            [then]
                {VARIABLE second_unit.status.bleeding yes}
                [unstore_unit]
                    variable=second_unit
                    find_vacant=no
                    text=_ "bleeding"
                    red,green,blue=255,0,0
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        id=$second_unit.id
                    [/filter]
                    {BLEEDING_OBJECT}
                [/modify_unit]
            [/then]
        [/if]
    [/event]
    [event]
        name=defender hits
        id=bleed_event_2
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [status]
                        not_living="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=bleed
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if variables.bleed == nil or variables.bleed == "" then
    variables.bleed = 1
else
    variables.bleed = (variables.bleed + 1)
end
variables.bleed_inflicted= wml.variables["second_unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
wml.variables["second_unit"] = u_table
>>
        [/lua]
        [if]
            [have_unit]
                id=$unit.id
                [not]
                    [filter_wml]
                        [status]
                            bleeding=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/have_unit]
            [then]
                {VARIABLE unit.status.bleeding yes}
                [unstore_unit]
                    variable=unit
                    find_vacant=no
                    text=_ "bleeding"
                    red,green,blue=255,0,0
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        id=$unit.id
                    [/filter]
                    {BLEEDING_OBJECT}
                [/modify_unit]
            [/then]
        [/if]
    [/event]
    [event]
        name=side turn
        id=bleed_event_3
        first_time_only=no
        [store_unit]
            [filter]
                side=$side_number
                [filter_wml]
                    [status]
                        bleeding="yes"
                    [/status]
                [/filter_wml]
            [/filter]
            variable=bleeding_units
        [/store_unit]
        [for]
            start=$($bleeding_units.length - 1)
            step=-1
            variable=i
            end=0
            [do]
                [harm_unit]
                    [filter]
                        x,y=$bleeding_units[$i].x,$bleeding_units[$i].y
                    [/filter]
                    [filter_second]
                        id=$bleeding_units[$i].variables.bleed_inflicted
                    [/filter_second]
                    amount=$bleeding_units[$i].variables.bleed
                    fire_event=yes
                    animate=defender
                    kill=yes
                    experience=kill
                [/harm_unit]
#                  [lua]
#                      code=<<
#  local u_table = wml.variables["unit"]
#  local variables = wml.get_child(u_table, "variables")
#  if variables.bleed == nil or variables.bleed == "" then
#      variables.bleed = 1
#  else
#      variables.bleed = (variables.bleed + 1)
#  end
#  variables.bleed_inflicted= wml.variables["second_unit"].id
#  wesnoth.units.erase(u_table.x,u_table.y)
#  wesnoth.units.to_map(u_table)
#  >>
#                  [/lua]
            [/do]
        [/for]
        {CLEAR_VARIABLE bleeding_units}
    [/event]
    [event]
        name=advance
        id=bleed_event_4
        first_time_only=no

        [filter]
            status=bleeding
        [/filter]

        {VARIABLE unit.status.bleeding no}

        [unstore_unit]
            variable=unit
            find_vacant=no
            advance=no
        [/unstore_unit]

        [remove_object]
            x,y=$unit.x,$unit.y
            object_id=bleeding_object
        [/remove_object]
    [/event]

    [event]
        name=victory
        id=bleed_event_5

        [remove_object]
            object_id=bleeding_object
            status=bleeding
        [/remove_object]

        [modify_unit]
            [filter]
                status=bleeding
            [/filter]

            [status]
                bleeding=no
            [/status]
        [/modify_unit]
    [/event]

    [event]
        name=side turn
        id=bleed_event_6
        first_time_only=no

        [remove_object]
            object_id=bleeding_object
            side=$side_number
            status=bleeding
            [and]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
                [or]
                    ability_type_active=regenerate
                [/or]
                [or]
                    [filter_adjacent]
                        is_enemy=no
                        [and]
                            ability_type=heals
                        [/and]
                    [/filter_adjacent]
                [/or]
            [/and]
        [/remove_object]

        [store_unit]
            [filter]
                side=$side_number
                status=bleeding
                [and]
                    [filter_location]
                        terrain=*^V*
                    [/filter_location]
                    [or]
                        ability_type_active=regenerate
                    [/or]
                    [or]
                        [filter_adjacent]
                            is_enemy=no
                            [and]
                                ability_type=heals
                            [/and]
                        [/filter_adjacent]
                    [/or]
                [/and]
            [/filter]
            variable=bleeding_units
        [/store_unit]

        [foreach]
            array=bleeding_units
            [do]
                {VARIABLE this_item.status.bleeding no}
                [unstore_unit]
                    variable=this_item
                    find_vacant=no
                [/unstore_unit]
                [heal_unit]
                    [filter]
                        x,y=$this_item.x,$this_item.y
                    [/filter]
                    amount=0
                    moves=full
                    animate=no
                    restore_statuses=no
                [/heal_unit]
            [/do]
        [/foreach]
        {CLEAR_VARIABLE bleeding_units}
    [/event]



    [event]
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=crippling_blow
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if variables.crippled == nil or variables.crippled == "" then
    variables.crippled = 5
else
    variables.crippled = (variables.crippled + 5)
end
if variables.crippled > 100 then
    variables.crippled = 100
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [if]
            [have_unit]
                x,y=$x2,$y2
                status=crippled
            [/have_unit]
            [then]
            [/then]
            [else]
                [modify_unit]
                    [filter]
                        x,y=$x2,$y2
                    [/filter]
                    [status]
                        crippled=yes
                    [/status]
                    [object]
                        id=crippled
                        silent=yes
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                [damage]
                                    id=crippled
                                    multiply="((100.0 - self.wml_vars.crippled) / 100.0)"
                                [/damage]
                            [/abilities]
                        [/effect]
                    [/object]
                [/modify_unit]
            [/else]
        [/if]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=crippling_blow
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if variables.crippled == nil or variables.crippled == "" then
    variables.crippled = 5
else
    variables.crippled = (variables.crippled + 5)
end
if variables.crippled > 100 then
    variables.crippled = 100
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [if]
            [have_unit]
                x,y=$x1,$y1
                status=crippled
            [/have_unit]
            [then]
            [/then]
            [else]
                [modify_unit]
                    [filter]
                        x,y=$x1,$y1
                    [/filter]
                    [status]
                        crippled=yes
                    [/status]
                    [object]
                        id=crippled
                        silent=yes
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                [damage]
                                    id=crippled
                                    multiply="((100.0 - self.wml_vars.crippled) / 100.0)"
                                [/damage]
                            [/abilities]
                        [/effect]
                    [/object]
                [/modify_unit]
            [/else]
        [/if]
    [/event]
    [event]
        name=post advance
        [if]
            [have_unit]
                x,y=$x1,$y1
                status=crippled
            [/have_unit]
            [then]
                [modify_unit]
                    [filter]
                        x,y=$x1,$y1
                    [/filter]
                    [status]
                        crippled=no
                    [/status]
                [/modify_unit]
                [remove_object]
                    x,y=$x1,$y1
                    object_id=crippled
                [/remove_object]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.crippled = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
        [/if]
    [/event]
    [event]
        name=turn refresh
        first_time_only=no
        [modify_unit]
            [filter]
                side=$side_number
                status=crippled
                [and]
                    [filter_location]
                        terrain=*^V*
                    [/filter_location]
                    [or]
                        [experimental_filter_ability]
                            value=8
                            id=regenerates
                        [/experimental_filter_ability]
                    [/or]
                [/and]
                [or]
                    status=crippled
                    [filter_adjacent]
                        side=$side_number
                        is_enemy=no
                        [experimental_filter_ability]
                            value=8
                            id=healing
                            affect_allies=yes
                        [/experimental_filter_ability]
                    [/filter_adjacent]
                [/or]
            [/filter]
            [set_variable]
                name=crippled
                sub=20
            [/set_variable]
        [/modify_unit]
        [remove_object]
            status=crippled
            formula="(self.wml_vars.crippled <= 0)"
            object_id=crippled
        [/remove_object]
        [modify_unit]
            [filter]
                status=crippled
                formula="(self.wml_vars.crippled <= 0)"
            [/filter]
            [set_variable]
                name=crippled
                value=0
            [/set_variable]
            [status]
                crippled=no
            [/status]
        [/modify_unit]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=limited_uses
        [/filter_attack]
        [filter]
        [/filter]
        [lua]
            code="wesnoth.dofile '~add-ons/Bandits_from_Brown_Hills/lua/special_limited_uses.lua'"
        [/lua]
    [/event]
    [event] #TODO FOR FUTURE ME!!!! UPGRADE THIS
        name=unit_placed
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [modifications]
                        [object]
                            id="counter_object"
                        [/object]
                    [/modifications]
                [/filter_wml]
            [/not]
        [/filter]
        [object]
            id=counter_object
            take_only_once=no
            silent=yes
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    [chance_to_hit]
                        id=counter_effect
                        add="(self.wml_vars.counter * 1000)"
                    [/chance_to_hit]
                [/abilities]
            [/effect]
        [/object]
    [/event]



    [event]
        name=attack_end
        first_time_only=no
        id=combat_last_attack_attack_end
        [filter_attack]
            special_id=calibrated,aggressive,parry
        [/filter_attack]
        [filter_condition]
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
u.variables.first_attack = nil
u.variables.first_defense = nil
            >>
        [/lua]
    [/event]

    [event]
        name=attack_end
        first_time_only=no
        id=combat_last_defense_attack_end
        [filter_second_attack]
            special_id=calibrated,aggressive,parry
        [/filter_second_attack]
        [filter_condition]
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
u.variables.first_attack = nil
u.variables.first_defense = nil
            >>
        [/lua]
    [/event]

    [event]
        name=attacker hits
        first_time_only=no
        id=last_attack_hit
        [filter_attack]
            special_id=calibrated,aggressive
        [/filter_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u.variables.first_attack == nil then
    u.variables.first_attack = "hit"
end
if u.variables.last_attack == "hit" then
    u.variables.last_attack_streak=u.variables.last_attack_streak+1
else
    u.variables.last_attack_streak=1
end
u.variables.last_attack = "hit"
            >>
        [/lua]
    [/event]
    [event]
        name=attacker misses
        first_time_only=no
        id=last_attack_miss
        [filter_attack]
            special_id=calibrated,aggressive
        [/filter_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u.variables.first_attack == nil then
    u.variables.first_attack = "miss"
end
if u.variables.last_attack == "miss" then
    u.variables.last_attack_streak=u.variables.last_attack_streak+1
else
    u.variables.last_attack_streak=1
end
u.variables.last_attack = "miss"
            >>
        [/lua]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        id=last_attack_hit_defend
        [filter_second_attack]
            special_id=calibrated,aggressive
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if u.variables.first_attack == nil then
    u.variables.first_attack = "hit"
end
if u.variables.last_attack == "hit" then
    u.variables.last_attack_streak=u.variables.last_attack_streak+1
else
    u.variables.last_attack_streak=1
end
u.variables.last_attack = "hit"
            >>
        [/lua]
    [/event]
    [event]
        name=defender misses
        first_time_only=no
        id=last_attack_miss_defend
        [filter_second_attack]
            special_id=calibrated,aggressive
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if u.variables.first_attack == nil then
    u.variables.first_attack = "miss"
end
if u.variables.last_attack == "miss" then
    u.variables.last_attack_streak=u.variables.last_attack_streak+1
else
    u.variables.last_attack_streak=1
end
u.variables.last_attack = "miss"
            >>
        [/lua]
    [/event]


    [event]
        name=attacker hits
        first_time_only=no
        id=last_defense_hit
        [filter_second_attack]
            special_id=parry
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if u.variables.first_defense== nil then
    u.variables.first_defense = "hit"
end
if u.variables.last_defense == "hit" then
    u.variables.last_defense_streak=u.variables.last_defense_streak+1
else
    u.variables.last_defense_streak=1
end
u.variables.last_defense = "hit"
            >>
        [/lua]
    [/event]
    [event]
        name=attacker misses
        first_time_only=no
        id=last_defense_miss
        [filter_second_attack]
            special_id=parry
        [/filter_second_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if u.variables.first_defense == nil then
    u.variables.first_defense = "miss"
end
if u.variables.last_defense == "miss" then
    u.variables.last_defense_streak=u.variables.last_defense_streak+1
else
    u.variables.last_defense_streak=1
end
u.variables.last_defense = "miss"
            >>
        [/lua]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        id=last_defense_hit_defend
        [filter_attack]
            special_id=parry
        [/filter_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u.variables.first_defense == nil then
    u.variables.first_defense = "hit"
end
if u.variables.last_defense == "hit" then
    u.variables.last_defense_streak=u.variables.last_defense_streak+1
else
    u.variables.last_defense_streak=1
end
u.variables.last_defense = "hit"
            >>
        [/lua]
    [/event]
    [event]
        name=defender misses
        first_time_only=no
        id=last_defense_miss_defend
        [filter_attack]
            special_id=parry
        [/filter_attack]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u.variables.first_defense == nil then
    u.variables.first_defense = "miss"
end
if u.variables.last_defense == "miss" then
    u.variables.last_defense_streak=u.variables.last_defense_streak+1
else
    u.variables.last_defense_streak=1
end
u.variables.last_defense = "miss"
            >>
        [/lua]
    [/event]

    [event]
        name=attack
        first_time_only=no
        priority=1000
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u.variables.attacker_order == nil or u.variables.attacker_order == 0 then
    u.variables.attacker_order = 1
end
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter]
            [filter_wml]
                [variables]
                    attacker_order=1
                [/variables]
            [/filter_wml]
        [/filter]
        [filter_attack]
            special_id=packstrike
        [/filter_attack]
        #[inspect][/inspect]
        [lua]
            code=<<
std_print("ATTACK")
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local e = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if e.hitpoints <= 0 then
    return
end
local neighbors1 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x1, wesnoth.current.event_context.y1}))
local neighbors2 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x2, wesnoth.current.event_context.y2}))
local attackers_loc = {}
for _, h1 in ipairs(neighbors1) do
    for _, h2 in ipairs(neighbors2) do
        if h1[1] == h2[1] and h1[2] == h2[2] then
            table.insert(attackers_loc, h1)
        end
    end
end
local attackers = {}
for _, loc in ipairs(attackers_loc) do
    if wesnoth.units.get(loc) ~= nil and wesnoth.units.get(loc).side == u.side then
        table.insert(attackers, wesnoth.units.get(loc))
    end
end
local defender=e
for _, attacker in ipairs(attackers) do
    attacker.facing=wesnoth.map.get_relative_dir(attacker.x, attacker.y, defender.x, defender.y)

    local _, _, attacker_stats, defender_stats = wesnoth.simulate_combat(attacker, defender) --to handle nil cases of defending_weapon_index
    local defending_weapon_index = 1
    while defender.attacks[defending_weapon_index] ~= nil do
        if wml.get_child(wesnoth.current.event_context,"second_weapon").name == defender.attacks[defending_weapon_index].name then
            -- _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker, defender, defending_weapon_index)
            -- TODO not working, for my implementation all units do attack with first avaible weapon :/
            _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker, 1, defender, defending_weapon_index)
            break
        end
        defending_weapon_index= defending_weapon_index + 1
    end --for attacker best weapon against that one that defender already uses for defence

    attacker.variables.attacker_order=2
    attacker.variables.attacking_weapon=attacker_stats.number
    attacker.variables.defenders_weapon=defending_weapon_index
    attacker.variables.strikes_left=attacker_stats.num_blows
    std_print("attacker stats number: "..attacker_stats.number.."    defending_weapon_index: "..defending_weapon_index.."    num_blows: "..attacker_stats.num_blows)
    local w2 = nil
    if defender.attacks[attacker.variables.defenders_weapon] ~= nil then
        w2 = defender.attacks[attacker.variables.defenders_weapon].__cfg
    end
    wesnoth.game_events.fire("attack", attacker.loc, defender.loc, {{"first",attacker.attacks[attacker.variables.attacking_weapon].__cfg},{"second",w2}})
end
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        priority=-100
        [filter_condition]
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter]
        [filter_wml]
            [variables]
                attacker_order=1
            [/variables]
        [/filter_wml]
        [/filter]
        [filter_attack]
            special_id=packstrike
        [/filter_attack]
        [lua]
            code=<<
std_print("ATTACK END")
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local e = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)

local neighbors1 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x1, wesnoth.current.event_context.y1}))
local neighbors2 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x2, wesnoth.current.event_context.y2}))
local attackers_loc = {}
for _, h1 in ipairs(neighbors1) do
    for _, h2 in ipairs(neighbors2) do
        if h1[1] == h2[1] and h1[2] == h2[2] then
            table.insert(attackers_loc, h1)
        end
    end
end
local attackers = {}
for _, loc in ipairs(attackers_loc) do
    if wesnoth.units.get(loc) ~= nil and wesnoth.units.get(loc).side == u.side then
        table.insert(attackers, wesnoth.units.get(loc))
    end
end
local defender=e
for _, attacker in ipairs(attackers) do
    local w2_num = nil
    if defender.attacks[attacker.variables.defenders_weapon] then
        w2_num=attacker.variables.defenders_weapon
    end
    local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacker.variables.attacking_weapon, defender,w2_num)--attacker.variables.defenders_weapon -- THIS IF I'd want defensive specials of weapon to apply, but enemy doesn't fight back, so no specials take effect
    local w = attacker.attacks[attacker_stats.name]
    local w2 = nil
    local w2_cfg=nil
    if defender_stats.name ~= nil then
        w2 = defender.attacks[defender_stats.name]
        w2_cfg = w2.__cfg
    end
    wesnoth.game_events.fire("attack_end", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg}})
end
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        priority=-10000000
        [set_variable]
            name=fire_no_attack_end_event
            value=no
        [/set_variable]
    [/event]
    [event]
        name=attacker hits, attacker misses
        first_time_only=no
        priority=-1000000
        [filter]
            [filter_wml]
                [variables]
                    attacker_order=1
                [/variables]
            [/filter_wml]
        [/filter]
        [filter_attack]
            special_id=packstrike
        [/filter_attack]
        [lua]
            code=<<
std_print("ATTACKED UNIT")
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local e = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if e.hitpoints <= 0 then
    return
end
local animator = wesnoth.units.create_animator()

local neighbors1 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x1, wesnoth.current.event_context.y1}))
local neighbors2 = table.pack(wesnoth.map.get_adjacent_hexes({wesnoth.current.event_context.x2, wesnoth.current.event_context.y2}))
local attackers_loc = {}
for _, h1 in ipairs(neighbors1) do
    for _, h2 in ipairs(neighbors2) do
        if h1[1] == h2[1] and h1[2] == h2[2] then
            table.insert(attackers_loc, h1)
        end
    end
end
local attackers = {}
for _, loc in ipairs(attackers_loc) do
    if wesnoth.units.get(loc) ~= nil and wesnoth.units.get(loc).side == u.side then
        table.insert(attackers, wesnoth.units.get(loc))
    end
end
defender=e
std_print("pack attack for loop")
for _, attacker in ipairs(attackers) do
    if attacker.variables.strikes_left > 0 then
        attacker.variables.strikes_left=attacker.variables.strikes_left-1
        attacker.facing=wesnoth.map.get_relative_dir(attacker.x, attacker.y, defender.x, defender.y)
        defender.facing=wesnoth.map.get_relative_dir(defender.x, defender.y,attacker.x, attacker.y)
        -- defender.attacks[attacker.variables.defenders_weapon] = {movement_used=100000,attacks_used=1}
        local loc = attacker.loc
        local loc2 = defender.loc
        local w2_num = nil
        if defender.attacks[attacker.variables.defenders_weapon] then
            w2_num=attacker.variables.defenders_weapon
        end
        local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacker.variables.attacking_weapon, defender,w2_num)-- -- THIS IF I'd want defensive specials of weapon to apply, but enemy doesn't fight back, so no specials take effect
        local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
        local w = attacker.attacks[attacker_stats.name]
        local w2 = nil
        local w2_cfg=nil
        if defender_stats.name ~= nil then
            w2 = defender.attacks[defender_stats.name]
            w2_cfg = w2.__cfg
        end
        std_print("hit/miss?")
        if mathx.random() < (attacker_stats.chance_to_hit/100) then

            local damage_inflicted = math.floor(attacker_stats.damage)

            local drain = 0
            if attacker_stats.drains then
                drain = math.floor(math.min((math.min(damage_inflicted,defender.hitpoints) * attacker_stats.drain_percent / 100) + attacker_stats.drain_constant, math.max(attacker.max_hitpoints - attacker.hitpoints,0)))
            end
            local text = ""
            if drain ~= 0 then
                text = text..drain
            end

            local text2 =  damage_inflicted.."\n"
            local add_tab = false
            local gender = defender.gender
            local statuses = {}

            local function set_status(ability, name, male_string, female_string, sound)
                if not attacker_stats[ability] or defender.status[name] then return end
                if gender == "female" then
                    text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
                else
                    text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
                end

                statuses[#statuses+1]=name
                add_tab = true

                if sound then -- for unhealable, that has no sound
                    wesnoth.audio.play(sound)
                end --TODO should I do this???
            end
            if not defender.status.unpoisonable then
                set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
            end
            set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
            set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
            if add_tab then
                text2 = string.format("%s%s", "     ", text2)
            end

            animator:add(attacker, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}})
            animator:add(defender, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}})
            animator:run()
            animator:clear()
            for i=1, #statuses do
                defender.status[statuses[i]] = true
            end
            attacker.hitpoints=(attacker.hitpoints + drain)
            defender.hitpoints=(defender.hitpoints - attacker_stats.damage)
            wesnoth.game_events.fire("attacker_hits", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted})
            std_print("deal damage")
            -- wesnoth.wml_actions.inspect({})
            if defender.valid == nil or defender.hitpoints <= 0 then
                wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
                if defender.valid == nil then
                    std_print("defender doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code")
                    break
                end
                wesnoth.game_events.fire("last breath", loc2, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
                animator:add(defender, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted TODO unsure!
                animator:run()
                animator:clear()
                defender_level = defender.level
                defender_id= defender.id
                wesnoth.game_events.fire("die", defender.loc, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
                wesnoth.wml_actions.kill({ id = defender_id, animate = false, fire_event = false})
                if defender_level == 0 then
                    attacker.experience = wesnoth.game_config.kill_experience * 0.5
                    attacker:advance(true,true)
                else
                    attacker.experience = attacker.experience +(defender_level * wesnoth.game_config.kill_experience)
                    attacker:advance(true,true)
                end
                std_print("fight should end")
                wml.variables["fire_no_attack_end_event"] = true
                -- "breaks" endurance (not enemies, no problem), defender fights util he gets attacked by the original enemy (it should continue even after it's hit by original enemy probably)
                -- raider doesn't work, ranged retalaition weapon, naga guardian, saurian ...
                -- at end set all combat variables to nil
                -- TODO deosn't work for berserker (not intended, just a warning for future me), untested with plague
                break
            end
        else
            animator:add(attacker, "attack", "miss",{with_bars = true, primary = w, secondary = w2})
            animator:add(defender, "defend", "miss",{with_bars = true, primary = w2, secondary = w}) --inverted TODO unsure!
            animator:run()
            animator:clear()
            wesnoth.game_events.fire("attacker_misses", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg}})

        end
    end
end
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        priority=-10000
        [filter_condition]
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if u then
    u.variables.attacker_order = 0
    u.variables.attacking_weapon=nil
    u.variables.defenders_weapon=nil
    u.variables.strikes_left=nil
end
>>
        [/lua]
    [/event]






    [event]
        name=attacker_hits, attacker_misses
        first_time_only=no
        priority=-1000
        [filter_attack]
            special_id=doublestrike
        [/filter_attack]
        [lua]
            code=<<
if wesnoth.current.event_context[1][2].next_attack == false then
    goto skip
end
std_print(wesnoth.current.event_context[1][2].next_attack)
local x1 = wesnoth.current.event_context.x1
local x2 = wesnoth.current.event_context.x2
local y1 = wesnoth.current.event_context.y1
local y2 = wesnoth.current.event_context.y2
local u = wesnoth.units.get(x1,y1)
local e = wesnoth.units.get(x2,y2)

local animator = wesnoth.units.create_animator()

local loc = u.loc
local loc2 = e.loc
local w = wml.get_child(wesnoth.current.event_context,"weapon")
local w2 = wml.get_child(wesnoth.current.event_context,"second_weapon")
local attacker = u
local defender = e

if e.valid ~= nil and e.hitpoints <= 0 then
    goto skip
end

if e ~= nil then
    u.facing=wesnoth.map.get_relative_dir({u.x, u.y},{e.x, e.y})
    e.facing=wesnoth.map.get_relative_dir({e.x, e.y},{u.x, u.y})

    local _, _, attacker_stats, defender_stats = wesnoth.simulate_combat(u,e)
    local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
    local attacking_weapon_index = 1
    while e.attacks[attacking_weapon_index] ~= nil do
        if wml.get_child(wesnoth.current.event_context,"weapon").name == u.attacks[attacking_weapon_index].name then
            _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(u, attacking_weapon_index, e)
            _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
            break
        end
        attacking_weapon_index= attacking_weapon_index + 1
    end
    local w_index = attacker_stats.number
    local w2_index = defender_stats.number
    --gui.show_inspector({})
    local w = u.attacks[w_index]
    local w2_cfg=nil
    if defender_stats.name ~= nil then
        w2 = defender.attacks[defender_stats.name]
        w2_cfg = w2.__cfg
    end
    local w2 = e.attacks[w2_index]

    if mathx.random() < (attacker_stats.chance_to_hit/100) then

        local damage_inflicted = math.floor(attacker_stats.damage)

        local drain = 0
        if attacker_stats.drains then
            drain = math.floor(math.min((math.min(damage_inflicted,defender.hitpoints) * attacker_stats.drain_percent / 100) + attacker_stats.drain_constant, math.max(attacker.max_hitpoints - attacker.hitpoints,0)))
        end
        local text = ""
        if drain ~= 0 then
            text = text..drain
        end

        local text2 =  damage_inflicted.."\n"
        local add_tab = false
		local gender = defender.gender
        local statuses = {}

		local function set_status(ability, name, male_string, female_string, sound)
			if not attacker_stats[ability] or defender.status[name] then return end
			if gender == "female" then
				text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
			else
				text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
			end

            statuses[#statuses+1]=name
			add_tab = true

			if sound then -- for unhealable, that has no sound
				wesnoth.audio.play(sound)
			end --TODO should I do this???
		end
        if not defender.status.unpoisonable then
			set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
		end
		set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
		set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
		if add_tab then
			text2 = string.format("%s%s", "     ", text2)
		end

        animator:add(attacker, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}, value={damage_inflicted,1}}) --TODO 1 is here just becouse it has currenty no effect, and I'm lazy
        animator:add(defender, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}, value={damage_inflicted,1}}) --TODO 1
        animator:run()
        animator:clear()
        wesnoth.wml_actions.redraw({})
        for i=1, #statuses do
            defender.status[statuses[i]] = true
        end
        attacker.hitpoints=(attacker.hitpoints + drain)
        defender.hitpoints=(defender.hitpoints - attacker_stats.damage)
        std_print("firing attacker_hits")
        wesnoth.game_events.fire("attacker_hits", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted,next_attack=false})
        std_print("deal damage")
        if defender.valid == nil or defender.hitpoints <= 0 then
            wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
            if defender.valid == nil then
                std_print("defender doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code")
                goto skip
            end
            wesnoth.game_events.fire("last breath", loc2, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            animator:add(defender, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted TODO unsure!
            animator:run()
            animator:clear()
            defender_level = defender.level
            defender_id= defender.id
            wesnoth.game_events.fire("die", defender.loc, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            wesnoth.wml_actions.kill({ id = defender_id, animate = false, fire_event = false})
            if defender_level == 0 then
                attacker.experience = wesnoth.game_config.kill_experience * 0.5
                attacker:advance(true,true)
            else
                attacker.experience = attacker.experience +(defender_level * wesnoth.game_config.kill_experience) - defender_level --(NOTE becouse it gets also fight xp... this may cause issues)
                attacker:advance(true,true)
            end
            std_print("fight should end")
            wml.variables["fire_no_attack_end_event"] = true
            -- "breaks" endurance (not enemies, no problem), defender fights util he gets attacked by the original enemy (it should continue even after it's hit by original enemy probably)
            -- raider doesn't work, ranged retalaition weapon, naga guardian, saurian ...
            -- at end set all combat variables to nil
            -- TODO deosn't work for berserker (not intended, just a warning for future me), untested with plague
            goto skip
        end
    else

        --Miss animation
        animator:add(u, "attack", "miss",{with_bars = true, primary = w, secondary = w2,value = {0,1}}) --TODO 1 is here just becouse it has currenty no effect, and I'm lazy
        animator:add(e, "defend", "miss",{with_bars = true, primary = w2, secondary = w, value = {0,1}}) --inverted TODO unsure! --value = {0,1} --no damage, first defenders strike -TODO 1
        animator:run()
        animator:clear()
        wesnoth.wml_actions.redraw({})
        std_print("firing attacker misses")
        wesnoth.game_events.fire("attacker_misses", loc, loc2,{{"first",w.__cfg},{"second",w2_cfg},next_attack=false})
    end
end
::skip::
>>
        [/lua]
    [/event]
    [event]
        name=defender_hits, defender_misses
        first_time_only=no
        priority=-1000
        [filter_second_attack]
            special_id=doublestrike
        [/filter_second_attack]
        [lua]
            code=<<
if wesnoth.current.event_context[1][2].next_attack == false then
    goto skip
end
std_print(wesnoth.current.event_context[1][2].next_attack)
local x1 = wesnoth.current.event_context.x1
local x2 = wesnoth.current.event_context.x2
local y1 = wesnoth.current.event_context.y1
local y2 = wesnoth.current.event_context.y2
local e = wesnoth.units.get(x1,y1)
local u = wesnoth.units.get(x2,y2)

local animator = wesnoth.units.create_animator()

local loc = u.loc
local loc2 = e.loc
local w = wml.get_child(wesnoth.current.event_context,"second_weapon")
local w2 = wml.get_child(wesnoth.current.event_context,"weapon")
local attacker = u
local defender = e

if e.valid ~= nil and e.hitpoints <= 0 then
    goto skip
end

if e ~= nil then
    u.facing=wesnoth.map.get_relative_dir({u.x, u.y},{e.x, e.y})
    e.facing=wesnoth.map.get_relative_dir({e.x, e.y},{u.x, u.y})

    local _, _, attacker_stats, defender_stats = wesnoth.simulate_combat(u,e)
    local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
    local attacking_weapon_index = 1
    while e.attacks[attacking_weapon_index] ~= nil do
        if wml.get_child(wesnoth.current.event_context,"weapon").name == u.attacks[attacking_weapon_index].name then
            _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(u, attacking_weapon_index, e)
            _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
            break
        end
        attacking_weapon_index= attacking_weapon_index + 1
    end
    local w_index = attacker_stats.number
    local w2_index = defender_stats.number
    --gui.show_inspector({})
    local w = u.attacks[w_index]
    local w2_cfg=nil
    if defender_stats.name ~= nil then
        w2 = defender.attacks[defender_stats.name]
        w2_cfg = w2.__cfg
    end
    local w2 = e.attacks[w2_index]

    if mathx.random() < (attacker_stats.chance_to_hit/100) then

        local damage_inflicted = math.floor(attacker_stats.damage)

        local drain = 0
        if attacker_stats.drains then
            drain = math.floor(math.min((math.min(damage_inflicted,defender.hitpoints) * attacker_stats.drain_percent / 100) + attacker_stats.drain_constant, math.max(attacker.max_hitpoints - attacker.hitpoints,0)))
        end
        local text = ""
        if drain ~= 0 then
            text = text..drain
        end

        local text2 =  damage_inflicted.."\n"
        local add_tab = false
		local gender = defender.gender
        local statuses = {}

		local function set_status(ability, name, male_string, female_string, sound)
			if not attacker_stats[ability] or defender.status[name] then return end
			if gender == "female" then
				text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
			else
				text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
			end

            statuses[#statuses+1]=name
			add_tab = true

			if sound then -- for unhealable, that has no sound
				wesnoth.audio.play(sound)
			end --TODO should I do this???
		end
        if not defender.status.unpoisonable then
			set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
		end
		set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
		set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
		if add_tab then
			text2 = string.format("%s%s", "     ", text2)
		end

        animator:add(attacker, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}, value={damage_inflicted,1}}) --TODO 1 is here just becouse it has currenty no effect, and I'm lazy
        animator:add(defender, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}, value={damage_inflicted,1}}) --TODO 1
        animator:run()
        animator:clear()
        wesnoth.wml_actions.redraw({})
        for i=1, #statuses do
            defender.status[statuses[i]] = true
        end
        attacker.hitpoints=(attacker.hitpoints + drain)
        defender.hitpoints=(defender.hitpoints - attacker_stats.damage)
        std_print("firing attacker_hits")
        wesnoth.game_events.fire("attacker_hits", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted,next_attack=false})
        std_print("deal damage")
        if defender.valid == nil or defender.hitpoints <= 0 then
            wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
            if defender.valid == nil then
                std_print("defender doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code")
                goto skip
            end
            wesnoth.game_events.fire("last breath", loc2, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            animator:add(defender, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted TODO unsure!
            animator:run()
            animator:clear()
            defender_level = defender.level
            defender_id= defender.id
            wesnoth.game_events.fire("die", defender.loc, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            wesnoth.wml_actions.kill({ id = defender_id, animate = false, fire_event = false})
            if defender_level == 0 then
                attacker.experience = wesnoth.game_config.kill_experience * 0.5
                attacker:advance(true,true)
            else
                attacker.experience = attacker.experience +(defender_level * wesnoth.game_config.kill_experience) - defender_level --(NOTE becouse it gets also fight xp... this may cause issues)
                attacker:advance(true,true)
            end
            std_print("fight should end")
            wml.variables["fire_no_attack_end_event"] = true
            -- "breaks" endurance (not enemies, no problem), defender fights util he gets attacked by the original enemy (it should continue even after it's hit by original enemy probably)
            -- raider doesn't work, ranged retalaition weapon, naga guardian, saurian ...
            -- at end set all combat variables to nil
            -- TODO deosn't work for berserker (not intended, just a warning for future me), untested with plague
            goto skip
        end
    else

        --Miss animation
        animator:add(u, "attack", "miss",{with_bars = true, primary = w, secondary = w2,value = {0,1}}) --TODO 1 is here just becouse it has currenty no effect, and I'm lazy
        animator:add(e, "defend", "miss",{with_bars = true, primary = w2, secondary = w, value = {0,1}}) --inverted TODO unsure! --value = {0,1} --no damage, first defenders strike -TODO 1
        animator:run()
        animator:clear()
        wesnoth.wml_actions.redraw({})
        std_print("firing attacker misses")
        wesnoth.game_events.fire("attacker_misses", loc, loc2,{{"first",w.__cfg},{"second",w2_cfg},next_attack=false})
    end
end
::skip::
>>
        [/lua]
    [/event]









    [event]
        name=attack
        first_time_only=no
        [filter_attack]
            special=danse_macabre
        [/filter_attack]
        [lua]
        code=<<
if wesnoth.current.event_context[1][2].attackers_attack_fired == true then
    goto skip
end
local x1 = wesnoth.current.event_context.x1
local y1 = wesnoth.current.event_context.y1
local u = wesnoth.units.get(x1,y1)
u.variables.danse_macabre_jumps_left=u.max_moves --So AI isn't limited
u.variables.strikes_done = 0
::skip::
>>
        [/lua]
    [/event]
    [event]
        name=attacker_hits, attacker_misses, next_attack
        first_time_only=no
        priority=-1000
        [filter_attack]
            special_id=danse_macabre
        [/filter_attack]
        [lua]
            code=<<
if wesnoth.current.event_context[1][2].next_attack == false then
    goto skip
end
std_print(wesnoth.current.event_context[1][2].next_attack)
local x1 = wesnoth.current.event_context.x1
local x2 = wesnoth.current.event_context.x2
local y1 = wesnoth.current.event_context.y1
local y2 = wesnoth.current.event_context.y2
local u = wesnoth.units.get(x1,y1)
local e = wesnoth.units.get(x2,y2)
if wesnoth.current.event_context[1][2].next_attack == nil then
    u.variables.battle_xp=e.level
end

local animator = wesnoth.units.create_animator()


local t=u.__cfg
local dir = wesnoth.map.get_relative_dir({x1, y1},{x2, y2})
local loc = wesnoth.map.get_direction({x1, y1},dir,2)
if u:movement_on(wesnoth.map.get(loc).terrain) == 99 or wesnoth.units.get(loc) ~= nil then
    --this should happen only first time, it's also an protection against erasing units, if a unexpected code gets fired in events
    goto skip
end
u:erase()
wesnoth.units.to_map(t,loc)
wesnoth.wml_actions.redraw({})
u = wesnoth.units.get(loc)

local loc = u.loc
local loc2 = {x2,y2}
local w = wml.get_child(wesnoth.current.event_context,"weapon")
local w2 = wml.get_child(wesnoth.current.event_context,"second_weapon")
std_print("firing attack end")
wesnoth.game_events.fire("attack end", loc, loc2, {{"first",w},{"second",w2}})

if e.valid ~= nil and e.hitpoints <= 0 then
    std_print("firing last breath")
    wesnoth.game_events.fire("last breath", loc2, loc, {{"first",w2},{"second",w}}) --inverted
    --TODO only if enemy doesn't evade somehow?
    u.variables.battle_xp = 0 --doesn't get battle XP if it gets kill XP
    animator:add(e, "death", "hit",{with_bars = false, primary = e.attacks[w2.name], secondary = u.attacks[w.name]}) --inverted TODO unsure!
    animator:run()
    animator:clear()
    wesnoth.wml_actions.redraw({})
    e_level = e.level
    e_id= e.id
    std_print("firing die")
    wesnoth.game_events.fire("die", loc2, loc, {{"first",w2},{"second",w}}) --inverted
    wesnoth.wml_actions.kill({ id = e_id, animate = false, fire_event = false})
    if e_level == 0 then
        u.experience = wesnoth.game_config.kill_experience * 0.5
        u:advance(true,true)
    else
        u.experience = u.experience +(e_level * wesnoth.game_config.kill_experience)
        u:advance(true,true)
    end
    -- TODO deosn't work for berserker (not intended, just a warning for future me), untested with plague
end


local enemies = wesnoth.units.find_on_map({{"filter_side",{{"enemy_of",{side=u.side}}}},{"filter_location",{{"not",{x=x2,y=y2}},{"filter_adjacent_location",{x=u.x,y=u.y}}}}})
local valid_targets = {}
for _, e in pairs(enemies) do
    local dir = wesnoth.map.get_relative_dir(u.loc, e.loc)
    local loc = wesnoth.map.get_direction(u.loc, dir, 2)
    if u:movement_on(wesnoth.map.get(loc).terrain) ~= 99 and wesnoth.units.get(loc) == nil then
        table.insert(valid_targets, e)
    end
end
e = valid_targets[math.random(#valid_targets)] or nil
if e ~= nil then
    u.facing=wesnoth.map.get_relative_dir({u.x, u.y},{e.x, e.y})
    e.facing=wesnoth.map.get_relative_dir({e.x, e.y},{u.x, u.y})

    local loc = u.loc
    local loc2 = e.loc
    local attacker = u
    local defender = e

    local _, _, attacker_stats, defender_stats = wesnoth.simulate_combat(u,e)
    local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
    local attacking_weapon_index = 1
    while e.attacks[attacking_weapon_index] ~= nil do
        if wml.get_child(wesnoth.current.event_context,"weapon").name == u.attacks[attacking_weapon_index].name then
            _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(u, attacking_weapon_index, e)
            _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
            break
        end
        attacking_weapon_index= attacking_weapon_index + 1
    end
    local w_index = attacker_stats.number
    local w2_index = defender_stats.number
    --gui.show_inspector({})
    local w = u.attacks[w_index]
    local w2_cfg=nil
    if defender_stats.name ~= nil then
        w2 = defender.attacks[defender_stats.name]
        w2_cfg = w2.__cfg
    end
    local w2 = e.attacks[w2_index]

    if attacker.variables.danse_macabre_jumps_left > 0 then
        attacker.variables.danse_macabre_jumps_left = attacker.variables.danse_macabre_jumps_left - 1
        attacker.variables.strikes_done = attacker.variables.strikes_done + 1
        local strikes = attacker.variables.strikes_done
        std_print("firing attack")
        wesnoth.game_events.fire("attack", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},attackers_attack_fired = true})
        std_print("hit/miss?")
        if mathx.random() < (attacker_stats.chance_to_hit/100) then

            local damage_inflicted = math.floor(attacker_stats.damage)

            local drain = 0
            if attacker_stats.drains then
                drain = math.floor(math.min((math.min(damage_inflicted,defender.hitpoints) * attacker_stats.drain_percent / 100) + attacker_stats.drain_constant, math.max(attacker.max_hitpoints - attacker.hitpoints,0)))
            end
            local text = ""
            if drain ~= 0 then
                text = text..drain
            end

            local text2 =  damage_inflicted.."\n"
            local add_tab = false
			local gender = defender.gender
            local statuses = {}

			local function set_status(ability, name, male_string, female_string, sound)
				if not attacker_stats[ability] or defender.status[name] then return end
				if gender == "female" then
					text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
				else
					text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
				end

                statuses[#statuses+1]=name
				add_tab = true

				if sound then -- for unhealable, that has no sound
					wesnoth.audio.play(sound)
				end --TODO should I do this???
			end
            if not defender.status.unpoisonable then
				set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
			end
			set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
			set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
			if add_tab then
				text2 = string.format("%s%s", "     ", text2)
			end

            animator:add(attacker, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}, value={damage_inflicted,strikes}})
            animator:add(defender, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}, value={damage_inflicted,1}})
            animator:run()
            animator:clear()
            wesnoth.wml_actions.redraw({})
            for i=1, #statuses do
                defender.status[statuses[i]] = true
            end
            attacker.hitpoints=(attacker.hitpoints + drain)
            defender.hitpoints=(defender.hitpoints - attacker_stats.damage)
            std_print("firing attacker_hits")
            wesnoth.game_events.fire("attacker_hits", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted,next_attack=false})
            std_print("deal damage")
            -- wesnoth.wml_actions.inspect({})
        else

            --Miss animation
            animator:add(u, "attack", "miss",{with_bars = true, primary = w, secondary = w2,value = {0,strikes}})
            animator:add(e, "defend", "miss",{with_bars = true, primary = w2, secondary = w, value = {0,1}}) --inverted TODO unsure! --value = {0,1} --no damage, first defenders strike
            animator:run()
            animator:clear()
            wesnoth.wml_actions.redraw({})
            std_print("firing attacker misses")
            wesnoth.game_events.fire("attacker_misses", loc, loc2,{{"first",w.__cfg},{"second",w2_cfg},next_attack=false})
        end
        std_print("firing next_attack")
        wesnoth.game_events.fire("next_attack", loc, loc2, {{"first",w.__cfg},{"second",w2_cfg},next_attack=true})
    else
        --u.variables.danse_macabre_jumps_left = 0 --should be on 0 already :D
        u.experience = u.experience + u.variables.battle_xp
        u:advance(true,true)
    end
else
    u.variables.danse_macabre_jumps_left = 0
    u.experience = u.experience + u.variables.battle_xp
    u:advance(true,true)
end
::skip::
>>
        [/lua]
    [/event]






    [event]
        name=attacker hits
        first_time_only=no
        [filter_attack]
            special_id=armor_breaking
        [/filter_attack]
        [filter_second]
            [not] #TODO in case of need shift this list
                trait="undead"
            [/not]
        [/filter_second]
        [object]
            id=broken_armor_object
            take_only_once=no
            silent=yes
            duration=turn
            [filter]
                x,y=$x2,$y2
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_BROKEN_ARMOR}
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=armor_breaking
        [/filter_second_attack]
        [filter]
            [not] #TODO in case of need shift this list
                trait="undead"
            [/not]
        [/filter]
        [object]
            id=broken_armor_object
            take_only_once=no
            silent=yes
            duration=turn
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_BROKEN_ARMOR}
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=attacker misses
        first_time_only=no
        [filter_second_attack]
            special_id=counter
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        [filter_attack]
            special_id=counter
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender misses
        first_time_only=no
        [filter_attack]
            special_id=counter
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=counter
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=counter
        [/filter_attack]
        [filter]
        [/filter]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_second_attack]
            special_id=counter
        [/filter_second_attack]
        [filter_second]
        [/filter_second]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.counter = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        id=knockback_event
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
            {FIRE_NO_ATTACK_END_EVENT_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=knockback
        [/filter_attack]
        [filter]
        [/filter]
        [filter_second]
            [not]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
            [/not]
        [/filter_second]
        [if]
            [variable]
                name=second_unit.hitpoints
                greater_than=0
            [/variable]
            [and]
                [variable]
                    name=unit.hitpoints
                    greater_than=0
                [/variable]
            [/and]
            [then]
                [store_locations]
                    [not]
                        [filter]
                        [/filter]
                    [/not]
                    #terrain=!,Q*,Q*^*,*^Q*,Mv,X*,X*^*,*^X*,_*^*,*^_*
                    [filter_adjacent_location]
                        x,y=$x2,$y2
                        adjacent="$(relative_dir(loc($x2,$y2), loc($x1,$y1)))"
                    [/filter_adjacent_location]
                    variable=knockback_target_hex
                [/store_locations]
                [store_locations]
                    [not]
                        [filter]
                        [/filter]
                    [/not]
                    #terrain=!,Q*,Q*^*,*^Q*,Mv,X*,X*^*,*^X*,_*^*,*^_*
                    [not]
                        [filter_adjacent_location]
                            x,y=$x2,$y2
                            adjacent="$(relative_dir(loc($x2,$y2), loc($x1,$y1)))"
                        [/filter_adjacent_location]
                    [/not]
                    [not]
                        [filter_adjacent_location]
                            x,y=$x1,$y1
                        [/filter_adjacent_location]
                    [/not]
                    [filter_adjacent_location]
                        x,y=$x2,$y2
                    [/filter_adjacent_location]
                    mode=append
                    variable=knockback_target_hex
                [/store_locations]
                [lua]
                    code=<<
local u = wesnoth.units.get(wml.variables["second_unit.id"])
local t = wml.variables["knockback_target_hex[0].terrain"]
if t then
    local move_cost = wesnoth.units.movement_on(u, t)
    if(move_cost > wml.variables["second_unit.max_moves"]) then
        wml.variables["knockback_target_hex"] = nil
    end
end
>>
                [/lua]
                [if]
                    [variable]
                        name=knockback_target_hex.length
                        greater_than=0
                    [/variable]
                    [then]
                        [lua] #TODO
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = defender
local second_unit = attacker
local unit_cfg = defender.__cfg
local second_unit_cfg = attacker.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
    local retreat=wesnoth.named_tuple({wml.variables["knockback_target_hex"].x, wml.variables["knockback_target_hex"].y}, {'x', 'y'})
    local loc = unit.loc
    attacker.experience = attacker.experience + defender_cfg.level
    defender.experience = defender.experience + attacker_cfg.level
    attacker:advance(true,true)
    defender:advance(true,true)
    attacker.experience = attacker.experience - defender_cfg.level --attacker isn't moved, so it will get xp
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) and (wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc)) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
>>
                        [/lua]
                        [if]
                            [have_unit]
                                x,y=$knockback_target_hex.x,$knockback_target_hex.y
                            [/have_unit]
                            [then]
                                [sound]
                                    name=fist.ogg
                                [/sound]
                                [store_unit]
                                    [filter]
                                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                                    [/filter]
                                    kill=yes
                                    variable=knockbacked
                                [/store_unit]
                                [unstore_unit]
                                    variable=knockbacked
                                    text= _ "knockback"
                                    {COLOR_HARM}
                                    advance=true
                                [/unstore_unit]
                                {CLEAR_VARIABLE knockbacked}
                            [/then]
                        [/if]
                    [/then]
                [/if]
                {CLEAR_VARIABLE knockback_target_hex}
            [/then]
        [/if]
    [/event]
    [event]
        name = enter_hex
        first_time_only = no
        [filter]
            [filter_adjacent]
                [has_attack]
                    special_id = intercept
                [/has_attack]
                is_enemy = yes
            [/filter_adjacent]
        [/filter]
        [lua]
            code=<<
local x1 = wesnoth.current.event_context.x1
local y1 = wesnoth.current.event_context.y1
local u = wesnoth.units.get(x1,y1)
local animator = wesnoth.units.create_animator()
local enemies = wesnoth.units.find_on_map({{"filter_adjacent",{id=u.id, is_enemy = true}},{"has_attack",{special_id = "intercept"}}})
for _,e in ipairs(enemies) do
    local i = 1
    while e.attacks[i] ~= nil do
        local weapon = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if weapon ~= nil then
            break
        end
        i = i + 1
    end
    local attacking_weapon=i
    std_print("attacking with",i)
    local attacker = e
    local defender = u
    attacker.facing=wesnoth.map.get_relative_dir(attacker.x, attacker.y, defender.x, defender.y)
    defender.facing=wesnoth.map.get_relative_dir(defender.x, defender.y,attacker.x, attacker.y)
    -- defender.attacks[attacker.variables.defenders_weapon] = {movement_used=100000,attacks_used=1}
    local loc = attacker.loc
    local loc2 = defender.loc
    local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon, defender)-- -- THIS IF I'd want defensive specials of weapon to apply, but enemy doesn't fight back, so no specials take effect
    local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
    local w = attacker.attacks[attacking_weapon]
    local w2 = nil
    local w2_cfg=nil
    if defender_stats.name ~= nil then
        w2 = defender.attacks[defender_stats.name]
        w2_cfg = w2.__cfg
    end
    std_print("hit/miss?")
    if mathx.random() < (attacker_stats.chance_to_hit/100) then

        local damage_inflicted = math.floor(attacker_stats.damage)

        local drain = 0
        if attacker_stats.drains then
            drain = math.floor(math.min((math.min(damage_inflicted,defender.hitpoints) * attacker_stats.drain_percent / 100) + attacker_stats.drain_constant, math.max(attacker.max_hitpoints - attacker.hitpoints,0)))
        end
        local text = ""
        if drain ~= 0 then
            text = text..drain
        end

        local text2 =  damage_inflicted.."\n"
        local add_tab = false
        local gender = defender.gender
        local statuses = {}

        local function set_status(ability, name, male_string, female_string, sound)
            if not attacker_stats[ability] or defender.status[name] then return end
            if gender == "female" then
                text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
            else
                text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
            end

            statuses[#statuses+1]=name
            add_tab = true

            if sound then -- for unhealable, that has no sound
                wesnoth.audio.play(sound)
            end --TODO should I do this???
        end
        if not defender.status.unpoisonable then
            set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
        end
        set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
        set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
        if add_tab then
            text2 = string.format("%s%s", "     ", text2)
        end

        animator:add(attacker, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}})
        animator:add(defender, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}})
        animator:run()
        animator:clear()
        for i=1, #statuses do
            defender.status[statuses[i]] = true
        end
        attacker.hitpoints=(attacker.hitpoints + drain)
        defender.hitpoints=(defender.hitpoints - attacker_stats.damage)
        wesnoth.game_events.fire("attacker_hits", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted})
        std_print("deal damage")
        -- wesnoth.wml_actions.inspect({})
        if defender.valid == nil or defender.hitpoints <= 0 then
            wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
            if defender.valid == nil then
                std_print("defender doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code")
                break
            end
            wesnoth.game_events.fire("last breath", loc2, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            animator:add(defender, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted TODO unsure!
            animator:run()
            animator:clear()
            defender_level = defender.level
            defender_id= defender.id
            wesnoth.game_events.fire("die", defender.loc, attacker.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            wesnoth.wml_actions.kill({ id = defender_id, animate = false, fire_event = false})
            if defender_level == 0 then
                attacker.experience = wesnoth.game_config.kill_experience * 0.5
                attacker:advance(true,true)
            else
                attacker.experience = attacker.experience +(defender_level * wesnoth.game_config.kill_experience)
                attacker:advance(true,true)
            end
            std_print("fight should end")
            -- "breaks" endurance (not enemies, no problem), defender fights util he gets attacked by the original enemy (it should continue even after it's hit by original enemy probably)
            -- raider doesn't work, ranged retalaition weapon, naga guardian, saurian ...
            -- at end set all combat variables to nil
            -- TODO deosn't work for berserker (not intended, just a warning for future me), untested with plague
            break
        end
    else
        animator:add(attacker, "attack", "miss",{with_bars = true, primary = w, secondary = w2})
        animator:add(defender, "defend", "miss",{with_bars = true, primary = w2, secondary = w}) --inverted TODO unsure!
        animator:run()
        animator:clear()
        wesnoth.game_events.fire("attacker_misses", attacker.loc, defender.loc, {{"first",w.__cfg},{"second",w2_cfg}})

    end
end
>>
        [/lua]
    [/event]
    [event]
        name=exit_hex
        id=exploitation_event
        first_time_only = no
        [filter]
            [filter_adjacent]
                [has_attack]
                    special_id = exploitation
                [/has_attack]
                is_enemy = yes
            [/filter_adjacent]
        [/filter]
        [store_unit]
            [filter]
                id=$unit.id
            [/filter]
            variable = defender
        [/store_unit]
        [store_unit]
            [filter]
                [has_attack]
                    special_id = exploitation
                [/has_attack]
                [filter_adjacent]
                    x,y=$x1,$y1
                    is_enemy = yes
                [/filter_adjacent]
                [not]
                    [filter_location]
                        [filter_adjacent_location]
                            x,y=$x2,$y2
                        [/filter_adjacent_location]
                    [/filter_location]
                [/not]
            [/filter]
            variable = exploitation_units
        [/store_unit]
        [foreach]
            array=exploitation_units
            variable=current_exploitation_unit
            [do]
                [lua]
                    code=<<
local attacker= wesnoth.units.get(wml.variables["current_exploitation_unit[0].id"])
local defender= wesnoth.units.get(wml.variables["defender[0].id"])
local attacking_weapon_index = 0
local i = 0
while wml.variables["current_exploitation_unit[0].attack["..i.."]"] ~= nil do
    local weapon = wml.find_child(wml.variables["current_exploitation_unit[0].attack["..i.."]"],"specials",{{"dummy",{id="exploitation"}}})
    if weapon ~= nil then
        attacking_weapon_index = i + 1
        break
    end
    i = i + 1
end
defender.attacks[(#defender.attacks + 1)] = {}
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index, defender, #defender.attacks)
defender.attacks[#defender.attacks] = nil
for key, value in pairs(attacker_stats) do
    wml.variables["attacker_stats."..key] = tonumber(value) or tostring(value)
end
for key, value in pairs(defender_stats) do
    wml.variables["defender_stats."..key] = tonumber(value) or tostring(value)
end>>
                [/lua]
                [set_variable]
                    name = hit_roll
                    rand = 1..100
                [/set_variable]
                [if]
                    [variable]
                        name = attacker_stats.chance_to_hit
                        greater_than = $hit_roll
                    [/variable]
                    [then]
                        [lua]
                            code=<<
local v=wml.variables
local animation = wesnoth.units.create_animator()
local attacker= wesnoth.units.get(v["current_exploitation_unit[0].id"])
local defender= wesnoth.units.get(v["defender[0].id"])
local facing = {x = defender.x, y = defender.y}
local unit = attacker
local facing_loc = wesnoth.map.find(facing)[1]
local dir = wesnoth.map.get_relative_dir(unit.x, unit.y, facing_loc[1], facing_loc[2])
unit.facing = dir
facing = wesnoth.map.get_direction(unit.x, unit.y, dir)
animation:add(attacker, "attack", "hit",{with_bars = true, primary = attacker.attacks[v["attacker_stats.name"]], secondary = attacker.attacks[v["attacker_stats.name"]], target = facing})
animation:add(defender, "defend", "hit",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]], text = v["attacker_stats.damage"],color={255,0,0}})
animation:run()
animation:clear()
defender.hitpoints=(defender.hitpoints - v["attacker_stats.damage"])
if defender.hitpoints <= 0 then
    animation:add(defender, "die", "hit",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]],text = v["attacker_stats.damage"],color={255,0,0}})
--#TODO KILL THE ENEMY IF DROPS UNDER 0
end
animation:run() --???
animation:clear()
>>
                        [/lua]#TODO ANIMATE THE HP BAR GOING DOWN
                        #  [harm_unit]#TODO doesn't look good
                        #      [filter]
                        #          x,y=$x1,$y1
                        #      [/filter]
                        #      [filter_second]
                        #          id=$current_exploitation_unit.id
                        #      [/filter_second]
                        #      amount = $attacker_stats.damage
                        #      kill = yes
                        #      experience = kill
                        #      fire_event = yes
                        #      animate = yes
                        #      [primary_attack]
                        #          special_id = exploitation
                        #      [/primary_attack]
                        #  [/harm_unit]
                    [/then]
                    [else]
                        [lua]
                            code=<<
local v=wml.variables
local animation = wesnoth.units.create_animator()
local attacker= wesnoth.units.get(v["current_exploitation_unit[0].id"])
local defender= wesnoth.units.get(v["defender[0].id"])
local facing = {x = defender.x, y = defender.y}
local unit = attacker
local facing_loc = wesnoth.map.find(facing)[1]
local dir = wesnoth.map.get_relative_dir(unit.x, unit.y, facing_loc[1], facing_loc[2])
unit.facing = dir
facing = wesnoth.map.get_direction(unit.x, unit.y, dir)
animation:add(attacker, "attack", "miss",{with_bars = true, primary = attacker.attacks[v["attacker_stats.name"]], secondary = attacker.attacks[v["attacker_stats.name"]], target = facing})
animation:add(defender, "defend", "miss",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]]})
animation:run()
animation:clear()
                            >>
                        [/lua]
                    [/else]
                [/if]
            [/do]
        [/foreach]
        #  {CLEAR_VARIABLE exploitation_units,defender,attacker_stats,defender_stats,hit_roll}
    [/event]
    [event]
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=zoc_stun, all_round
        [/filter_attack]
        [filter_condition]
        [/filter_condition]
        [modify_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x1,$y1
                    is_enemy=yes
                [/filter_adjacent]
                [not]
                    status=stunned
                [/not]
            [/filter]
            [object]
                silent=yes
                duration=turn end
                [effect]
                    apply_to=image_mod
                    replace="CS(50,50,0)"
                [/effect]
                [effect]
                    apply_to=zoc
                    value=no
                [/effect]
                [effect]
                    apply_to=movement
                    increase=-50%
                [/effect]
                [effect]
                    apply_to=status
                    add=stunned
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        name=side turn end
        first_time_only=no
        [modify_unit]
            [filter]
                side=$side_number
                status=stunned
            [/filter]
            [status]
                stunned=no
            [/status]
        [/modify_unit]
    [/event]
#enddef

#define SPEAKING TAGS MESSAGE
    [narration]
        {TAGS}
        message = {MESSAGE}
    [/narration]
#enddef

#define NARRATION TAGS MESSAGE
    [narration]
        {TAGS}
        speaker_unit = no
        message = {MESSAGE}
    [/narration]
#enddef

#define DELAY TIME ACCELERATE
    [delay]
        time={TIME}
        accelerate={ACCELERATE}
    [/delay]
#enddef

#define AMLA_LEVEL_INCREASE
#doesnt work
    [event]
        name=post_advance
        id=amla_level_increase_event
        first_time_only=no
#         [filter_condition]
#             {AWW_TEST_WAS_AMLA}
#         [/filter_condition]
#cant find
        [modify_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object] ###############################################MAYBE DOESN'T work becouse of ID, which shouldn't be there
                id=amla_level_increase
                duration=forever
                silent=yes
                [effect]
                    apply_to=level
                    increase=1
                [/effect]
            [/object]
#             [set_variable]
#                 name=aww_level_count
#                 value=$unit.level
#             [/set_variable]
#TODO number of AMLAS past, then move into AMLA
        [/modify_unit]
    [/event]
#enddef

##############Scenario 1 MACROS####################

#define BUILD_CAMP UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Cyk
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_CAMP_KEEP UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Kyt
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_TENT_VILLAGE UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Vct
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_TORCH_UP UNIT X Y TIME_X TIME_Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    {PLACE_TORCHES "{X}" "$({Y}-1)"}
    [sound]
        name=torch.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define PLACE_TORCHES X Y
    {VARIABLE torch.x {X}}
    {VARIABLE torch.y {Y}}
    {VARIABLE torch_array ""}
    [lua]
        code=<<
local i = 0
if tostring(wml.variables["torch.x"]):find(",") then
    for num in wml.variables["torch.x"]:gmatch("[^,%s]+") do
        wml.variables["torch_array["..i.."].x"] = tonumber(num)
        i = i + 1
    end
else
    wml.variables["torch_array[0].x"] = tonumber(wml.variables["torch.x"])
end
        >>
    [/lua]
    [lua]
        code=<<
local i = 0
if tostring(wml.variables["torch.y"]):find(",") then
    for num in wml.variables["torch.y"]:gmatch("[^,%s]+") do
        wml.variables["torch_array["..i.."].y"] = tonumber(num)
        i = i + 1
    end
else
    wml.variables["torch_array[0].y"] = tonumber(wml.variables["torch.y"])
end
        >>
    [/lua]
    [foreach]
        array=torch_array
        [do]
            [if]
                [have_location]
                    x,y=$torch_array[$i].x,$torch_array[$i].y
                    terrain=X*^*
                    include_borders=yes
                [/have_location]
                [then]
                    [time_area]
                        id="torch_$torch_array[$i].x|_$torch_array[$i].y"
                        x,y=$torch_array[$i].x,$torch_array[$i].y
                        include_borders=yes
                        [or]
                            [filter_adjacent_location]
                                x,y=$torch_array[$i].x,$torch_array[$i].y
                                adjacent=ne,n,nw
                                include_borders=yes
                            [/filter_adjacent_location]
                            [not]
                                terrain=X*^*
                            [/not]
                        [/or]
                        [time]
                            name= _ "Torchlight"
                            image=time/schedule-indoors-dark.png
                            red=0
                            green=-20
                            blue=-35
                        [/time]
                    [/time_area]
                [/then]
                [else]
                    [time_area]
                        id="torch_$torch_array[$i].x|_$torch_array[$i].y"
                        x,y=$torch_array[$i].x,$torch_array[$i].y
                        include_borders=yes
                        [or]
                            [filter_adjacent_location]
                                x,y=$torch_array[$i].x,$torch_array[$i].y
                                adjacent=se,s,sw
                                include_borders=yes
                            [/filter_adjacent_location]
                            [not]
                                terrain=X*^*
                            [/not]
                        [/or]
                        [time]
                            name= _ "Torchlight"
                            image=time/schedule-indoors-dark.png
                            red=0
                            green=-20
                            blue=-35
                        [/time]
                    [/time_area]
                [/else]
            [/if]
            [terrain]
                x,y=$torch_array[$i].x,$torch_array[$i].y
                terrain=^Efs
                layer=overlay
                include_borders=yes
            [/terrain]
            [redraw]
                side=1
            [/redraw]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE torch_array}
    {CLEAR_VARIABLE torch}
#enddef
#define RANDOM_AROUND_PLACEMENT X Y
    [store_locations]
        [filter_adjacent_location]
            x,y={X},{Y}
        [/filter_adjacent_location]
        [not]
            [filter]
            [/filter]
            [filter_location]
                terrain=X*^*
            [/filter_location]
        [/not]
        variable=adjecent_hexes
    [/store_locations]
    {VARIABLE_OP i rand "0..$($adjecent_hexes.length - 1)"}
#enddef
#define VILLAGE_RAID X Y ID
    [event]
        id={ID}
        name=moveto
        first_time_only=yes
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        [scroll_to]
            x,y={X},{Y}
        [/scroll_to]
        [terrain]
            x,y={X},{Y}
            terrain=Gd^Vhr
        [/terrain]
        [sound]
            name=torch.ogg
        [/sound]
        [redraw]
            side=1
        [/redraw]
        [delay]
            time=500
            accelerate=yes
        [/delay]
        {VARIABLE {ID} 1}
        {VARIABLE_OP farmers rand "1..100"}
        {VARIABLE_OP type_of_farmer rand "1..100"}
        {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 11 13 15}"}
        {RANDOM_AROUND_PLACEMENT {X} {Y} }
        [if]
            [variable]
                name=type_of_farmer
                less_than_equal_to=50
            [/variable]
            [then]
                [move_unit_fake]
                    type=BfBH Peasant
                    x={X},$adjecent_hexes[$i].x
                    y={Y},$adjecent_hexes[$i].y
                    side=2
                [/move_unit_fake]
                [unit]
                    type="BfBH Peasant"
                    side=2
                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                    experience=$units_experience
                    placement=map
                    passable=yes
                [/unit]
            [/then]
            [else]
                [move_unit_fake]
                    type=BfBH Woodsman
                    x={X},$adjecent_hexes[$i].x
                    y={Y},$adjecent_hexes[$i].y
                    side=2
                [/move_unit_fake]
                [unit]
                    type="BfBH Woodsman"
                    side=2
                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                    experience=$units_experience
                    placement=map
                    passable=yes
                [/unit]
            [/else]
        [/if]
        [if]
            [variable]
                name=farmers
                less_than_equal_to={ON_DIFFICULTY 30 50 70}
            [/variable]
            [then]
                {VARIABLE_OP type_of_farmer rand "1..100"}
                {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 11 13 15}"}
                {RANDOM_AROUND_PLACEMENT {X} {Y} }
                [if]
                    [variable]
                        name=type_of_farmer
                        less_than_equal_to=50
                    [/variable]
                    [then]
                        [move_unit_fake]
                            type=BfBH Peasant
                            x={X},$adjecent_hexes[$i].x
                            y={Y},$adjecent_hexes[$i].y
                            side=2
                        [/move_unit_fake]
                        [unit]
                            type="BfBH Peasant"
                            side=2
                            x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                            experience=$units_experience
                            placement=map
                            passable=yes
                        [/unit]
                    [/then]
                    [else]
                        [move_unit_fake]
                            type=BfBH Woodsman
                            x={X},$adjecent_hexes[$i].x
                            y={Y},$adjecent_hexes[$i].y
                            side=2
                        [/move_unit_fake]
                        [unit]
                            type="BfBH Woodsman"
                            side=2
                            x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                            experience=$units_experience
                            placement=map
                            passable=yes
                        [/unit]
                    [/else]
                [/if]
                [if]
                    [variable]
                        name=farmers
                        less_than_equal_to={ON_DIFFICULTY 0 10 20}
                    [/variable]
                    [then]
                        {VARIABLE_OP type_of_farmer rand "1..100"}
                        {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 9 10 11}"}
                        {RANDOM_AROUND_PLACEMENT {X} {Y} }
                        [if]
                            [variable]
                                name=type_of_farmer
                                less_than_equal_to=50
                            [/variable]
                            [then]
                                [move_unit_fake]
                                    type=BfBH Peasant
                                    x={X},$adjecent_hexes[$i].x
                                    y={Y},$adjecent_hexes[$i].y
                                    side=2
                                [/move_unit_fake]
                                [unit]
                                    type="BfBH Peasant"
                                    side=2
                                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                                    experience=$units_experience
                                    placement=map
                                    passable=yes
                                [/unit]
                            [/then]
                            [else]
                                [move_unit_fake]
                                    type=BfBH Ruffian
                                    x={X},$adjecent_hexes[$i].x
                                    y={Y},$adjecent_hexes[$i].y
                                    side=2
                                [/move_unit_fake]
                                [unit]
                                    type="BfBH Ruffian"
                                    side=2
                                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                                    experience=$units_experience
                                    placement=map
                                    passable=yes
                                [/unit]
                            [/else]
                        [/if]
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
#enddef
#define VILLAGERS_FLEEING X Y ID
    [if]
        [variable]
            name={ID}
            greater_than=0
        [/variable]
        [then]
        [/then]
        [else]
            {VARIABLE_OP type_of_farmer rand "1..100"}
            {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 9 10 11}"}
            [if]
                [variable]
                    name=type_of_farmer
                    less_than_equal_to=50
                [/variable]
                [then]
                    [unit]
                        type="BfBH Peasant"
                        side=2
                        x,y={X},{Y}
                        animate=yes
                        placement=map
                        passable=yes
                        experience=$units_experience
                        role=villager_fleeing
                    [/unit]
                [/then]
                [else]
                    [unit]
                        type="BfBH Woodsman"
                        side=2
                        x,y={X},{Y}
                        animate=yes
                        placement=map
                        passable=yes
                        experience=$units_experience
                        role=villager_fleeing
                    [/unit]
                [/else]
            [/if]
            [capture_village]
                x,y={X},{Y}
            [/capture_village]
            [if]
                [variable]
                    name=villager_talked
                    less_than_equal_to=0
                [/variable]
                [then]
                    [store_unit]
                        [filter]
                            role=villager_fleeing
                        [/filter]
                    [/store_unit]
                    {SPEAKING (id=$unit.id) "Sir Rillon was defeated, it's not safe in there anymore!"}
                    [set_variable]
                        name=villager_talked
                        value=1
                    [/set_variable]
                [/then]
            [/if]
        [/else]
    [/if]
#enddef
#define VILLAGE_REPLACE X Y ID
    [if]
        [variable]
            name={ID}
            greater_than=0
        [/variable]
        [then]
            [terrain]
                x,y={X},{Y}
                terrain=Gd^Vhr
            [/terrain]
        [/then]
    [/if]
#enddef
#define SONG NAME
    [music]
        name={NAME}
        ms_before=12000
        append=yes
        immediate=no
        play_once=yes
    [/music]
#enddef
#define UNIVERSAL_RECALL SIDE X Y RECALL_UNIT NEW_UNIT MAX_XP
    [if]
        [have_unit]
            x,y=recall,recall
            side={SIDE}
            type={RECALL_UNIT}
            search_recall_list=yes
        [/have_unit]
        [then]
            [recall]
                side={SIDE}
                type={RECALL_UNIT}
                x,y={X},{Y}
            [/recall]
        [/then]
        [else]
            {VARIABLE_OP units_experience rand "0..{MAX_XP}"}
            [unit]
                type={NEW_UNIT}
                side={SIDE}
                animate=yes
                x,y={X},{Y}
                experience=$units_experience
            [/unit]
        [/else]
    [/if]
#enddef
#define THREE_TRAITS_LOYAL_UNIT SIDE UNIT_TYPE X Y
    [unit]
        side={SIDE}
        type={UNIT_TYPE}
        x={X}
        y={Y}
        generate_name=yes
        random_traits=yes
        random_gender=yes
        role=needs_loyal_trait
    [/unit]
    [modify_unit]
        [filter]
            role=needs_loyal_trait
        [/filter]
        role=
        {TRAIT_LOYAL}
    [/modify_unit]
#enddef
#define ABILITY_EQUIPPED
    [dummy]
        id=equipped
        name= _ "equipped"
        female_name= _ "female^equipped"
        description=_ "This unit has equipped item and it can't get another one."
        special_note=_ "This unit has equipped item and it can't get another one."
    [/dummy]
#enddef
#define ABILITY_UNDYING
    [resurrection]
        id=undying
        name= _ "undying"
        female_name= _ "female^undying"
        description=_ "Death holds no permanence for these ancient bones. When destroyed, the dark magic binding this skeleton together may persist, giving it a 30% chance to reconstruct itself with a third of its vitality after half a day has passed. Patient in death as in unlife, the cursed remains will rise again from the empty battlefield once their destroyers have moved on, ready to serve their dark purpose once more."
        special_note=_ "30% chance to revive with 33% HP on empty tile, 12 hours after death."#TODO
        chance=33.333
        hitpoints=33.333
        min_turns=2
        max_turns=4
        instant_damage="0/0"
        buff=0
        spawn_radius=0
    [/resurrection]
#enddef
#define ABILITY_VENGEFUL
    [resurrection]
        id=vengeful
        name= _ "vengeful"
        female_name= _ "female^vengeful"
        description=_ "#TODO"
        special_note=_ "#TODO"
        chance=35
        hitpoints=35
        min_turns=2
        max_turns=4
        instant_damage="0/7"
        buff=3
        spawn_radius=5
        children=vengeful_2
    [/resurrection]
    [attacks]
        id=vengeful_2
        add=1
        affect_self=yes
        [filter_self]
            formula="(self.wml_vars.resurrection_buff > 0)"
        [/filter_self]
    [/attacks]
#enddef
#define ABILITY_DEATHLESS
    [resurrection]
        id=deathless
        name= _ "deathless"
        female_name= _ "female^deathless"
        description=_ "#TODO"
        special_note=_ "#TODO"
        chance=35 #TODO 40%?
        hitpoints=50
        min_turns=2
        max_turns=4
        instant_damage="0/7"
        buff=3
        spawn_radius=5
        children=deathless_2,deathless_3
    [/resurrection]
    [attacks]
        id=deathless_2
        add=1
        affect_self=yes
        [filter_self]
            formula="(self.wml_vars.resurrection_buff > 0)"
        [/filter_self]
    [/attacks]
    [resistance]
        id=deathless_3
        add=40
        max_value=100
        affect_self=yes
        [filter_self]
            formula="(self.wml_vars.resurrection_buff > 0)"
        [/filter_self]
    [/resistance]
#enddef
#define ABILITY_TRAP
    [trap] #TODO different (pierce 1 damage, poison) in swamps
        id=trap #TODO renama in case more [trap] abilities #TODO make it visible for enemy only if unit with unhides or trap disarm is nearby
        name= _ "trap"
        female_name= _ "female^trap"
        description=_ "When not attacking, this unit can set a concealed bladed trap on solid ground. Once triggered, the mechanism unleashes razor-sharp steel that deals 10 damage, causes bleeding, and locks the victim in place. Cannot be placed in water or villages."
        special_note=_ "When not attacking, sets a concealed trap that deals 10 blade damage, causes bleeding, and immobilizes enemies (not in water/villages)."
    [/trap]
#enddef
#define ABILITY_STONECLOAK
    [hides]
        id=stonecloak
        name= _ "stonecloak"
        female_name= _ "female^stonecloak"
        description= _ "The dwarven scout melds their form with surrounding stone, becoming nearly invisible in mountainous terrain and underground environments. This camouflage is perfect when stationary and highly effective even while moving."
        special_note= _ "This unit is invisible in stony terrain."
        affect_self=yes
        [filter]
            [filter_location]
                terrain=H*^*,M*^*,Uu*^*,Uh*^*,*^Dr*
            [/filter_location]
            {UNHIDE_FILTER}
        [/filter]
    [/hides]
#enddef
#define ABILITY_LIVING_SHIELD
    [dummy]
        id=living_shield
        name= _ "living shield"
        female_name= _ "female^living shield"
        description= _ "Driven by a mix of fanatical loyalty and primal fear, this unit instinctively throws itself in harm's way. When an enemy attacks an allied unit adjacent to this one, this expendable warrior will intercept the blow, taking the full brunt of the assault upon its own flesh."
        special_note=_ "This unit can intercept attacks meant for adjacent allies. When an enemy attacks an allied unit adjacent to this one, this unit will take the attack instead."
    [/dummy]
#enddef
#define ABILITY_TREASURED
    [treasured]
        id=treasured
        name= _ "treasured"
        female_name= _ "female^treasured"
        description= _ "Heavy with riches and gold. Stories of its valuable cargo travel faster than the unit itself."
        special_note=_ "Heavy with riches and gold. Stories of its valuable cargo travel faster than the unit itself."
    [/treasured]
#enddef
#define ABILITY_REANIMATED
    [reanimated]
        id=reanimated
        name= _ "reanimated"
        female_name= _ "female^reanimated"
        description= _ "A nightmarish fusion of past and present, this corpse writhes with unnatural vitality. Fragments of its former self claw their way through decaying flesh, manifesting as twisted echoes of abilities long dead. Those who face it must contend not just with the monster before them, but with the grotesque remnants of the person it once was."
        special_note=_ "Twisted echoes of past life writhe within this rotting flesh, granting unpredictable and horrifying abilities."
    [/reanimated]
#enddef
#define ABILITY_FORAGE
    [regenerate]
        id=forage
        name=_"forage"
        female_name= _ "female^forage"
        description=_"A lifetime of wandering has taught them the secrets of the land's abundance. In nature's shelter and settled grounds alike, they find renewal among leaf and stone."
        special_note=_ "When on forest/fungus/farm/village tile, this unit heals 4 HP per turn."
        affect_self=yes
        value=4
        poison=slowed
        [filter_self]
            [filter_location]
                #forest, fungus, farm
                terrain=*^F*,*^Uf,*^Ufi,*^Gvs,*^Tf
            [/filter_location]
        [/filter_self]
    [/regenerate]
#enddef
#define ABILITY_RINGING_EARS
    [chance_to_hit]
        id=ringing_ears
        sub=10
    [/chance_to_hit]
#enddef
#define ABILITY_INKED
    [chance_to_hit]
        id=inked
        name= _ "inked"
        female_name= _ "female^inked"
        description=_ "This unit's accuracy is decreased by 10% until the end of the fight."
        special_note=_ "YOU REALLY SHOULDN'T SEE THIS! (unless special note's appearance has been changed, in that case please contact me :D )"
        sub=10
    [/chance_to_hit]
#enddef
#define ABILITY_BODYGUARD
    [resistance]
        id=bodyguard
        add=30
        max_value=100
        name= _ "bodyguard"
        female_name= _ "female^bodyguard"
        description=_ "#TODO"
        special_note=_ "#TODO"
        affect_self=yes
        active_on=defense
        [filter_self]
            [filter_adjacent]
                is_enemy=no
                ability=leadership
            [/filter_adjacent]
        [/filter_self]
    [/resistance]
#enddef
#define ABILITY_TENACITY
    [resistance]
        id=tenacity
        divide=2
        max_value=0
        [filter_base_value]
            greater_than=-100
            less_than=0
        [/filter_base_value]
        name= _ "tenacity"
        female_name= _ "female^tenacity"
        description=_ "An iron determination shields them where they would normally falter. Their perceived weaknesses become mere glancing blows when standing their ground."
        special_note=_ "This unit's vulnerabilities are halved when defending."
        affect_self=yes
        active_on=defense
    [/resistance]
#enddef
#define ABILITY_BOLD
    [resistance]
        id=bold
        divide=2
        max_value=0
        [filter_base_value]
            greater_than=-100
            less_than=0
        [/filter_base_value]
        name= _ "bold"
        female_name= _ "female^bold"
        description=_ "Where others hesitate, they strike with reckless courage. In the heat of their offensive, even their vulnerabilities seem to fade away."
        special_note=_ "This unit's vulnerabilities are halved when attacking."
        affect_self=yes
        active_on=offense
    [/resistance]
#enddef
#define ABILITY_CASTLE_GUARD
    [resistance]
        id=castle_guard
        name= _ "castle guard"
        female_name= _ "female^castle guard"
        description= _ "A born defender of walls and hearths, their commanding presence bolsters the resolve of fellow warriors who stand beside them in strongholds. Through their mastery of defensive warfare, they transform simple stone into stalwart shields."
        special_note= _ "While in a castle or village, this unit gives 10% physical protection increase to adjacent units in castle or village, up to the total of 50% protection."
        add=10
        max_value=50
        apply_to=blade,pierce,impact
        affect_self=no
        affect_allies=yes
        cumulative=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [filter_location]
                    terrain=C*^*,K*^*,*^V*
                [/filter_location]
            [/filter]
        [/affect_adjacent]
        [filter_base_value]
            less_than=50
        [/filter_base_value]
        [filter]
            [filter_location]
                terrain=C*^*,K*^*,*^V*
            [/filter_location]
        [/filter]
    [/resistance]
#enddef
#define WEAPON_SPECIAL_SKILLED
    [chance_to_hit]
        id=skilled
        name= _ "skilled"
        female_name= _ "female^skilled"
        description=_"A master of the warrior's craft, this unit's strikes ring true even in the most challenging conditions. Years of relentless training ensure their weapon finds its mark."
        special_note= _ "This unit's weapon always has a minimum 50% chance to hit"
        value=50
        cumulative=yes
    [/chance_to_hit]
#enddef
#define ABILITY_SKILLED
    [chance_to_hit]
        id=skilled
        name= _ "skilled"
        female_name= _ "female^skilled"
        description=_"A master of the warrior's craft, this unit's strikes ring true even in the most challenging conditions. Years of relentless training ensure their weapon finds its mark."
        special_note= _ "This unit always has a minimum 50% chance to hit"
        value=50
        cumulative=yes
    [/chance_to_hit]
#enddef
#define ABILITY_VERY_SKILLED
    [chance_to_hit]
        id=very_skilled
        name= _ "very skilled"
        female_name= _ "female^very skilled"
        description=_"A legendary warrior whose precision is spoken of in hushed whispers, this unit's mastery transcends the ordinary bounds of combat. Every strike flows with a grace that seems almost supernatural."
        special_note= _ "This unit always has a minimum 60% chance to hit"
        value=60
        cumulative=yes
    [/chance_to_hit]
#enddef
#define BATTLE_FRENZY COUNT ADDITION
    [damage]
        id=battle_frenzy_{COUNT}
        add="({ADDITION} * level)"
        cumulative=no
        apply_to=self
        [filter_self]
            [filter_adjacent]
                is_enemy=yes
                count={COUNT}
            [/filter_adjacent]
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_BATTLE_FRENZY
    [damage]
        id=battle_frenzy
        name= _ "battle frenzy"
        female_name= _ "female^battle frenzy"
        description=_ "When in the heat of battle, this unit enters a state of frenzy, significantly increasing its attack power.

+level damage per every adjecent enemy, except first one."
        special_note=_ "This unit deals more damage for every adjecent enemy"
        [filter_self] # So you see something in attack menu
            [filter_adjacent]
                is_enemy=yes
                count=2-6
            [/filter_adjacent]
        [/filter_self]
    [/damage]
    {BATTLE_FRENZY 2 1}
    {BATTLE_FRENZY 3 2}
    {BATTLE_FRENZY 4 3}
    {BATTLE_FRENZY 5 4}
    {BATTLE_FRENZY 6 5}
#enddef

#define ABILITY_BERSERKERS_RAGE
    [damage]
        id=berserkers_rage
        name= _ "berserkers rage"
        female_name= _ "female^berserkers rage"
        description="This unit enters a frenzied state when is about to strike for the last time.

In this state, the unit's damage doubles, unleashing its full berserker rage on its enemies."
        special_note=_ "This unit deals great damage when it's about to die."
        multiply=2
        [filter_self]
            formula="if((self.hitpoints * 4) < self.max_hitpoints, 1, 0)"
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_AVENGER
    [damage]
        id=avenger
        name= _ "avenger"
        female_name= _ "female^avenger"
        description="#TODO"
        special_note=_ "#TODO"
        multiply=2
        active_on = offense
        [filter_opponent]
            formula="take_while(vars.unavenged_kills.item,self!=vars.current_team_name) != vars.unavenged_kills.item and vars.unavenged_kills != '' and vars.unavenged_kills != variable_that_doesnt_exist
                where
                    vars = self.wml_vars" #TODO team_name of the attacker save at the start of each side turn into each and every unit
        [/filter_opponent]  #TODO reset the status when cleansed, cleansing shoud happen woth evey stored/recalled unit probably?
    [/damage]
#enddef
#define ABILITY_DAUNTLESS
    [resistance]
        id=dauntless
        name= _ "dauntless"
        female_name= _ "female^dauntless"
        description= _ "When attacking, this unit's unwavering courage and determination bolster its defenses, significantly increasing its resistances."
        special_note=_ "This unit's resistances are doubled, up to a maximum of 50%, when attacking. Vulnerabilities are not affected."
        multiply=2
        max_value=50
        [filter_base_value]
            greater_than=0
            less_than=50
        [/filter_base_value]
        affect_self=yes
        active_on=offense
    [/resistance]
#enddef
#define ABILITY_AWE
    [leadership]
        id=awe
        cumulative=yes
        name=_"awe"
        female_name= _ "female^awe"
        description=_"The menacing presence of this unit strikes fear into the hearts of nearby enemies. Enemies adjacent to this unit deal 15% less damage, with an additional 15% reduction per level difference.
This ability does not affect non-living or fearless units, as they are immune to such intimidation."
        special_note=_ "Enemies adjacent to this unit deal 15% less damage, and another 15% less damage per level difference. Does not affect non-living or fearless units."
        sub="(if(level > other.level, (15 * (level + 1 - other.level)), 15))"
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            [filter]
                [not]
                    trait=undead
                    [or]
                        trait=fearless
                    [/or]
                [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef
#define ABILITY_FLEE
    [chance_to_hit]
        id=flee
        name= _ "flee"
        female_name= _ "female^flee"
        description=_ "When faced with imminent defeat, the unit can execute a strategic retreat, swiftly disengaging from combat to avoid certain death.

The more space this unit has behind, the more likely it can evade."
        special_note=_ "This unit can flee combat, to fight another day."
        apply_to=opponent
        multiply="(1
        - if(unit_at(back) or movement_cost(self, back) = 99 or movement_cost(self, back) = null(),0,0.3)
        - if(unit_at(back_left) or movement_cost(self, back_left) = 99 or movement_cost(self, back_left) = null(),0,0.1)
        - if(unit_at(back_right) or movement_cost(self, back_right) = 99 or movement_cost(self, back_right) = null(),0,0.1)
        where
            back_left = direction_from(loc, dirs[back_left_index]),
            back = direction_from(loc, dirs[back_index]),
            back_right = direction_from(loc, dirs[back_right_index])
        where
            back_left_index = (index + 4) % 6,
            back_index = (index + 3) % 6,
            back_right_index = (index + 2) % 6
        where
            index = index_of(relative_dir(loc, other.loc), dirs)
        where
            dirs = ['n', 'ne', 'se', 's', 'sw', 'nw']
        )"#My most complex formula so far :D
        [filter_self]
            formula="(wml_vars.flee)"
        [/filter_self]
    [/chance_to_hit]
#enddef
#define ABILITY_IMMORTAL
    [dummy]
        id=immortal
        name= _ "immortal"
        female_name= _ "female^immortal"
        description= _ "When thy mortal coil fails, embrace not the peace of death, but the curse of unlife. Thy soul, bound to bone by eldritch magicks, shall defy the reaper's scythe. In shadows deep and time unending, thy form shall walk the earth, a wraith of bygone days. The warmth of life shall flee thy touch, and mortal men shall tremble at thy passing. Whispers of thy name shall chill the blood, and nightmares of thy visage shall plague the living. In realms of dust and forgotten lore, thy power shall wax eternal, fed by the fear of those who dare not speak thy dreaded title. But hark! The price of such power is steep, for in cheating death, thou shalt become its master and its slave forevermore."
        special_note=_"When thy mortal coil fails, embrace not the peace of death, but the curse of unlife. Thy soul, bound to bone by eldritch magicks, shall defy the reaper's scythe. In shadows deep and time unending, thy form shall walk the earth, a wraith of bygone days. The warmth of life shall flee thy touch, and mortal men shall tremble at thy passing. Whispers of thy name shall chill the blood, and nightmares of thy visage shall plague the living. In realms of dust and forgotten lore, thy power shall wax eternal, fed by the fear of those who dare not speak thy dreaded title. But hark! The price of such power is steep, for in cheating death, thou shalt become its master and its slave forevermore."
    [/dummy]
#enddef
#define ABILITY_VEIL_OF_THE_VOID
    [veil_of_the_void]
        id=veil_of_the_void
        name= _ "veil of the void"
        female_name= _ "female^veil of the void"
        description= _ "When thy unholy form manifests anew, thy essence shall fade to mist, untouchable by mortal hands or mundane steel. Pass through solid stone as if 'twere but air, and let arrows whistle harmlessly through thy spectral form. But mark well, wielder of dark arts - this reprieve is fleeting. As the third sand falls, corporeality shall claim thee once more, returning thy bones to the realm of flesh and blood."
        special_note=_"When thy unholy form manifests anew, thy essence shall fade to mist, untouchable by mortal hands or mundane steel. Pass through solid stone as if 'twere but air, and let arrows whistle harmlessly through thy spectral form. But mark well, wielder of dark arts - this reprieve is fleeting. As the third sand falls, corporeality shall claim thee once more, returning thy bones to the realm of flesh and blood."
    [/veil_of_the_void]
#enddef
#define ABILITY_DISENGAGE
    [dummy]
        id=disengage
        name= _ "disengage"
        female_name= _ "female^disengage"
        description= _ "Upon invoking the esteemed maneuver, the adept tactician deftly extricates themselves from the tumultuous fray of battle.

This unit can move after attack, if it haven't moved yet."
        special_note=_"If this unit doesn't move before attacking, it will retain its movement points after the attack."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_ARSON
    [damage]
        id=arson_1
        name= _ "arson"
        female_name= _ "female^arson"
        description= _ "The ancient art of weaponizing flame against shelter and sanctuary. Those who wield this dreaded technique know how to turn an enemy's refuge into their pyre, as flames feast eagerly on wooden homes and forested havens. Yet against those who seek safety in water's embrace, the fire's hunger wanes."
        special_note=_ "This unit uses the terrain against the enemy by lighting it on fire, its damage increases by 25% when the enemy is on forest, castle, or a village tile, or other manmade structure (farms and windmills) but decreases by 25% if the enemy is in water." #NOTE ::Note:: Villages or castles with water or swamp are considered water.
        apply_to=self
        multiply="1.25"
        [filter_opponent]
            [filter_location]
                terrain=C*^*,K*^*,*^F*,*^Gvs,*^Wm,*^Eff,*^Uf*,*^V*,*^Bw*,*^Bh*,*^Bp*
                [not]
                    terrain=W*^*,S*^*,Chw*^*,Chs*^*,Cm*^*,Khw*^*,Khs*^*,Km*^*,*^Vm*,*^Vaa
                [/not]
            [/filter_location]
        [/filter_opponent]
    [/damage]
    [damage]
        id=arson_2
        apply_to=self
        multiply="0.75"
        [filter_opponent]
            [filter_location]
                terrain=W*^*,S*^*,Chw*^*,Chs*^*,Cm*^*,Khw*^*,Khs*^*,Km*^*
                [not]
                    terrain=*^Bw*,*^Bs*,*^Bh*,*^Bc*,*^Bp* # not on Bridges
                [/not]
            [/filter_location]
        [/filter_opponent]
    [/damage]
#enddef
#define WEAPON_SPECIAL_CALIBRATED
    [damage]
        id=calibrated
        name= _ "calibrated"
        female_name= _ "female^calibrated"
        description=_ "Intricate weapon that grows more devastating with each consecutive strike by 20%, while every miss in row allows wielder to better gauge their weapons aim by 10%. A fearsome tool that turns both victory and failure into deadly advantage."
        special_note=_ "Each consecutive hit boosts damage by 20%, and each consecutive miss increases accuracy by 10%."
        apply_to=self
        multiply="(if(self.wml_vars.last_attack='hit',1+(self.wml_vars.last_attack_streak*0.2),1))"
    [/damage]
    [chance_to_hit]
        id=calibrated_chance_to_hit
        apply_to=self
        add="(if(self.wml_vars.last_attack='miss',self.wml_vars.last_attack_streak*10,0))"
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_PACKSTRIKE
    [attack]
        id=packstrike
        name= _ "packstrike"
        female_name= _ "female^packstrike"
        description=_ "When these savage riders charge, their war cry becomes a primal signal that electrifies every nearby ally - a thunderous invitation to rend and tear. Wolves and goblins move with a savage synchronicity born of generations of shared hunts, striking as one overwhelming force. Their coordinated assault transcends mere tactics; it is a ritual of predatory communion, where individual warriors dissolve into a single, merciless hunting entity. No target can withstand such a coordinated onslaught, as blades and fangs descend in perfect, unstoppable harmony - a symphony of calculated violence that leaves a little room for counterattack."
        special_note=_ "When attacking, this unit leads its pack into battle. Adjacent allies join the assault, striking the same target without facing retaliation."
        active_on=offense
        [filter_self]#TODO if has ally adjacent to both this unit and the enemy
            [filter_adjacent]
                is_enemy=no
            [/filter_adjacent]
        [/filter_self]
    [/attack]
#enddef
#define WEAPON_SPECIAL_INTERCEPT
    [attack]
        id=intercept
        name= _ "intercept"
        female_name= _ "intercept"
        description=_ "#TODO"
        special_note=_ "#TODO"
        [filter_self]
            [not]
            [/not]
        [/filter_self]
    [/attack]
#enddef
#define WEAPON_SPECIAL_LURE
    [move]
        id=lure
        name= _ "lure"
        female_name= _ "lure"
        description=_ "#TODO"
        special_note=_ "#TODO"
        active_on=offense
    [/move]
#enddef
#define WEAPON_SPECIAL_CLEAVE
    [attack]
        id=cleave
        name= _ "cleave"
        female_name= _ "female^cleave"
        description=_ "#TODO"
        special_note=_ "#TODO"
        #  [filter_self]#TODO if has enemy in zone of attack (rather not, looks weird)
        #      [filter_adjacent]
        #          is_enemy=yes
        #          count=2-6
        #      [/filter_adjacent]
        #  [/filter_self]
    [/attack]
#enddef
#define WEAPON_SPECIAL_DANSE_MACABRE
    [attack]
        id=danse_macabre
        name= _ "danse macabre"
        female_name= _ "female^danse macabre"
        description=_ "#TODO"
        special_note=_ "#TODO"
        #Only if theres empty, passable space behind the opponent
    [/attack]
#enddef
#define WEAPON_SPECIAL_DOUBLESTRIKE
    [attack]
        id=doublestrike
        name= _ "doublestrike"
        female_name= _ "female^doublestrike"
        description=_ "#TODO"
        special_note=_ "#TODO"
    [/attack]
#enddef
#define WEAPON_SPECIAL_FEED
    [feed]
        id=feed
        name= _ "feed"
        female_name= _ "female^feed"
        description=_ "The wolves' supernatural hunger is awakened by prey tainted with their rider's poison - a dark, mystical bond that transforms fallen enemies into a ritualistic feast. When poisoned claws claim a victim, the wolves perceive a deeper, more potent essence that calls to their primal hunger, compelling them to feed and regenerate."
        special_note=_ "Aggressive kills restore 15% of enemy's max HP to adjacent allied wolves and self."
        active_on=offense
        #TODO only in attack, if enemy is not undead, animate wolves feeding
        [filter_opponent]
            [not] #TODO in case of need shift this list
                trait="undead"
            [/not]
        [/filter_opponent]
    [/feed]
#enddef
#define WEAPON_SPECIAL_SOULREAP
    [soulreap]
        id=soulreap
        name= _ "soulreap"
        female_name= _ "female^soulreap"
        description=_ "#TODO"
        special_note=_ "#TODO"
        #TODO +1 soul when kills an unit
        [filter_opponent]
            [not] #TODO in case of need shift this list
                #UNITS WITH SOULS
                trait="undead"
            [/not]
        [/filter_opponent]
    [/soulreap]
#enddef
#define WEAPON_SPECIAL_SPIRITCRY
    [attacks]
        id=spiritcry
        name= _ "spiritcry"
        female_name= _ "female^spiritcry"
        description=_ "#TODO"
        special_note=_ "#TODO"
        add="(self.wml_vars.souls)"
        #TODO +1 attack per soul
    [/attacks]
#enddef
#define WEAPON_SPECIAL_AGGRESSIVE
    [damage]
        id=aggressive
        name= _ "aggressive"
        female_name= _ "female^aggressive"
        description=_ "A relentless combat style that builds in ferocity with each strike. When the warrior maintains their assault without pause, their follow-up blow channels the momentum of their rage, striking with devastating force. The true power of this technique manifests only in the rhythm of continuous attack."
        special_note=_ "When attacking, consecutive hits deal double damage."
        active_on=offense
        apply_to=self
        multiply="(if(self.wml_vars.last_attack='hit' and self.wml_vars.first_attack != null(),2,1))"
    [/damage]
#enddef
#define ABILITY_CONCENTRATED
    [attacks] #TODO #NOW
        id=concentrated
        name= _ "concentrated"
        female_name= _ "female^concentrated"
        description= _ "#TODO"
        special_note=_ "#TODO"
        active_on=offense
        apply_to=self
        sub=1
    [/attacks]
    [chance_to_hit]
        id=concentrated_2 #TODO how is it used elsewhere?
        active_on=offense
        apply_to=self
        add="$($weapon.number * 5)"
    [/chance_to_hit]
#enddef
#define ABILITY_LONE_WOLF
    [damage]
        id=lone_wolf
        name= _ "lone wolf"
        female_name= _ "female^lone wolf"
        description=_ "When this unit finds itself isolated, without nearby allies, it undergoes a remarkable transformation.
Enhanced by solitude, its senses sharpen, reflexes quicken, and strength surges."
        special_note=_ "When isolated, the unit's skills peak."
        multiply=1.25
        [filter_self]
            [filter_adjacent]
                is_enemy=no
                count=0
            [/filter_adjacent]
        [/filter_self]
    [/damage]
    [chance_to_hit]
        id=lone_wolf_chance_to_hit
        add=10
        cumulative=yes
        apply_to=self
        [filter_self]
            [filter_adjacent]
                is_enemy=no
                count=0
            [/filter_adjacent]
        [/filter_self]
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_RIGHTEOUS
    [damage]
        id=righteous
        name=_"righteous"
        female_name= _ "female^righteous"
        description= _ "Sacred power that burns brightest against the forces of chaos and darkness. Those who bear this blessing channel divine authority that smites particularly hard against creatures born of disorder and malevolence, their weapons glowing with holy purpose when confronting such foes."
        special_note=_ "This weapon deals 30% more damage against chaotic enemies."
        multiply=1.3
        [filter_opponent]
            [filter_wml]
                alignment=chaotic
            [/filter_wml]
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_STORMING
    [damage]
        id=storming
        name=_"storming"
        female_name= _ "female^storming"
        description= _ "This unit excels in breaching fortified positions. When attacking enemies occupying a castle or village, this unit gains increased strength, allowing it to deal extra damage and break through defenses more effectively.
The overwhelming force of the storming unit's assault can demoralize and weaken entrenched enemies, making it a powerful asset in capturing strategic locations.

Upon defeating an enemy on castle or village this units takes it's ground."
        special_note=_ "This unit deals extra damage agains fortified foes and recaptures those positions."
        active_on=offense
        multiply=2 #TODO 1.5?
        [filter_opponent]
            [filter_location]
                terrain=*^V*,C*^*,K*^*
            [/filter_location]
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_STALKER
    [teleports]
        id=stalker
        name= _ "stalker"
        female_name= _ "female^stalker"
        description= _ "#TODO"
        special_note=_ "#TODO"
    [/teleports]
#enddef
#define ABILITY_REVEALS
    [unhides]
        id=reveals
        name= _ "reveals"
        female_name= _ "female^reveals"
        description= _ "A keen eye for detail and years of exploration allow this unit to spot concealed foes within 3 hexes, revealing any hidden enemies in range."
        special_note=_ "Reveals hidden enemies within 3 hexes."
    [/unhides]
#enddef
#define ABILITY_BFBH_NIGHTSTALK
    [hides]
        id=nightstalk
        name= _ "nightstalk"
        female_name= _ "nightstalk"
        description= _ "The unit becomes invisible during night.

Enemy units cannot see this unit at night, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement."
        special_note={INTERNAL:SPECIAL_NOTES_NIGHTSTALK}
        affect_self=yes
        [filter]
            [filter_location]
                time_of_day=chaotic
            [/filter_location]
            {UNHIDE_FILTER}
        [/filter]
    [/hides]
#enddef
#define ABILITY_BFBH_CONCEALMENT
    [hides]
        id=concealment
        name= _ "concealment"
        female_name= _ "female^concealment"
        description= _ "This unit can hide in villages (with the exception of water villages), and remain undetected by its enemies, except by those standing next to it.

Enemy units cannot see this unit while it is in a village, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement."
        special_note={INTERNAL:SPECIAL_NOTES_CONCEALMENT}
        affect_self=yes
        [filter]
            [filter_location]
                terrain=*^V*
            [/filter_location]
            {UNHIDE_FILTER}
        [/filter]
    [/hides]
#enddef
#define ABILITY_BFBH_SUBMERGE
    [hides]
        id=submerge
        name= _ "submerge"
        female_name= _ "female^submerge"
        description= _ "This unit can hide in deep water, and remain undetected by its enemies.

Enemy units cannot see this unit while it is in deep water, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement."
        special_note={INTERNAL:SPECIAL_NOTES_SUBMERGE}
        affect_self=yes
        [filter]
            [filter_location]
                terrain=Wo*^*
            [/filter_location]
            {UNHIDE_FILTER}
        [/filter]
    [/hides]
#enddef
#define ABILITY_BFBH_AMBUSH
    [hides]
        id=ambush
        name= _ "ambush"
        female_name= _ "female^ambush"
        description= _ "This unit can hide in forest, and remain undetected by its enemies.

Enemy units cannot see this unit while it is in forest, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement."
        special_note={INTERNAL:SPECIAL_NOTES_AMBUSH}
        affect_self=yes
        [filter_self]
            [filter_location]
                terrain=*^F*
            [/filter_location]
            {UNHIDE_FILTER}
        [/filter_self]
    [/hides]
#enddef
#define ABILITY_WOLF_PACK
    [skirmisher]
        id=wolf_pack
        name=_"wolf pack"
        female_name= _ "female^wolf pack"
        description=_"Moving as one with their kin, these hunters understand the ancient ways of the pack. Their presence creates paths through enemy lines that other wolves instinctively recognize and follow, allowing the pack to weave through foes with predatory grace."
        special_note=_ "This unit negates enemy Zones of Control around itself for allied wolf units."
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
    [/skirmisher]
#enddef
#define ABILITY_PACK_LEADER
    [damage]
        id=pack_leader
        name=_"pack leader"
        female_name= _ "female^pack leader"
        description=_"A master of coordinated hunting tactics, this alpha guides their pack in the ancient art of the encirclement. When wolves flank their prey from opposite sides under the leader's guidance, they strike with the devastating precision that comes from generations of inherited hunting wisdom."
        special_note=_ "Adjacent allied wolves deal 50% more damage when attacking an enemy from opposite sides"
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
        multiply=1.5
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_TANGLED_SLAUGHTER
    [damage] #TODO
        id=tangled_slaughter
        name=_"tangled slaughter"
        female_name= _ "female^tangled slaughter"
        description=_"#TODO"
        special_note=_ "#TODO"
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
        multiply=1.5
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_DESPERATE_DODGE
    [chance_to_hit]
        id=desperate_dodge
        name= _ "desperate dodge"
        female_name= _ "female^desperate dodge"
        description= _ "The Desperation Dodging effect represents the unit's survival instincts kicking in when nearing a critically injured state. As it takes more damage, its reflexes are heightened by adrenaline, allowing it to twist, duck and dive to narrowly avoid what would otherwise be lethal blows.
The effect ends once the unit evades an attack, simulating how after that harrowing near-miss experience, the surge of desperation fades and the unit's evasion returns to its base chance."
        special_note=_ "This unit's chance to evade grows as it takes damage, resets when evades."
        apply_to=opponent
        sub="(other.wml_vars.desperate_dodge)"
        cumulative=no
    [/chance_to_hit]
#enddef
#define ABILITY_SCAVENGER
    [scavenger]
        id=scavenger
        name=_"scavenger"
        female_name= _ "female^scavenger"
        description=_"Scavenger feeds on the remains of its fallen enemies, absorbing their vitality to heal itself. When the unit kills an enemy, it restores health equal to 25% of the enemy's maximum HP, allowing it to sustain itself in the midst of battle.
This gruesome ability ensures scavenger remains a persistent threat on the battlefield."
        special_note= _ "Whenever this unit kills a living enemy, it heals itself by 25% of the enemy's max health."
    [/scavenger]
#enddef
#define ABILITY_DRUMBEAT
    [leadership]
        id=drumbeat
        name= _ "drumbeat"
        female_name= _ "female^drumbeat"
        description= _ "The steady rhythm of war drums carries across the battlefield, its primal cadence steeling the hearts of allies even in their darkest hours. Those who hear this ancient battle-song find strength when the familiar light wanes, their spirits bolstered by its unwavering pulse."
        special_note= _ "This unit can offer reassurance to allies, counteracting a time-of-day penalty."
        value="(if('fearless' in other.traits,
            0,
            switch(
                other.alignment,
                'chaotic',max(tod_bonus(loc(other.x,other.y)),0),
                'lawful',max((-tod_bonus(loc(other.x,other.y))),0),
                0
            )
        ))" # This is a comment (for WFL) ... #NOTE can break if a [fearless] trait is used that won't be allways active#
        cumulative=no
        affect_self=no
        [affect_adjacent]
        [/affect_adjacent]
    [/leadership]
#enddef
#define ABILITY_STONEFOOT
    [damage]
        id=stonefoot
        name=_"stonefoot"
        female_name= _ "stonefoot"
        description=_"Hearken, ye who seek the wisdom of the ancients! Know ye that the children of the deep places, the venerable dwarven race, possess a might born of stone and forged in the fires of creation itself. When a warrior of our kind plants his feet upon the earth, becoming as immovable as the very mountains we call home, a fearsome power awakens within.
In those moments when a dwarven warrior chooses to stand his ground, neither advancing nor retreating, he channels the unyielding spirit of our ancestors. His arms become as mighty as the great pillars that hold aloft our subterranean halls, and his blows fall with the force of a thousand years of tradition and strength.
Verily, I say unto thee, that should a dwarf remain steadfast in his position during the tumult of battle, eschewing movement in favor of stalwart defense, his strikes shall bear the blessing of the mountain itself. Each swing of his axe, each thrust of his spear, each bolt loosed from his crossbow shall carry with it a fifth part more of its usual might.
This is the way of our people, as it has been since the first dwarf emerged from the heart of the world. We are the immovable objects, the unbreakable shields, and when we choose to stand our ground, all foes shall tremble before our enhanced fury."
        special_note= _ "When this warrior holds it's ground, blows clinging on armor of enemy shall be severe."
        multiply=1.3
        [filter_self]
            formula="(self.wml_vars.side_turn_loc[0].x = self.x) and (self.wml_vars.side_turn_loc[0].y = self.y)" #TODO not perfect if moves there and back... not the case now
        [/filter_self]
    [/damage]
#enddef
#define ETHEREAL_PART ID TYPE
    [resistance]
        id=ethereal_{ID}
        add=50
        max_value=100
        [filter_self]
            formula="(self.wml_vars.ethereal[0].{TYPE})"
        [/filter_self]
        apply_to={TYPE}
    [/resistance]
#enddef
#define ABILITY_ETHEREAL
    [mother_tag] #TODO, rename for ghost
        id=ethereal
        name= _ "ethereal"
        female_name= _ "female^ethereal"
        description=_"#TODO"
        special_note= _ "#TODO"
        children="ethereal_1,ethereal_2,ethereal_3,ethereal_4,ethereal_5,ethereal_6"
    [/mother_tag]
    {ETHEREAL_PART 1 blade}
    {ETHEREAL_PART 2 pierce}
    {ETHEREAL_PART 3 impact}
    {ETHEREAL_PART 4 fire}
    {ETHEREAL_PART 5 cold}
    {ETHEREAL_PART 6 arcane}
#enddef
#define ABILITY_DEATH_SHRIEK
    [dummy]
        id=death_shriek
        name= _ "death shriek"
        female_name= _ "female^death shriek"
        description=_"As this creature perishes, it unleashes a piercing ultrasonic cry. Enemies within 2 tiles are disoriented, suffering 10% reduced accuracy on their next turn. Even in death, the creature's echolocation serves a final purpose."
        special_note= _ "Upon death accuracy of nearby enemies is disrupted temorary."
    [/dummy]
#enddef
#define ABILITY_SWIFT
    [dummy]
        id=swift
        name= _ "swift"
        female_name= _ "female^swift"
        description=_"The serpentine grace of the Naga fighter allows it to strike and slither away from danger, moving up to 2 hexes after an attack. These warriors of the deep are masters of hit-and-glide tactics, as fluid in battle as they are in water."
        special_note= _ "Can move up to 2 hexes after attacking."
    [/dummy]
#enddef
#define ABILITY_ENDURANCE
    [dummy]
        id=endurance
        name= _ "endurance"
        female_name= _ "female^endurance"
        description=_"If this unit begins combat with its full measure of life, it cannot be felled in one engagement, always emerging with a flicker of vitality intact."
        special_note= _ "Should a combatant enter the fray with their life force unblemished, the threads of fate shall not be severed in a single clash of arms."
    [/dummy]
#enddef
#define ABILITY_RESTED
    [rested]
        id=rested
        name= _ "rested"
        female_name= _ "female^rested"
        description=_"A warrior's vigor peaks after proper rest and care, their vitality swelling beyond normal bounds. This enhanced strength gradually wanes with exertion, though it can be restored by brief respite in settlements - villages offering the deepest recovery, while castle walls offer some respite, preserving what strength remains."
        special_note= _ "Unit gains temporary max HP (5 + 5 per level) that decreases by 1 each turn. Recovers 5 max HP in villages, maintains the bonus in castles."
    [/rested]
#enddef
#define ABILITY_ARDENT
    [ardent]
        id=ardent
        name= _ "ardent"
        female_name= _ "female^ardent"
        description=_"Woe unto those who would stand against the ardent lord and his invigorated host, for they shalt be swept away like leaves before the tempest. The elder chroniclers speak in awed tones of the devastation wrought by these sudden, savage assaults - a testament to the inspiring power of a leader who hath tasted victory and shown his warriors the true meaning of courage."
        special_note= _ "When the battle-hardened lord doth vanquish his foes, a righteous fire doth instantly ignite within the hearts of his loyal warriors. For the lord, unafraid to cast himself into the heart of the fierce battle, sets an example of peerless valor that his men cannot help but emulate with fervor."
    [/ardent]
#enddef
#define ABILITY_PROTECTION
    [resistance] #TODO only if attacker adjacent to this unit ### CANNOT BE DONE!!!
        id=protection
        name= _ "protection"
        female_name= _ "female^protection"
        description=_"#TODO"
        special_note= _ "#TODO"
        add=20
        max_value=50
        affect_self=no
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                formula="(hitpoints/max_hitpoints) < (other.hitpoints/other.max_hitpoints)"
            [/filter]
        [/affect_adjacent]
        #  [filter_opponent]
        #      [filter_location]
        #          [filter_adjacent_location]
        #              [filter]
        #                  id="meow"
        #              [/filter]
        #          [/filter_adjacent_location]
        #      [/filter_location]
        #  [/filter_opponent]
        #  [filter_adjacent]
        #      [not]
        #          id="(other.id)"
        #      [/not]
        #  [/filter_adjacent]
        #  [filter_self]
        #      [filter_adjacent]
        #          id=(other.id)
        #      [/filter_adjacent]
        #  [/filter_self]
        #  [filter_second]
        #      [filter_adjacent]
        #          id="meow"
        #      [/filter_adjacent]
        #  [/filter_second]
        [filter_base_value]
            less_than=50
        [/filter_base_value]
        cumulative=yes
    [/resistance]
#enddef
#define WEAPON_SPECIAL_SHIELDSTRIKE
    [damage]
        id=shieldstrike
        name= _ "shieldstrike"
        female_name= _ "female^shieldstrike"
        description= _ "The warrior expertly pivots their shield into a striking position while maintaining their defensive stance, turning protection into a weapon without sacrificing their guard."
        special_note= _ "When this attack is used offensively, this unit takes 2 damage less on every strike."
        active_on=offense
        apply_to=opponent
        sub=2
    [/damage]
#enddef
#define WEAPON_SPECIAL_DISARMING
    [disarming]
        id=disarming
        name= _ "disarming"
        female_name= _ "female^disarming"
        description= _ "Deep in the mountain forges, the dwarves perfected the art of sundering weapons from flesh with thunderous force. When the smoke clears and the echoes fade, naught remains but scattered steel and disarmed foes, helplessly grasping at empty air where their weapons once were."
        special_note= _ "Successful attacks in offense prevent the target from attacking on their next turn."
        active_on=offense
    [/disarming]
#enddef
#define WEAPON_SPECIAL_FURY
    [damage]
        id=fury
        name= _ "fury"
        female_name= _ "female^fury"
        description= _ "Blood and victory fuel a primal rage, driving the hunter forward with newfound ferocity and reckless abandon."
        special_note= _ "Upon landing a killing blow, gain +4 movement, +1 attack, +20% damage, and -20% resistance until end of turn."
        active_on=offense
        multiply="((min(self.wml_vars.fury,100)/100.0)+1)"
        [filter_self]
            formula="(self.wml_vars.fury > 0)"
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_FURY_VULNERABILITY
    [resistance]
        id=fury vulnerability
        #  name= _ "fury vulnerability"
        #  female_name= _ "female^fury vulnerability"
        #  description= _ ""
        #  special_note= _ ""
        sub="(min(self.wml_vars.fury,100))"
        [filter_self]
            formula="(self.wml_vars.fury > 0)"
        [/filter_self]
    [/resistance]
#enddef
#define WEAPON_SPECIAL_INK
    [dummy]
        id=ink
        name=_"ink"
        female_name= _ "female^ink"
        description= _ "A peculiar defense mechanism perfected through evolution, releasing a cloud of dark fluid that lingers in the water, confusing and disorienting any who dare to strike through it. The murky substance clings to their eyes and senses, making it difficult to land precise blows."
        special_note= _ "Successful hits reduce opponent's accuracy by 10% for this combat."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_RAPIDFIRE
    [chance_to_hit]
        id=rapidfire
        name= _ "rapidfire"
        female_name= _ "female^rapidfire"
        description= _ "The Rapidfire ability allows the wielder to unleash a blistering hail of attacks by rapidly firing or striking with the weapon. However, this drastic rise in attack speed comes at the cost of reduced accuracy and precision.
While Rapidfire is active, each individual attack has a higher chance to miss the intended target as the wielder sacrifices careful aim for sheer volume of fire. Shots go awry more frequently, blows glance off-target, and it becomes much harder to land clean hits."
        special_note= _ "Units attack releases shots in fast succession, which increases strikes by 90%, but decreases accuracy by 20%."
        sub=20
        active_on=offense
        cumulative=no
    [/chance_to_hit]
    [attacks]
        id=rapidfire
        name= _ ""
        description= ""
        multiply=1.9
        active_on=offense
        cumulative=no
    [/attacks]
#enddef
#define WEAPON_SPECIAL_DISRUPTOR_STRIKE
    [disruptor_strike]
        id=disruptor_strike
        name= _ "disruptor strike"
        female_name= _ "female^disruptor strike"
        description= _ "A devastating strike that resonates through the target's body, sending tremors through their muscles and disrupting their ability to coordinate complex movements. The crushing impact leaves lasting trauma that makes any precise motion a struggle."
        special_note= _ "Brutal hit leaves the enemy struggling to muster ranged attacks until turn end."
        active_on=offense
    [/disruptor_strike]
#enddef
#define ABILITY_DISRUPTED
    [attacks]
        id=disrupted
        #  name= _ "disrupted" #TODO add status effect instead of this
        #  female_name= _ "female^disrupted"
        #  description= _ "Muscles tremble and coordination fails, making it difficult to properly draw and aim any ranged weapon. Each motion feels forced and unnatural."
        #  special_note= _ "Shaken coordination reduces offensive ranged attack capability by half."
        multiply=0.5
        active_on=offense
        [filter_student]
            [filter_weapon]
                range=ranged
            [/filter_weapon]
        [/filter_student]
    [/attacks]
#enddef
#define WEAPON_SPECIAL_TEMPO_SURGE
    [attacks]
        id=tempo_surge
        name= _ "tempo surge"
        female_name= _ "female^tempo surge"
        description= _ "In the crucible of combat, time bends to the sword's will. Blades clash in a furious dance, each warrior's strikes multiplied as if caught in a whirlwind of steel. Both attacker and defender find their blows increased by half again, locked in a duel that pushes the very limits of mortal speed and skill."
        special_note= _ "A frenzied exchange of blows pushes both combatants to their limits. Increases strikes by 50% for both attacker and defender."
        multiply=1.5
        apply_to=both
        active_on=offense
        cumulative=no
    [/attacks]
#enddef
#define WEAPON_SPECIAL_KNOCKBACK
    [knockback] #TODO event part
        id=knockback
        name= _ "knockback"
        female_name= _ "female^knockback"
        description=_ "#TODO"
        special_note= _"#TODO"
    [/knockback]
#enddef
#define WEAPON_SPECIAL_ARMOR_BREAKING
    [dummy]
        id=armor_breaking
        name=_"armor breaking"
        female_name= _ "female^armor breaking"
        description=_"With a thunderous blow that shakes the very earth, this weapon finds the flaw in foe's defenses. Their vaunted armor is temporarily compromised by 20%, its protective layers rent asunder by the sheer ferocity of attack. For but a fleeting moment, their stalwart guard is grievously weakened, leaving them vulnerable to further onslaught. Strike true while their aegis falters, for soon their battered shield shall regain its potency, denying this opportune breach. Seize chance to exploit their failing guard before the armor's integrity is restored."
        special_note= _ "Attacks of this unit can temporarily break foes armor."
    [/dummy]
#enddef
#define ABILITY_BROKEN_ARMOR
    [resistance]
        id=broken_armor_1
        cumulative=no
        sub=20
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=20
            less_than=100
        [/filter_base_value]
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/resistance]
    [resistance]
        id=broken_armor_2
        cumulative=no
        value=0
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=0
            less_than=21
        [/filter_base_value]
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/resistance]
#enddef
#define WEAPON_SPECIAL_ARMOR_PENETRATING
    [dummy]
        id = armor_penetrating
        name = _"armor penetrating"
        female_name= _ "female^armor penetrating"
        description= _ "A well-aimed attack that defies conventional defenses. With lethal precision, blow finds the chinks and weak points in foe's armor. No matter how stalwart their protective layering, a full thirty percent of its shielding value is rendered utterly moot. Such is the penetrating might of this focused assault that it simply punches through, shearing the armored plates asunder as if they were made of parchment."
        special_note= _ "This unit's attack can ignore portion of enemy armor."
    [/dummy]
#enddef
#define ABILITY_ARMOR_PENETRATING
    [resistance]
        id=armor_penetrating_ability_1
        cumulative=no
        sub=30
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=30
            less_than=100
        [/filter_base_value]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=armor_penetrating
        [/filter_second_weapon]
    [/resistance]
    [resistance]
        id=armor_penetrating_ability_2
        cumulative=no
        value=0
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=0
            less_than=31
        [/filter_base_value]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=armor_penetrating
        [/filter_second_weapon]
    [/resistance]
#enddef
#define WEAPON_SPECIAL_PARRY
    [damage]
#  try to block first strike
#  If block successful, counter-attacks deals +4 damage
#  If block fails, gain +25% defense against remaining strikes
        id = parry
        name = _"parry"
        female_name= _ "female^parry"
        description= _ "#TODO"
        special_note= _ "#TODO"
        apply_to=self
        active_on=defense
        add="(if(self.wml_vars.first_defense='miss',4,0))"
    [/damage]
    [chance_to_hit]
        id = parry_chance_to_hit
        apply_to=opponent
        active_on=defense
        sub="(if(self.wml_vars.first_defense='hit',20,0))"
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_COUNTER
    [dummy] #TODO ... not sure if good for attacking
        id = counter
        name = _"counter"
        female_name= _ "female^counter"
        description= _ "When an enemy attack misses, the unit expertly parries the failed strike, creating an opening for a precise counterattack.

This ability ensures that the unit lands a retaliatory hit, turning the foe's failure into an immediate advantage."
        special_note= _ "This unit hits enemy, when it misses it's strike."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_EXPLOITATION
    [attack] #TODO make it fire attack events, same as intercept
        id = exploitation
        name = _"exploitation"
        female_name= _ "female^exploitation"
        description= _ "Seizing the perfect moment, the opportunist unleashes a devastating strike on retreating enemies, exploiting their vulnerability, ensuring no escape for the weak and the cowardly

This unit attacks enemies with strike of the weapon, when a foe leaves it's zone of control."
        special_note= _ "This unit can deal extra damage to retreating enemy."
        [filter_self]
            [not]
            [/not]
        [/filter_self]
    [/attack]
#enddef
#define ABILITY_MARK
    [resistance] #TODO UPDATE DESCRIPTION, status
        id=mark
        sub=30
        [filter_self]
            formula="(other.id = self.wml_vars.marked_unit)"
        [/filter_self]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=mark
        [/filter_second_weapon]
    [/resistance]
#enddef
#define ABILITY_CORRODED
    [resistance]
        id=corroded
        name= _ "corroded"
        female_name=_"female^corrode"
        description= _ "Armor bears visible signs of deterioration - weakened straps, thinned plates, and compromised joints that expose vulnerable points."
        special_note= _ "Deteriorated armor provides 10% less protection until repaired in village."
        sub=10
        max_value=90 #so it makes 90 from 150
        apply_to=blade,pierce,impact
        affect_self=yes
    [/resistance]
#enddef
#define WEAPON_SPECIAL_CORRODE
    [dummy]
        id=corrode
        name= _ "corrode"
        female_name=_"female^corrode"
        description= _ "A caustic substance that seeps into the joints and seams of armor, eating away at metal and leather alike. The acidic compound continues its work until properly cleaned and treated, leaving equipment weakened and brittle."
        special_note= _ "Corrosive substances weaken physical armor by 10% until treated in a village."
        [filter_self]
            #  formula="(other.wml_vars.corroded = false)" #TODO, add corroded variable, filter from STATUS INSTEAD?
        [/filter_self]
    [/dummy]
#enddef
#define WEAPON_SPECIAL_MARK
    [dummy]
        id=mark
        name= _ "mark"
        female_name= _ "female^mark"
        description=_ "After attacking an enemy, this unit learns foes personal weakness allowing further strikes to be critical hits, dealing 50% more damage.
However this unit can mark only one enemy at the time."
        special_note=_ "Attacks of this unit can deal great damage if opponent doesn't change too often."
        [filter_self]
            formula="(other.id = self.wml_vars.marked_unit)"
        [/filter_self]
    [/dummy]
#enddef
#define WEAPON_SPECIAL_EXECUTIONERS_CHOP
    [damage] #TODO
        id=executioners_chop
        name= _ "executioner's chop"
        female_name= _ "female^executioner's chop"
        description=_ "With a decisive and brutal swing, the executioner unleashes a devastating blow that can seal the fate of any foe teetering on the edge of oblivion."
        special_note=_ "This unit can deal great damage to criticaly wounded units."
        multiply=2
        apply_to=self
        [filter_opponent]
        [/filter_opponent]
        [filter_self] #TODO, DOESN'T WORK #TODO
            #  formula="if((other.hitpoints * 4) < other.max_hitpoints, 1, 0)"
            formula="(other.hitpoints <= (self.attacks[0].damage * 2))"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_BLEED
    [dummy] #TODO (maybe rename to [bleed])
        id=bleed
        name= _ "bleed"
        female_name= _ "female^bleed"
        description=_"#TODO"
        special_note=_ "#TODO"
    [/dummy]
#enddef
#define WEAPON_SPECIAL_RIPOSTE
    [chance_to_hit]
        id=riposte
        name= _ "riposte"
        female_name= _ "female^riposte"
        description= _ "Years of battle have taught that patience in pain yields opportunity - waiting for that crucial moment when an attacker's guard drops, leaving them vulnerable to a swift and precise riposte."
        special_note= _ "The unit has at least 60% chance to hit during retaliation."
        value=60
        cumulative=yes
        active_on=defense
        apply_to=self
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_CRIPPLING_BLOW
    [dummy] #CURED ONLY IN VILLAGES, HEAL 8 HEALERS AND REGENERATION (20% PER HEALING)
        id=crippling_blow
        name= _ "crippling blow"
        female_name= _ "female^crippling blow"
        description=_ "This weapon makes the enemy unable to fight effectively, decreasing it's damage for 5% until healed." #TODO
        special_note=_ "This unit can hit so hard, it makes the enemy unable to fight effectively."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_LIMITED_USES ATTACKS TRAIT MENU_ITEM
    [limited_uses]
        id=limited_uses
        name= _ "limited uses {ATTACKS}"
        description=_ "This weapon can be used {ATTACKS} more times."
        special_note=_ "One of units weapon can be used only {ATTACKS} times."
        uses={ATTACKS}
        trait={TRAIT}
        menu_item={MENU_ITEM}
    [/limited_uses]
#enddef
#  #define WEAPON_SPECIAL_LIMITED_USES_MAX ATTACKS TRAIT MENU_ITEM
#      [limited_uses]
#          id=limited_uses_max
#          uses={ATTACKS}
#          trait={TRAIT}
#          menu_item={MENU_ITEM}
#      [/limited_uses]
#  #enddef
#define WEAPON_SPECIAL_ALL_ROUND
    [dummy]
        id=all_round
        name= _ "all round"
        description=_ "This attack damages all surrounding enemies."
        special_note=_ "This unit can damage all surrounding enemies."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_CLUSTER_SHOT
    [dummy]
        id=cluster_shot
        name= _ "cluster shot"
        description=_ "This attack damages all units adjacent to primary target."
        special_note=_ "Attacks of this unit can damage multiple units at once."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_LONG_RANGED RANGE
    [dummy]
        id=long_ranged_{RANGE}
        name= _ "long ranged {RANGE}"
        description=_ "This attack can attack to hexes up to {RANGE} tiles away"
        special_note=_ "Attacks of this unit can damage enemies up to {RANGE} tiles away"
        # set attack_weight and defense_weight to 0 if it's long ranged only
    [/dummy]
#enddef
#define WEAPON_SPECIAL_HIT_AND_RUN
    [dummy]
        id=hit_and_run
        name= _ "hit and run"
        description=_ "Attacker restores movement and gains skirmisher ability for rest of the turn when attacking with this weapon."
        special_note=_ "This unit can attack and then move again."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_CRITICAL
    [damage]
        id=critical
        name= _ "critical"
        female_name=_"female^critical"
        description=_ "Imbued with lethal precision, this weapon harbors a latent power that occasionally manifests in devastating strikes, doubling its destructive force."
        special_note=_ "Weapon(s) of this unit have 10% chance to strike a vital point, inflicting twofold carnage."
        multiply=2
        [filter_self]
            formula="(self.wml_vars.critical = 1)"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_BULLSEYE
    [chance_to_hit]
        id=bullseye
        name= _ "bullseye"
        description = _ "When striking offensively, this weapon channels its wielder's focus, piercing through the chaos of battle. Attacks gain unerring accuracy, ensuring at least a 70% chance to hit."
        special_note= _ "Some weapons of the unit have at least a 70% chance to hit when used offensively."
        value=70
        cumulative=yes
        active_on=offense
    [/chance_to_hit]
#enddef
#define ABILITY_UNEXPERIENCED
    [chance_to_hit]
        id=unexperienced
        name= _ "unexperienced"
        description = _ "The telltale hesitation of one still learning their craft - slight uncertainties in stance and timing that make attacks less reliable."
        special_note= _ "Combat inexperience reduces strike accuracy by 10%."
        sub=10
        cumulative=yes
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_STUN
    [damage]
        id=zoc_stun
        name= _ "stun"
        description= _ "This attack hits so hard that the opponent is dazed and can no longer enforce a zone of control and looses half of movement points. The effect wears off on the opponent’s next turn."
        special_note=_ "This unit is able to stun its enemies, disrupting their zones of control and slowing them down."
        multiply=1
    [/damage]
#enddef
#define WEAPON_SPECIAL_SURPRISE
    [damage]
        id=surprise
        name= _ "surprise"
        description= _ "This attack deals 25% extra damage to enemies that are 5 or more tiles away at the beginning of its turn. Skilled at striking from afar, it catches distant foes off guard."
        special_note=_ "Solider, skilled at striking from afar, catches distant foes off guard, dealing some extra casualties."
        multiply=1.25
        active_on=offense
        [filter_self]
            formula="(if(self.wml_vars.side_turn_loc[0].x != null(),5 < distance_between(loc(self.wml_vars.side_turn_loc[0].x, self.wml_vars.side_turn_loc[0].y),loc(other.x,other.y)),1))"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_SHADOWSTRIKE
    [damage]
        id=shadowstrike
        name= _ "shadowstrike"
        female_name=_"female^shadowstrike"
        description= _ "#TODO"
        special_note=_ "#TODO"
        actiove_on=offense
        multiply=2
        [filter_self]
            formula="(self.wml_vars.started_invisible)"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_STAGGER
    [chance_to_hit] #TOD NOW should work
        id=stagger
        name= _ "stagger"
        female_name=_"female^stagger"
        description= _ "A precise strike that momentarily disrupts an opponent's combat effectiveness, reducing their counterattack accuracy by 30% for one strike. The sudden impact throws off muscle memory and spatial awareness, causing the target to lose their tactical focus at a critical moment."
        special_note=_ "Reduces target's counterattack accuracy by 30% for one strike."
        sub="(other.wml_vars.staggered)"
        actiove_on=defense
        apply_to=opponent
        #  [filter_opponent] #not needed
        #      formula="(self.wml_vars.staggered)"
        #  [/filter_opponent]
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_ALWAYS_HITS
    [chance_to_hit]
        id=always_hits
        name= _ "always hits"
        description= _ "This attack is always successful."
        special_note=_ "Some attacks of this unit never misses."
        value=100
        cumulative=no
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_KAMIKAZE
    [dummy]
        id=kamikaze
        name= _ "kamikaze"
        description=_"Unit dies while performing this attack."
        special_note=_"This unit can deliver critical blow, dying in the process."
    [/dummy]
#enddef
#define UNIT_SKIRIMSHER UNIT_FILTER
    [modify_unit]
        [filter]
            {UNIT_FILTER}
        [/filter]
        [object]
            silent=yes
            duration=turn end
            [effect]
                apply_to=new_ability
                [abilities]
                    [skirmisher]
                        id=skirmisher
                        name= _ "skirmisher"
                        female_name= _ "female^skirmisher"
                        description= _ "This unit is skilled in moving past enemies quickly, and ignores all enemy Zones of Control."
                        special_note={INTERNAL:SPECIAL_NOTES_SKIRMISHER}
                        affect_self=yes
                    [/skirmisher]
                [/abilities]
            [/effect]
        [/object]
        moves=$unit.max_moves
    [/modify_unit]
#enddef
#define ABILITY_ALCHEMIST
    [dummy]
        id=alchemist
        name= _ "alchemist"
        female_name= _ "female^alchemist"
        description=_ "This unit can create potions."
        special_note=_ "This unit can create potions."
    [/dummy]
#enddef
#define ABILITY_POTION_OF_HEALING
    [heals]
        value=8
        id=potion_of_healing
        affect_allies=yes
        name= _ "potion_of_healing +8"
        female_name= _ "female^potion_of_healing +8"
        description= _ "heals +8"
        affect_self=no
        poison=slowed
        [affect_adjacent]
        [/affect_adjacent]
    [/heals]
#enddef
#define ABILITY_POTION_OF_LEADING
    [leadership]
        id=potion_of_leading
        value="(25 * (level - other.level))"
        cumulative=no
        name= _ "potion_of_leading"
        female_name= _ "female^potion_of_leading"
        description= _ "This unit can lead other troops in battle.

All adjacent lower-level units from the same side deal 25% more damage for each difference in level."
        affect_self=no
        [affect_adjacent]
            [filter]
                formula="level < other.level"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef
#define IMPLEMENT_TITLES_FOR_CERTAIN_UNITS
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [filter]
            type=BfBH Skeleton Archer,BfBH Bone Shooter,BfBH Banebow,BfBH Skeleton,BfBH Revenant,BfBH Deathblade,BfBH Draug
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
skeleton_name = {}
skeleton_name["BfBH Skeleton Archer"] = "     💀🏹"
skeleton_name["BfBH Bone Shooter"] = "🗡️💀🏹"
skeleton_name["BfBH Banebow"] = "🗡️💀🏹"
skeleton_name["BfBH Skeleton"] = "🪓💀"
skeleton_name["BfBH Revenant"] = "🪓💀🛡️"
skeleton_name["BfBH Deathblade"] = "🪓💀🪓"
skeleton_name["BfBH Draug"] = "🛡️💀🪓"
unit.name=skeleton_name[unit.type]
>>
        [/lua]
    [/event]
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [variables]
                        necromancer_name=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local necromancers_table={"BfBH Dark Adept","BfBH Dark Sorcerer","BfBH Necromancer","BfBH Lich","BfBH Ancient Lich"}
local necromancers={}
--local function assign_titles(title, units)
for _, unit in ipairs(necromancers_table) do
    necromancers[unit] = true
end
--end
if necromancers[unit.type] then --Lichs
    if tostring(unit.name) == "" then
        if mathx.random() < 0.7 then --becouse males are superior XD
            unit.name = wesnoth.races["human"].male_name_gen()
        else
            unit.name = wesnoth.races["human"].female_name_gen()
        end
    end

local function transform_letters(name)
    name = custom_lower(name)
    local transformations = {
        {pattern = "a", replacement = "ae"},
        {pattern = "e", replacement = "y"},
        {pattern = "i", replacement = "y"},
        {pattern = "o", replacement = "ou"},
        {pattern = "u", replacement = "uu"},
        {pattern = "c", replacement = "k"},
        {pattern = "s", replacement = "z"},
        {pattern = "th", replacement = "tz"},
        {pattern = "w", replacement = "v"},
    }

    for i = #transformations, 2, -1 do
        local j = mathx.random(i)
        transformations[i], transformations[j] = transformations[j], transformations[i]
    end

    for i = 1, math.ceil(#transformations / 2) do
        local t = transformations[i]
        name = name:gsub(t.pattern, function(match)
            if mathx.random() < 0.5 then
                return t.replacement
            else
                return match
            end
        end)
    end

    return custom_upper(name:sub(1,1)) .. name:sub(2)
end

local function add_special_characters(name)
    name = custom_lower(name)
    local specialChars = {
        {char = "œ", replace = "oe"},
        {char = "æ", replace = "ae"},
        {char = "ø", replace = "o"},
        {char = "ñ", replace = "n"},
        {char = "ï", replace = "i"},
        {char = "ç", replace = "c"}
    }
    local numToAdd = mathx.random(0, 2)
    for i = 1, numToAdd do
        local try = 1
        ::try_again::
        local charIndex = mathx.random(#specialChars)
        local charInfo = specialChars[charIndex]
        local success = false
        name = name:gsub(charInfo.replace, function(match)
            if not success and mathx.random() < 0.5 then
                success = true
                return charInfo.char
            else
                return match
            end
        end)
        table.remove(specialChars, charIndex)
        if not success and try < 3 then
            try = try + 1
            goto try_again
        end
        if #specialChars == 0 then break end
    end
    return custom_upper(string.sub(name, 1, utf8.offset(name, 2) - 1)) .. string.sub(name, utf8.offset(name, 2))
end

local function split_name(name)
    local length = utf8.len(name)
    if length <= 4 then
        return name
    end

    local cutStart = mathx.random(4, length - 1)
    local cutEnd = mathx.random(cutStart, length - 1)

    local firstPartEnd = utf8.offset(name, cutStart) - 1
    local lastPartStart = utf8.offset(name, cutEnd + 1)

    local firstPart = name:sub(1, firstPartEnd)
    local lastPart = name:sub(lastPartStart)

    local firstCharLastPart = utf8.char(utf8.codepoint(lastPart, 1))
    return firstPart .. "-" .. custom_upper(firstCharLastPart) .. lastPart:sub(utf8.offset(lastPart, 2) or #lastPart + 1)
end

local function add_suffix(name)
    local suffixes = {"'x", "'th", "'yr", "'zh", "'q"}
    name = name .. suffixes[mathx.random(#suffixes)]
    return name
end

local function generate_necromancer_name(name)
    name = transform_letters(name)
    name = add_special_characters(name)

    if mathx.random() < 0.5 then
        name = split_name(name)
    end

    if mathx.random() < 0.5 then
        name = add_suffix(name)
    end
    return name
end
    unit.variables.necromancer_name = true
    unit.name = generate_necromancer_name(tostring(unit.name))
end
>>
        [/lua]
    [/event]
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if unit.variables.title_gained == nil then
    unit.variables.title_gained = 0
end
local title_gained = unit.variables.title_gained
-- table containing list of prefix+suffix Axewielder?, add more
-- #TODO change types to BfBH, add much more titles, for royal human gurad too?
local high_naga = {{'Serpent ',''},{'Asp Assassin ',''},{'',' Coiled'},{'Venom Figter ',''},{'',' Scaled'},{'',' Slither'},{'Cobra Fury ',''},{'Vortex Fury ',''},
{'',' Dead Hiss'},{'',' Sharptail'},{'Fanged ',''},{'',' Swift'}}
local titles = {
    high_human_leader = {{'Duke ',''},{'Sir ',''},{'Baron ',''},{'Lord ',''},{'Constable ',''},{'Knight ',''},{'Count ',''},{'Earl ',''},{'Marquis ',''},{'Viscount ',''}},
    high_human_foot = {{'',' the Stern'},{'Armor breaker ',''},{'',' Staunch'},{'',' Unyielding'},{'Implacable ',''},{'',' the Seasoned'},{'Master ',''},{'',' Resolute'},
    {'',' Vigilant'},{'',' the Unyielding'},{'',' Loyal'},{'Dauntless ',''},{'Valiant ',''}},
    high_human_paladin = {{'Saint ',''},{'','-Saint'},{'Divine ',''},{'Pious ',''},{'',' the Rider'},{'Mounted ',''},{'',' the Vanguard'},{'Holy ',''},{'','-Holy'},
    {'Lancelot ',''},{'Crusader ',''},{'',' Lionheart'},{'Sunrider ',''}},
    high_human_cavalery = {{'',' the Rider'},{'Mounted ',''},{'',' Flawless'},{'',' Nevermiss'},{'Zealous ',''},{'',' the Zealous'},{'Lancemaster ',''},{'',' Lancemaster'},
    {'Fearless ',''},{'',' Warhorse'},{'Deadly ',''}},
    high_human_javelineer = {{'Lithe-',''},{'',' the Unerring'},{'',' Skilled'},{'Swift ',''},{'',' the Quick'},{'Nimble ',''},{'',' Nimble'},{'Skirmisher ',''}},
    high_dwarf_melee = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Stone','Iron','Deep','Forge','Mountain','Beard','Gold','Rune','Clan','Cave','Anvil','Gem','Rock','Mithril','Ale','Battle','Earth','Tunnel','Shield','Ore','Crystal'}
                local second_part = {'heart','fist','beard','forge','delver','smith','miner','thane','kin','master','lord','breaker','carver','seeker','bane','keeper','guard','born','wise','hand','sworn'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then --Too few titles would repeat a lot
            --      return {{'',' Beardlord'},{'',' Gemstone Sovereign'},{'',' the Voluminous'}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_dwarf_ranged = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Boom','Bang','Gun','Fire','Lead','Shot','Blast','Sling','Spark'}
                local second_part = {'eye','shot','arm','bolt','hand','fuse','bang','blast'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then
            --      return {{'',''}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_dwarf_scout = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Swift','Keen','Track','Sneak','Spy','Stalk','Scout','Far'}
                local second_part = {'foot','eye','ear','nose','step','run','hide'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then
            --      return {{'',''}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_lich = {{'Lightbane ',''},{'Mercykiller ',''},{'Embalmer ',''},{'Gravedigger ',''},{'',''},{'',''}}, --TODO
    high_bandit = {
{'Black ',''},{'Grim ',''},{'One-eyed ',''},{'Ruthless ',''},{'Bloody ',''},{'Silent ',''},{'Cutthroat ',''},{'Raven ',''},{'Shadow ',''},{'Red ',''},
{'Scarred ',''},{'Savage ',''},{'Bonebreaker ',''},{'Stormcrow ',''},
{'Wolf-',''},{'Hawk-',''},{'Fox-',''},{'Night-',''},{'Rook-',''},{'Flint-',''},{'Claw-',''},
{'',' the Merciless'},{'',' Blackheart'},{'',' the Cunning'},{'',' Bloodfist'},{'',' the Shadowwalker'},{'',' Skullcrusher'},{'',' Ghostwalker'},{'',' the Dread'},
{'',' the Relentless'},{'',' Wolfsbane'},{'',' Blackheart'},{'',' Ravager'},{'',' the Unforgiving'},
{'','-Spite'},{'','-Thorn'}
    },
    high_naga_sword = tmerge(high_naga,{{'Twin Fang ',''},{'Slicer ',''},{'',' Whirlwind'},{'',' Fang Master'},{'Reaper ',''},{'',' Reaper'},{'Swordmaster ',''},
{'',' Swiftblade'},{'',' Forked Cutter'}}),
    high_naga_chakram = tmerge(high_naga,{{'Halo-',''},{'',' Ringwrath'},{'',' Orbweaver'},{'Discus-',''},{'',' Gyrator'},{'Chakra-',''},{'Circlet-',''},{'','Ringmaster'},
{'',' Spiraler'},{'',' Gyroclaw'},{'Ringcoil-',''},{'Flyblade-',''},{'','Flyblade'}}),
        high_naga_jarid = tmerge(high_naga,{{'',' Skewer'},{'',' Master Javelineer'},{'Master Hurler ',''},{'Spike-',''},{'',' Swiftstriker'},{'Barb-',''},{'',' Piercer'},
{'',' Whistler'},{'',' Supreme Flinger'},{'Quill-',''},{'',' Sharpquill'},{'Spire-',''},{'',' the Skirmisher'}}),
    high_goblin_wolf_pillager = {{'',' the Marauder'},{'Plunderer ',''},{'Ravager ',''},{'Reaver ',''},{'',' the Reaver'},{'Pillager ',''},{'',' the Pillager'},{'Raider ',''},
{'Snarer ',''},{'',' Snarer'},{'',' Goblin Scourger'},{'',' Embersnout'}},
    high_goblin_wolf_rider = {{'Razerwolf ',''},{'',' the Razerwolf'},{'Havocbringer ',''},{'',' the Havocbringer'},{'',' Dreadclaw'},{'',' Wailing'},{'',' Terrorhowl'},
{'Howlheart ',''},{'',' Fangflinger'},{'',' the Fangflinger'},{'Barkbiter ',''},{'','-Barkbiter'},{'Growlgutter ',''},{'',' Scruffscourge'}},
    high_spider = {{'Monster',''},{'Widowmaker',''},{'Mindtwister',''},{'Heartpiercer',''},{'Venom Hunter',''},{'Shadowstitcher',''},{'Quiet Death',''},{'Death',''},
{'Reaper',''},{'Corpse-Wrapper',''},{'Tapestry of Terror',''},{'Venom\'s Embrace',''},{'Dark Dead',''},{'Abomination',''},{'Hairy Horror',''},{'Widow\'s Embrace',''},
{'Eyes in the Dark',''},{'Thousand Legs',''},{'Blood Demon',''},{'Nightmare\'s Messenger',''},{'Shadowcreeper',''}},
    orcish_assassin_1={{'','krag'},{'','thak'},{'','mok'},{'','rakh'},{'','khor'},{'','gar'},{'','shik'},{'','nok'},{'','vex'},{'','zar'},{'','khal'},{'','thar'},
{'','loc'},{'','dex'},{'','vak'},{'','zul'},{'','mex'},{'','pex'},{'','kix'},{'','tox'},{'','ghor'},{'','mak'},{'','zak'},{'','vok'},{'','krak'}},
    orcish_assassin_2={{'Nok-',''},{'Shad-',''},{'Kro-',''},{'Viz-',''},{'Rix-',''},{'Mor-',''},{'Than-',''},{'Drak-',''},{'Kro-',''},{'Zar-',''},{'Vek-',''},
{'Thek-',''},{'Kor-',''},{'Mak-',''},{'Lok-',''},{'Vor-',''},{'Khal-',''},{'Thur-',''},{'Raz-',''},{'Morg-',''},{'Tox-',''},{'Kaz-',''},{'Riz-',''},{'Nak-',''},{'Vex-',''}},
saurian_skirmisher_1={
    {'','sith'},{'','zix'},{'','rax'},{'','kex'},{'','vix'},  -- swift movement
    {'','tix'},{'','nax'},{'','kss'},{'','skar'},{'','zak'},  -- hunting prowess
    {'','mura'},{'','slix'},{'','nex'},{'','rix'},{'','thex'},  -- environment mastery
    {'','kraz'},{'','thax'},{'','sax'},{'','vex'},{'','rith'}  -- combat excellence
},
saurian_skirmisher_2={
    {'Sith','',decap_first=true},{'Kra','',decap_first=true},{'Zex','',decap_first=true},{'Nix','',decap_first=true},{'Vra','',decap_first=true},  -- elite status
    {'Mur','',decap_first=true},{'Rax','',decap_first=true},{'Thex','',decap_first=true},{'Sli','',decap_first=true},{'Nex','',decap_first=true},  -- environment mastery
    {'Tix','',decap_first=true},{'Kex','',decap_first=true},{'Zar','',decap_first=true},{'Vix','',decap_first=true},{'Rix','',decap_first=true}  -- combat mastery
},
saurian_spearthrower_1={
    {'','thix'},{'','zar'},{'','kix'},{'','sax'},{'','nix'},  -- throwing precision
    {'','rax'},{'','tix'},{'','vex'},{'','kss'},{'','zix'},  -- hunting achievement
    {'','thax'},{'','mix'},{'','rix'},{'','lax'},{'','kex'},  -- kill special
    {'','sith'},{'','nax'},{'','vix'},{'','thex'},{'','rith'}  -- combat role
},
saurian_spearthrower_2={
    {'Tix','',decap_first=true},{'Zar','',decap_first=true},{'Kra','',decap_first=true},{'Nix','',decap_first=true},{'Vra','',decap_first=true},  -- master status
    {'Sax','',decap_first=true},{'Thex','',decap_first=true},{'Rix','',decap_first=true},{'Kex','',decap_first=true},{'Mur','',decap_first=true},  -- battle achievement
    {'Sith','',decap_first=true},{'Nex','',decap_first=true},{'Vix','',decap_first=true},{'Zex','',decap_first=true},{'Rax','',decap_first=true}  -- legendary feats
},

--sample={{'',''},{'',''}},
}
local title_assignments = {}
local function assign_titles(title_level,title, units)
    if not title_assignments[title_level] then
        title_assignments[title_level] = {}
    end
    for _, unit in ipairs(units) do
        title_assignments[title_level][unit] = title
    end
end
assign_titles(1,"high_human_leader", {"BfBH Lieutenant","BfBH General","BfBH Grand Marshal","BfBH Grand Knight"})
assign_titles(1,"high_human_foot", {"BfBH Master Bowman","BfBH Royal Guard","BfBH Halberdier"})
assign_titles(1,"high_human_cavalery", {"BfBH Lancer","BfBH Cavalier"})
assign_titles(1,"high_human_paladin", {"BfBH Paladin"})
assign_titles(1,"high_human_javelineer", {"BfBH Javelineer"})
assign_titles(1,"high_dwarf_melee", {"BfBH Dwarvish Lord","BfBH Dwarvish Runemaster","BfBH Dwarvish Arcanister","BfBH Dwarvish Sentinel"})
assign_titles(1,"high_dwarf_ranged", {"BfBH Dwarvish Dragonguard"})
assign_titles(1,"high_dwarf_scout", {"BfBH Dwarvish Explorer"})
assign_titles(1,"high_lich", {"BfBH Ancient Lich"})
assign_titles(1,"high_bandit", {"BfBH Highwayman","BfBH Ranger","BfBH Huntsman","BfBH Fugitive"})
assign_titles(1,"high_naga_sword", {"BfBH Naga Myrmidon"})
assign_titles(1,"high_naga_chakram", {"BfBH Naga Zephyr"})
assign_titles(1,"high_naga_jarid", {"BfBH Naga Sicarius"})
assign_titles(1,"high_goblin_wolf_pillager", {"BfBH Goblin Pillager"})
assign_titles(1,"high_goblin_wolf_rider", {"BfBH Direwolf Rider"})
assign_titles(1,"high_spider", {"BfBH Giant Spider"})
assign_titles(1,"orcish_assassin_1", {"BfBH Orcish Slayer","BfBH Orcish Nightblade"})
assign_titles(2,"orcish_assassin_2", {"BfBH Orcish Nightblade"})
assign_titles(1,"saurian_skirmisher_1", {"BfBH Saurian Ambusher","BfBH Saurian Flanker"})
assign_titles(2,"saurian_skirmisher_2", {"BfBH Saurian Flanker"})
assign_titles(1,"saurian_spearthrower_1", {"BfBH Saurian Spearthrower","BfBH Saurian Javelineer"})
assign_titles(2,"saurian_spearthrower_2", {"BfBH Saurian Javelineer"})
local function get_unit_title(title_level,type)
    return titles[title_assignments[title_level][type]] or false
end
local function lowercase_first(str)
    if str == "" then return str end
    local first = string.sub(str, 1, utf8.offset(str, 2) - 1)
    local rest = string.sub(str, utf8.offset(str, 2) or #str + 1)
    return custom_lower(first) .. rest
end
for i = title_gained + 1, #title_assignments, 1 do
    local title_table = get_unit_title(i,unit.type)
    if title_table then
        local title = title_table[mathx.random(#title_table)]
        ::move_layer_deeper::
        if type(title[1]) == "table" then
            title=title[mathx.random(#title)]
            goto move_layer_deeper
        end
        unit.variables.title_gained = unit.variables.title_gained+1
        local name = tostring(unit.name)
        std_print(tprint(title))
        if title.decap_first then
            name=lowercase_first(name)
        end
        unit.name = title[1] .. name .. title[2]
    end
end
>>
        [/lua]
    [/event]
#enddef
#define IMPLEMENT_ALCHEMIST
    [set_menu_item]
        id=potion_choose
        description= _ "potion selection"
        #[show_if]
            #[true]
            #[/true]
        #[/show_if]
        [filter_location]
            [filter]
                ability=alchemist
            [/filter]
        [/filter_location]
        [command]
            [message]
                speaker=$unit.id
                message= _ "What potion should I make?"
                [option]
                    label= _ "Potion of healing"
                    [command]
                        [modify_unit]
                            [filter]
                                id=$unit.id
                            [/filter]
                            role=going_to_make_potion_of_healing
                        [/modify_unit]
                    [/command]
                [/option]
                [option]
                    label= _ "Potion of leadership"
                    [command]
                        [modify_unit]
                            [filter]
                                id=$unit.id
                            [/filter]
                            role=going_to_make_potion_of_leading
                        [/modify_unit]
                    [/command]
                [/option]
            [/message]
        [/command]
    [/set_menu_item]
    [event]
        namen refresh
        first_time_only=no
        [modify_unit]
            [filter]
                #side=$side_number
                #ability=alchemist
            [/filter]
            [effect]
                apply_to=remove_ability
                [abilities]
                    id=potion_of_healing, potion_of_leading
                [/abilities]
            [/effect]
        [/modify_unit]
        [modify_unit]
            [filter]
                side=$side_number
                role=going_to_make_potion_of_healing
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_POTION_OF_HEALING}
                [/abilities]
            [/effect]
        [/modify_unit]
        [modify_unit]
            [filter]
                side=$side_number
                role=going_to_make_potion_of_leading
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_POTION_OF_LEADING}
                [/abilities]
            [/effect]
        [/modify_unit]
    [/event]
#enddef
#define IMPLEMENT_LOAD_COUNTER
    [event]
        name=new turn
        first_time_only=no
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=$turn_number
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
    [/event]
    [event]
        name=preload
        first_time_only=no
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable] ### MEANS IT'S NOT SCENARIO ONE FIRST EVER LOAD
                name=game_number
                not_equals=""
            [/variable]
            [and]
                [variable]
                    name=is_variable_created
                    not_equals=""
                [/variable]
            [/and]
            [then]
                [get_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_global=$turn_number
                    to_local=turn_load_count
                    side=1
                [/get_global_variable]
                [set_variable]
                    name=turn_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=turn_load_count
                    to_global=$turn_number
                    side=1
                    immediate=yes
                [/set_global_variable]
                {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number total_load_count total_load_count}
                [set_variable]
                    name=total_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number
                    from_local=total_load_count
                    to_global=total_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
                {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number scenario_load_count scenario_load_count}
                [set_variable]
                    name=scenario_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=scenario_load_count
                    to_global=scenario_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
                [if]
                    [variable]
                        name=show_load_counter_pop_ups
                        equals=yes
                    [/variable]
                    [then]
{SAVESCUM_MESSAGE savescum_2 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 2} _"Leave no man behind!" help/bandits_to_ghost.png _"Abandon timeline"
_"
Each reset abandons your crew to a
forgotten timeline.
Can you face the ghosts of
all companions you've erased?"}
{SAVESCUM_MESSAGE savescum_4 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 4} _"Harvest of Lost Futures" help/great_dark.png _"Reap the consequences"
_"
Every discarded path,
every erased moment,
feeds the hunger of
something unspeakable.

The dead grow restless."}
{SAVESCUM_MESSAGE savescum_6 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 6} _"The land remembers" help/wose_and_merman.png _"Face its wrath"
_"
Feel that chill?
The very earth growls with each retry.
Ancient forces stir,
and they're not looking to negotiate.

Fate's comming!"}
{SAVESCUM_MESSAGE savescum_8 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 8} _"Requiem of the Rewritten" help/skeletons.png _"Conduct the unmaking"
_"
Reality's cracks echo,
with forbidden knowledge.
Something ancient drinks deep,
from the abyss."}
{SAVESCUM_MESSAGE savescum_10 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 10} _"Echoes" help/dwarves_to_undead.png _"Listen to the void"
_"
Inhuman laughter resonates,
across timelines.
How many times have you heard it?
How many times will you,

untill it consumes you?"}
{SAVESCUM_MESSAGE savescum_12 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 12} _"Reflection of Entropy" help/broken_hourglass.png _"Shatter reality"
_"
Time bleeds through reality's wounds.
Every reset fractures the mirror of existence.

Something terrifying grows stronger with each drop."}

#  "The night holds many secrets. Some are best left undiscovered by meddling with time."

                        [event]
                            name=side turn,moveto,sighted,recruit,recall,attacker hits,attacker misses,defender hits,defender misses,last breath,die,side turn end,attack
                            first_time_only=no
                            id=savescum_load_messages
                            [if]
                                [variable]
                                    name=show_load_counter_pop_ups
                                    equals=yes
                                [/variable]
                                [then]
{SAVESCUM_MESSAGE savescum_1 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 1} _"Time's revenge" help/farm_ambush.png _"Pay the debt"
_"
With each manipulation,
you borrow from a debt,
you can't repay.
And time, friend,

is a most unforgiving collector."}
{SAVESCUM_MESSAGE savescum_3 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 3} _"Echoes of the forsaken" help/battle_for_castle.png _"Embrace oblivion"
_"
The men whisper of phantom pains,
memories of deaths undone.
How many times can you,
ask them to die,

for you?"}
{SAVESCUM_MESSAGE savescum_5 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 5} _"The Watching Dark" help/cave_march.png _"Step into shadows"
_"
Shadows flicker oddly in the torchlight.
Your men's eyes dart nervously.
The darkness remembers every time,
you've tried to cheat it.

It's patient.
It's hungry."}
{SAVESCUM_MESSAGE savescum_7 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 7} _"Glitter of Lost Futures" help/gold_hoard.png _"Count the cost"
_"
Your men cheer,
but the gold feels too heavy.
It pulls at you,
a gravitational mass of every reset,
every do-over.

The universe demands balance.
And you're in debt."}
{SAVESCUM_MESSAGE savescum_9 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 9} _"Ripples of Unmaking" help/hidden_in_village.png _"Drown in possibility"
_"
As your foes pass by,
reality shimmers.

You've lived this moment too many times.
The fabric of existence wears thin here.

Pray it doesn't tear..."}
{SAVESCUM_MESSAGE savescum_11 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 11} _"Sacrifice to Chaos" help/spider_fight.png _"Feed the madness"
_"
Your men flee as you battle the beast.
But in how many abandoned timelines
did they die here?

Their ghosts watch,
judging your cowardice across realities."}

#  "The night holds many secrets. Some are best left undiscovered by meddling with time."
#  Extended text:
#  The shadows that cloak your misdeeds are the same shadows that guard the mysteries of the world. As a bandit, you've learned to use the night as your ally, but have you considered that time itself might not be so forgiving of manipulation? Each attempt to rewrite your story sends ripples through the fabric of reality. The coins you steal today might be the ones that would have funded your future ally. The guard you avoid might have become a valuable informant. The failure you erase might have been the key to a greater success. The world of a bandit is one of delicate balance – between risk and reward, trust and betrayal, fate and free will. By constantly seeking to unveil the 'what ifs', you risk unraveling the very threads of your destiny. Some doors, once opened, can never be closed. Some knowledge, once gained, can never be unlearned. In your quest for the perfect heist, be wary of the price you might pay for peeking behind the curtain of time.

#  "True legends are forged in the fires of adversity, not in the shadows of forgotten timelines."
#  Extended text:
#  In the crucible of challenge, legends are born. Every great bandit tale, every whispered story of impossible heists and daring escapes, is built on a foundation of trials overcome and lessons hard-won. When you choose to rewrite your story, to hide from the consequences of your choices, you rob yourself of the very experiences that would temper your skills and sharpen your wit. Think of the greatest outlaws in history – they didn't achieve renown by playing it safe or always making the right choice. They became legends by facing impossible odds, by turning crushing defeats into unlikely victories, by learning from every misstep until they could dance through danger as easily as others walk down a street. The path of a true legend is not a straight line to glory, but a winding road of triumph and tribulation. Each time you erase a failure, you erase an opportunity to grow, to adapt, to become the stuff of legend. Will you hide in the shadows of 'what might have been', or will you stride boldly into the fires of adversity, ready to be forged into a legend that will echo through the ages?

#  "The best disguise is one of authenticity. Accept your path, twists and all."
#  Extended text:
#  In the world of subterfuge and deception that you inhabit, the concept of a 'perfect disguise' is alluring. But consider this – the most impenetrable façade is not one built on careful construction, but on genuine experience. Every scar, every callus, every hard-learned lesson etches itself into your very being, creating a persona that no amount of acting could replicate. When you constantly seek to erase your missteps, you're not perfecting your disguise – you're making it more hollow, more likely to crack under scrutiny. The guard who's faced real danger can spot a pretender. The merchant who's weathered true hardship can sense a fabricated tale. But the bandit who wears their full history, who has known both the dizzying heights of a perfect heist and the crushing lows of a plan gone awry? They can slip into any role because they've lived it all. Your path, with all its unexpected turns and harsh lessons, is what makes you unique, unpredictable, and ultimately, unstoppable. Will you embrace the rich tapestry of your experiences, allowing them to shape you into a master of adaptation? Or will you pursue a flawless but flat persona, always at risk of being seen for what you are – a counterfeit trying to pass as the genuine article?
                                [/then]
                            [/if]
                        [/event]
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
    [event]
        name=start
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=1
                    side=1
                    immediate=yes
                [/set_global_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=scenario_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number
            from_global=total_load_count
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number
                    from_local=variable_with_zero
                    to_global=total_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
    [/event]
#enddef
##define ABILITY_GOING_TO_MAKE_POTION_OF_HEALING
    #[dummy]
        #id=going_to_make_potion_of_healing
        #name=""
        #female_name=""
        #description=""
        #special_note=""
    #[/dummy]
##/enddef
##define ABILITY_GOING_TO_MAKE_POTION_OF_LEADING
    #[dummy]
        #id=going_to_make_potion_of_leading
        #name=""
        #female_name=""
        #description=""
        #special_note=""
    #[/dummy]
##/enddef
##define ABILITY_POTION_OF_LEADING
    #[leadership]
        #id=potion_of_leading
        #value="(25 * (level - other.level))"
        #cumulative=no
        #name= _ "potion_of_leading"
        #female_name= _ "female^potion_of_leading"
        #description= _ "This unit can lead other troops in battle.

#All adjacent lower-level units from the same side deal 25% more damage for each difference in level."
        #affect_self=no
        #[affect_adjacent]
            #[filter]
                #formula="level < other.level"
            #[/filter]
        #[/affect_adjacent]
    #[/leadership]
##/enddef
##define IMPLEMENT_ALCHEMIST
    #[set_menu_item]
        #id=potion_choose
        #description= _ "potion selection"
        ##[show_if]
            ##[true]
            ##[/true]
        ##[/show_if]
        #[filter_location]
            #[filter]
                #ability=alchemist
            #[/filter]
        #[/filter_location]
        #[command]
            #[message]
                #speaker=$unit.id
                #message= _ "What potion should I make?"
                #[option]
                    #label= _ "Potion of healing"
                    #[command]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=remove_ability
                                #[abilities]
                                    #id=going_to_make_potion_of_leading
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=new_ability
                                #[abilities]
                                    #{ABILITY_GOING_TO_MAKE_POTION_OF_HEALING}
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                    #[/command]
                #[/option]
                #[option]
                    #label= _ "Potion of leadership"
                    #[command]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=remove_ability
                                #[abilities]
                                    #id=going_to_make_potion_of_healing
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=new_ability
                                #[abilities]
                                    #{ABILITY_GOING_TO_MAKE_POTION_OF_LEADING}
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                    #[/command]
                #[/option]
            #[/message]
        #[/command]
    #[/set_menu_item]
    #[event]
        #name=turn refresh
        #first_time_only=no
        #[modify_unit]
            #[filter]
                #ability=alchemist
            #[/filter]
            #[effect]
                #apply_to=remove_ability
                #[abilities]
                    #id=potion_of_healing,potion_of_leading
                #[/abilities]
            #[/effect]
        #[/modify_unit]
        #[modify_unit]
            #[filter]
                #ability=going_to_make_potion_of_healing
            #[/filter]
            #[effect]
                #apply_to=new_ability
                #[abilities]
                    #{ABILITY_POTION_OF_HEALING}
                #[/abilities]
            #[/effect]
        #[/modify_unit]
        #[modify_unit]
            #[filter]
                #ability=going_to_make_potion_of_leading
            #[/filter]
            #[effect]
                #apply_to=new_ability
                #[abilities]
                    #{ABILITY_POTION_OF_LEADING}
                #[/abilities]
            #[/effect]
        #[/modify_unit]
    #[/event]
##/enddef

#### FINDS CLOSEST ENEMY

#{VARIABLE max_radius 50}
                #{VARIABLE radius 0}
                #{VARIABLE bombard_targets 0}
                #[while]
                    #[variable]
                        #name=bombard_targets
                        #equals=0
                    #[/variable]
                    #[and]
                        #[variable]
                            #name=radius
                            #less_than_equal_to=$max_radius
                        #[/variable]
                    #[/and]
                    #[do]
                        #[if]
                            #[have_unit]
                                #side=1
                                #[filter_location]
                                    #x=$dwarvish_cannoner[$i].x
                                    #y=$dwarvish_cannoner[$i].y
                                    #radius=$radius
                                #[/filter_location]
                            #[/have_unit]
                            #[then]
                                #[store_unit]
                                    #[filter]
                                        #side=1
                                        #[filter_location]
                                            #x=$dwarvish_cannoner[$i].x
                                            #y=$dwarvish_cannoner[$i].y
                                            #radius=$radius
                                        #[/filter_location]
                                    #[/filter]
                                    #variable=bombard_targets
                                #[/store_unit]
                            #[/then]
                        #[/if]
                        #{VARIABLE_OP radius add 1}
                    #[/do]
                #[/while]
