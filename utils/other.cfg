#textdomain wesnoth-Bandits_from_Brown_Hills

#define REDRAW
    [redraw][/redraw]
#enddef
#define SET_GLOBAL_VARIABLE NAMESPACE VARNAME LOCAL VALUE
    [set_variable]
        name={LOCAL}
        value={VALUE}
    [/set_variable]

    [set_global_variable]
        namespace={NAMESPACE}
        from_local={LOCAL}
        to_global={VARNAME}
        side=1
        immediate=yes
    [/set_global_variable]
    {CLEAR_VARIABLE global_tmp}
#enddef
#define GET_GLOBAL_VARIABLE NAMESPACE VARNAME LOCAL
    [get_global_variable]
        namespace={NAMESPACE}
        from_global={VARNAME}
        to_local={LOCAL}
        side=1
    [/get_global_variable]
#enddef
#define SAVESCUM_MESSAGE ID CONDITION TITLE IMAGE SUBMIT_TEXT MESSAGE
    {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.dialogs {ID} dialog_tmp_get_{ID}}
    [if] {VARIABLE_CONDITIONAL dialog_tmp_get_{ID} not_equals yes}
        [and] {CONDITION} [/and]
        [then]
            {SET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.dialogs {ID} dialog_tmp_set_{ID} yes}
            [display_tip]
                title={TITLE}
                image={IMAGE}
                message={MESSAGE}
                submit_text={SUBMIT_TEXT}
            [/display_tip]
        [/then]
    [/if]
    {CLEAR_VARIABLE dialog_tmp_set_{ID},dialog_tmp_get_{ID}}
#enddef
#define CANCELLED_ATTACK_FILTER
    [and]
        [variable]
            name=attack_was_cancelled
            equals=no
        [/variable]
    [/and]
#enddef
#define IMPLEMENT_UNWALKABLE_VISION_COST
[event]
    name=unit placed
    first_time_only=no
    [filter]
        side=1
    [/filter]
    [object]
        silent=yes
        id=unwalkable_vision_costs_2
        take_only_once=no
        [filter]
            x,y=$x1,$y1
            [not]
                [filter_wml]
                    [modifications]
                        [object]
                            id="unwalkable_vision_costs_2"
                        [/object]
                    [/modifications]
                [/filter_wml]
            [/not]
        [/filter]
        [effect]
            apply_to=vision_costs
            replace=yes
            [vision_costs]
                unwalkable=2
            [/vision_costs]
        [/effect]
    [/object]
[/event]
#enddef
#define IMPLEMENT_DWARVISH_CANNONER_ENEMY_ONLY
    [event]
        name=turn refresh
        first_time_only=no
        [store_unit]
            [filter]
                side=$side_number
                type=Dwarvish Cannoner
            [/filter]
            variable=dwarvish_cannoner
        [/store_unit]
        [foreach]
            array=dwarvish_cannoner
            [do]
                {CLEAR_VARIABLE bombard_targets}
                {VARIABLE radius 50}
                [store_unit]
                    [filter]
                        side=1
                        [filter_location]
                            x=$dwarvish_cannoner[$i].x
                            y=$dwarvish_cannoner[$i].y
                            radius=$radius
                        [/filter_location]
                    [/filter]
                    variable=bombard_targets
                [/store_unit]
                {VARIABLE lua_line_of_sight_start_x $dwarvish_cannoner[$i].x}
                {VARIABLE lua_line_of_sight_start_y $dwarvish_cannoner[$i].y}
                {VARIABLE lua_line_of_sight_blocking_terrains X} # TODO filter it better
                {VARIABLE bombard_targets_adjecent_units_count -1}
                [for]
                    start=$($bombard_targets.length - 1)
                    step=-1
                    variable=i2
                    end=0
                    [do]
                        {VARIABLE lua_line_of_sight_end_x $bombard_targets[$i2].x}
                        {VARIABLE lua_line_of_sight_end_y $bombard_targets[$i2].y}
                        [lua]
                            code="wesnoth.dofile '~add-ons/Bandits_from_Brown_Hills/lua/is_line_of_sight_blocked.lua'"
                        [/lua]
                        [if]
                            [variable]
                                name=is_line_of_sight_blocked
                                equals=yes
                            [/variable]
                            [or]
                                [variable]
                                    name=bombard_targets[$i2].id
                                    equals=$last_bombarded_unit_id
                                [/variable]
                            [/or]
                            [then]
                                {CLEAR_VARIABLE bombard_targets[$i2]}
                            [/then]
                            [else]
                                [store_unit]
                                    [filter]
                                        [not]
                                            x,y=$bombard_targets[$i2].x, $bombard_targets[$i2].y
                                        [/not]
                                        [filter_location]
                                            x,y=$bombard_targets[$i2].x, $bombard_targets[$i2].y
                                            radius=1
                                        [/filter_location]
                                        [filter_side]
                                            [enemy_of]
                                                side=$dwarvish_cannoner[$i].side
                                            [/enemy_of]
                                        [/filter_side]
                                    [/filter]
                                    variable=bombard_targets_adjecent_units
                                [/store_unit]
                                [if]
                                    [variable]
                                        name=bombard_targets_adjecent_units_count
                                        less_than=$bombard_targets_adjecent_units.length
                                    [/variable]
                                    [then]
                                        {VARIABLE bombard_targets_adjecent_units_count $bombard_targets_adjecent_units.length}
                                    [/then]
                                    [else]
                                        {CLEAR_VARIABLE bombard_targets[$i2]}
                                    [/else]
                                [/if]
                            [/else]
                        [/if]
                    [/do]
                [/for]
                [if]
                    [variable]
                        name=bombard_targets[0].id
                        not_equals=""
                    [/variable]
                    [then]
                        {VARIABLE last_bombarded_unit_id $bombard_targets[0].id}
                        [if]
                            [have_unit]
                                x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                [filter_vision]
                                    side=1
                                [/filter_vision]
                            [/have_unit]
                            [then]
                                [scroll_to]
                                    x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                [/scroll_to]
                                [modify_unit]
                                    [filter]
                                        x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                                    [/filter]
                                    [status]
                                        cannon_empty=yes
                                    [/status]
                                [/modify_unit]
                                [delay]
                                    time=500
                                    accelerate=no
                                [/delay]
                            [/then]
                        [/if]
                        ###TODO if seen animate the unit, first bombard-> message jareth, hitted unit, if survived and one other unit
                        [modify_unit]
                            [filter]
                                x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                            [/filter]
                            moves=0
                        [/modify_unit]
                        [scroll_to]
                            x,y=$bombard_targets[0].x, $bombard_targets[0].y
                        [/scroll_to]
                        [store_unit]
                            variable=bombard_secondary_targets
                            [filter]
                                [not]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                [/not]
                                [filter_location]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                    radius=1
                                [/filter_location]
                            [/filter]
                        [/store_unit]
                        [remove_time_area] #attack destruct torches on main tile
                            id="torch_$bombard_targets[0].x|_$bombard_targets[0].y"
                        [/remove_time_area]
                        [terrain]
                            x,y=$bombard_targets[0].x, $bombard_targets[0].y
                            layer=overlay
                            terrain=""
                        [/terrain]
                        [if]
                            [have_location]
                                x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                [not]
                                    terrain=W*^*,S*^*,
                                [/not]
                            [/have_location]
                            [then]
                                [terrain]
                                    x,y=$bombard_targets[0].x, $bombard_targets[0].y
                                    terrain=^Dr
                                    layer=overlay
                                [/terrain]
                            [/then]
                        [/if]
                        [redraw]
                            side=1
                        [/redraw]
                        [sound]
                            name=explosion.mp3
                        [/sound]
                        [lua]
                            code=<<
--making vars , v for shorter code
local v=wml.variables
local kill_list={}
local kill_list_count=0
local primary_medium_damage=20
local secondary_medium_damage=10
local second_unit = wesnoth.units.get(v["dwarvish_cannoner["..v["i"].."].id"])

--random damage generation, replay friendly
wml.fire("set_variable", { name = "primary_raw_damage", rand = string.format("%d..%d", (primary_medium_damage - 10), (primary_medium_damage + 10)) })
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    wml.fire("set_variable", { name = "secondary_raw_damage["..i.."].d", rand = string.format("%d..%d", (secondary_medium_damage - 5), (secondary_medium_damage + 5)) })
end

--explosion
wesnoth.interface.add_hex_overlay(v["bombard_targets[0].x"], v["bombard_targets[0].y"], {halo="projectiles/fireball-impact-[1~16].png~SCALE(200,300), misc/blank-hex.png:[60*16,999999]"})

--defend animation and damage numbers
local animation=wesnoth.units.create_animator()
unit_to_animate=wesnoth.units.get(v["bombard_targets[0].x"], v["bombard_targets[0].y"])
real_damage=math.floor(v["primary_raw_damage"]*(100-wesnoth.units.resistance_against(unit_to_animate, "fire"))/100)
animation:add(unit_to_animate, "defend", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
wesnoth.interface.float_label(v["bombard_targets[0].x"], v["bombard_targets[0].y"], "<span color='red'>"..real_damage.."</span>")
if real_damage>=v["bombard_targets[0].hitpoints"] then
    kill_list_count=kill_list_count+1
    kill_list[kill_list_count]=unit_to_animate
end
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    unit_to_animate=wesnoth.units.get(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"])
    real_damage=math.floor(v["secondary_raw_damage["..i.."].d"]*(100-wesnoth.units.resistance_against(unit_to_animate, "fire"))/100)
    animation:add(unit_to_animate, "defend", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
    wesnoth.interface.float_label(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"], "<span color='red'>"..real_damage.."</span>")
    if real_damage>=v["bombard_secondary_targets["..i.."].hitpoints"] then
        kill_list_count=kill_list_count+1
        kill_list[kill_list_count]=unit_to_animate
    end
end
animation:run()
animation:clear()

-- deal damage to all units
unit_to_damage=wesnoth.units.get(v["bombard_targets[0].x"], v["bombard_targets[0].y"])
real_damage=math.floor(v["primary_raw_damage"]*(100-wesnoth.units.resistance_against(unit_to_damage, "fire"))/100)
unit_to_damage.hitpoints=unit_to_damage.hitpoints-real_damage
local animation=wesnoth.units.create_animator()
for i = 0, (v["bombard_secondary_targets.length"] - 1 ) do
    unit_to_damage=wesnoth.units.get(v["bombard_secondary_targets["..i.."].x"], v["bombard_secondary_targets["..i.."].y"])
    real_damage=math.floor(v["secondary_raw_damage["..i.."].d"]*(100-wesnoth.units.resistance_against(unit_to_damage, "fire"))/100)
    unit_to_damage.hitpoints=unit_to_damage.hitpoints-real_damage
end

--animate death
for k,unit_to_die in pairs(kill_list) do
    unit_to_die.hitpoints=0
    animation:add(unit_to_die, "death", "hit",{with_bars = false, primary = second_unit.attacks["cannon"], secondary = second_unit.attacks["cannon"]})
end
animation:run()
animation:clear()

--kill units
for k,unit_to_die in pairs(kill_list) do
    wesnoth.wml_actions.kill { id = unit_to_die.id, animate = false, fire_event = true}
end
                            >>
                        [/lua]
                        [delay]
                            time=100
                        [/delay]
                        [delay]
                            time=2000
                        [/delay]
                        [lua]
                            code=<<
local v=wml.variables
wesnoth.interface.remove_hex_overlay(v["bombard_targets[0].x"], v["bombard_targets[0].y"], {halo="projectiles/fireball-impact-[1~16].png~SCALE(200,300), misc/blank-hex.png:[60*16,999999]"})
                            >>
                        [/lua]
                    [/then]
                    [else]
                        {VARIABLE last_bombarded_unit_id 0}
                    [/else]
                [/if]
            [/do]
        [/foreach]
        [foreach]
            array=dwarvish_cannoner
            [do]
                [modify_unit]
                    [filter]
                        x,y=$dwarvish_cannoner[$i].x,$dwarvish_cannoner[$i].y
                    [/filter]
                    [status]
                        cannon_empty=no
                    [/status]
                [/modify_unit]
            [/do]
        [/foreach]
    [/event]
#enddef
#define IMPLEMENT_DWARVEN_MAGIC_ITEM_DROPPABLE
    [switch]
        variable=dwarven_magic_item
        [case]
            value="Boots of speed"
            {GLOBAL__DROPPABLE_BOOTS_OF_SPEED boots_of_speed_dwarven_leader}
        [/case]
        [case]
            value="Breastplate of the mighty"
            {GLOBAL__DROPPABLE_BREASTPLATE_OF_THE_MIGHTY breastplate_of_the_mighty_dwarven_leader}
        [/case]
        [case]
            value="Diadem of intelligence"
            {GLOBAL__DROPPABLE_DIADEM_OF_INTELLIGENCE diadem_of_intelligence_dwarven_leader}
        [/case]
        [case]
            value="Ring of strengt"
            {GLOBAL__DROPPABLE_RING_OF_STRENGT ring_of_strengt_dwarven_leader}
        [/case]
        [case]
            value="Huntsmans hat"
            {GLOBAL__DROPPABLE_HUNTSMANS_HAT huntsmans_hat_dwarven_leader}
        [/case]
        [case]
            value="Ankh"
            {GLOBAL__DROPPABLE_ANKH ankh_dwarven_leader}
        [/case]
    [/switch]
#enddef
#define BLEEDING_OBJECT
        [object]
            silent=yes
            duration=scenario
            id=bleeding_object
            take_only_once=no
            [effect]
                apply_to=image_mod
                replace="CS(50,0,0)"
            [/effect]
            [effect]
                apply_to=movement
                increase="-2"
            [/effect]
            [effect]
                apply_to=attack
                increase_damage="-15%"
            [/effect]
        [/object]
    #enddef
#define IMPLEMENT_ABILITIES_CUSTOM
    [event]
        name=preload
        first_time_only=no
        [lua]
            [args]
                [abilities]
                    {ABILITY_LONE_WOLF}
                    {ABILITY_MARK}
                    {ABILITY_FLEE}
                    {ABILITY_DISENGAGE}
                [/abilities]
                [specials]
                    {WEAPON_SPECIAL_CRIPPLING_BLOW}
                    {WEAPON_SPECIAL_MARK}
                [/specials]
            [/args]
            code = <<
local abilities = {}
local specials= {}
local args = wml.tovconfig(...)
local abilities_vconfig = wml.tovconfig(wml.get_child(args, "abilities"))
local specials_vconfig = wml.tovconfig(wml.get_child(args, "specials"))
local i = 1
while abilities_vconfig[i] do
    abilities[abilities_vconfig[i][2].id] = {
        id = abilities_vconfig[i][2].id,
        wml.tag.effect {
            apply_to = "new_ability",
            wml.tag.abilities {
                wml.tag[abilities_vconfig[i][1]](abilities_vconfig[i][2])
            }
        }
    }
    i = i + 1
end
i = 1
while specials_vconfig[i] do
    specials[specials_vconfig[i][2].id] = {
        id = specials_vconfig[i][2].id,
        wml.tag.effect {
            apply_to = "attack",
            wml.tag.set_specials {
                mode = "append",
                wml.tag[specials_vconfig[i][1]](specials_vconfig[i][2])
            }
        }
    }
    i = i + 1
end
BfBH.reanimated.base_unit_functions = {
    [""] = function(unit)
        std_print("No base unit found, this ability needs a little bit of extra attention for evey unit tree.")
    end,
    ["BfBH Footpad"] = function(unit)
        unit:add_modification("object", abilities["flee"])
    end,
    ["BfBH Outlaw"] = function(unit)
        unit:add_modification("object", abilities["disengage"])
    end,
    ["BfBH Thug"] = function(unit)
        unit:add_modification("object", specials["crippling_blow"])
    end,
    ["BfBH Bandit"] = function(unit)

    end,
    ["BfBH Poacher"] = function(unit)
        unit:add_modification("object", abilities["lone_wolf"])
    end,
    ["BfBH Trapper"] = function(unit)
        unit:add_modification("object", abilities["mark"])
        unit:add_modification("object", specials["mark"])
    end
}
BfBH.reanimated.base_units = {
    ["BfBH Walking Corpse"] = {"BfBH Footpad", "BfBH Thug", "BfBH Poacher", "BfBH Goblin Spearman", "BfBH Spearman"},
    ["BfBH Soulless"] = {"BfBH Outlaw", "BfBH Bandit", "BfBH Trapper"}
}
BfBH.unit_tree.move_down = {}
for k,unit in pairs(wesnoth.unit_types) do
	for i = 1, #unit.advances_to do
        BfBH.unit_tree.move_down[unit.advances_to[i]] = BfBH.unit_tree.move_down[unit.advances_to[i]] or {}
        table.insert(BfBH.unit_tree.move_down[unit.advances_to[i]], k)
    end
end
            >>
        [/lua]
    [/event]
    [event]
        name=prestart
        id=kamikaze_event
        {VARIABLE attack_was_cancelled no}
    [/event]
    [event]
        name=attack_end
        id=kamikaze_event
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=kamikaze
        [/filter_attack]
        [kill]
            x,y=$x1,$y1
            animate=no
            fire_event=yes
        [/kill]
    [/event]
    [event]
        name=attacker_hits, attacker_misses, attack
        id=critical_attack
        first_time_only=no
        [filter_attack]
            special_id=critical
        [/filter_attack]
        {VARIABLE_OP critical_random rand "1..100"}
        [if]
            [variable]
                name=critical_random
                less_than=11
            [/variable]
            [then]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
            [else]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/else]
        [/if]
    [/event]
    [event]
        name=defender_hits, defender_misses, attack
        id=critical_defend
        first_time_only=no
        [filter_second_attack]
            special_id=critical
        [/filter_second_attack]
        {VARIABLE_OP critical_random rand "1..100"}
        [if]
            [variable]
                name=critical_random
                less_than=11
            [/variable]
            [then]
                [lua]
                    code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
            [else]
                [lua]
                    code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/else]
        [/if]
    [/event]
    [event]
        name=attack_end
        id=critical_attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=critical
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        id=critical_defend_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second_attack]
            special_id=critical
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.critical = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=surprise_event
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{{"has_attack",{special_id = "surprise"}},{"or",{ability="stonefoot"}}}}})
for _,u in ipairs(units) do
    u.variables.side_turn_loc={x=u.x,y=u.y,loc=u.loc}
end
>>
        [/lua]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        id=corrode_event_attack
        [filter_attack]
            special_id=corrode
        [/filter_attack]
        [filter_second]
            [not]
                ability=corroded
            [/not]
        [/filter_second]
        [modify_unit]
            [filter]
                x=$x2
                y=$y2
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [unit_overlay]
            x,y=$x2,$y2
            ability=corroded
            image="overlays/corrode.png"
        [/unit_overlay]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        id=corrode_event_defend
        [filter_second_attack]
            special_id=corrode
        [/filter_second_attack]
        [filter]
            [not]
                ability=corroded
            [/not]
        [/filter]
        [modify_unit]
            [filter]
                x=$x1
                y=$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [unit_overlay]
            x,y=$x1,$y1
            ability=corroded
            image="overlays/corrode.png"
        [/unit_overlay]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=corrode_event_village
        [store_locations]
            [filter]
                side=$side_number
                ability=corroded
            [/filter]
            terrain=*^V*
            variable=uninjure_by_village_on
            mode=append
        [/store_locations]
        {VARIABLE i 0}
        [while]
            [variable]
                name=i
                less_than=$uninjure_by_village_on.length
            [/variable]
            [do]
                [store_unit]
                    [filter]
                        x=$uninjure_by_village_on[$i].x
                        y=$uninjure_by_village_on[$i].y
                    [/filter]
                    variable=uninjure_by_healing_on
                    mode=append
                [/store_unit]
                [set_variable]
                    name=i
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE i}
        {VARIABLE j 0}
        [while]
            [variable]
                name=j
                less_than=$uninjure_by_healing_on.length
            [/variable]
            [do]
                [unstore_unit]
                    variable=uninjure_by_healing_on[$j]
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    [/filter]
                    [effect]
                        apply_to=remove_ability
                        [abilities]
                            {ABILITY_CORRODED}
                        [/abilities]
                    [/effect]
                [/modify_unit]
                [remove_unit_overlay]
                    x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    image="overlays/corrode.png"
                [/remove_unit_overlay]
                [animate_unit]
                    flag=healed
                    [filter]
                        x,y=$uninjure_by_healing_on[$j].x,$uninjure_by_healing_on[$j].y
                    [/filter]
                    text= _ "armor repaired"
                    red=200
                    green=0 ###TODO # TODO #TODO
                    blue=200
                [/animate_unit]
                [set_variable]
                    name=j
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE j}
        {CLEAR_VARIABLE uninjure_by_healing_on}
        {CLEAR_VARIABLE uninjure_by_village_on}
    [/event]
    [event]
        name=pre advance
        first_time_only=no
        id=corrode_event_advance
        [filter]
            ability=corroded
        [/filter]
        [modify_unit]
            [filter]
                x,y=$unit.x,$unit.y
            [/filter]
            [effect]
                apply_to=remove_ability
                [abilities]
                    {ABILITY_CORRODED}
                [/abilities]
            [/effect]
        [/modify_unit]
        [remove_unit_overlay]
            x,y=$unit.x,$unit.y
            image="overlays/corrode.png"
        [/remove_unit_overlay]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=hit_and_run
        [/filter_attack]
        {UNIT_SKIRIMSHER x,y=$x1,$y1}
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            ability=endurance
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if u_table.hitpoints == u_table.max_hitpoints then
    variables.endurance = true
else
    variables.endurance = false
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second]
            ability=endurance
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if u_table.hitpoints == u_table.max_hitpoints then
    variables.endurance = true
else
    variables.endurance = false
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender_hits
        first_time_only=no
        [filter]
            ability=endurance
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
if unit.hitpoints <= 0 and unit.variables.endurance then unit.hitpoints = 1 end
>>
        [/lua]
    [/event]
    [event]
        name=attacker_hits
        first_time_only=no
        [filter_second]
            ability=endurance
        [/filter_second]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if unit.hitpoints <= 0 and unit.variables.endurance then unit.hitpoints = 1 end
>>
        [/lua]
    [/event]
    [event]
        name=pre attack
        first_time_only=no
        priority=1000
        [filter_condition]
            [not]
                [variable]
                    name=living_shield.length
                    greater_than=0
                [/variable]
            [/not]
        [/filter_condition]
        [filter]
            [filter_adjacent]
                is_enemy=yes
                ability=living_shield
            [/filter_adjacent]
        [/filter]
        [filter_second]
            [filter_adjacent]
                is_enemy=no
                ability=living_shield
            [/filter_adjacent]
        [/filter_second]
        [store_unit]
            [filter]
                ability=living_shield
                [filter_adjacent]
                    x,y=$unit.x,$unit.y
                    is_enemy=yes
                [/filter_adjacent]
                [and]
                    [filter_adjacent]
                        x,y=$second_unit.x,$second_unit.y
                        is_enemy=no
                        [and]
                            formula="level > other.level"
                            [or]
                                formula="level = other.level"
                                [not]
                                    ability=living_shield
                                [/not]
                            [/or]
                        [/and]
                    [/filter_adjacent]
                [/and]
            [/filter]
            variable=living_shield
        [/store_unit]
        [if]
            [variable]
                name=living_shield.length
                greater_than=0
            [/variable]
            [then]
                [lua]
                    code=<<
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
wml.variables["attacking_weapon_index"] = i
attacker = wesnoth.units.get(wml.variables["unit[0].id"])
defender = wesnoth.units.get(wml.variables["living_shield[0].id"])
local _,_,_,defender_stats = wesnoth.simulate_combat(attacker, i + 1, defender)
wml.variables["defending_weapon_index"] = defender_stats.attack_num
>>
                [/lua]
                [cancel_action]
                [/cancel_action]
                [do_command]
                    [attack]
                        [source]
                            x,y=$x1,$y1
                        [/source]
                        [destination]
                            x,y=$living_shield.x,$living_shield.y
                        [/destination]
                        weapon=$attacking_weapon_index
                        defender_weapon=$defending_weapon_index
                    [/attack]
                [/do_command]
                {VARIABLE attack_was_cancelled yes}
            [/then]
        [/if]
        {CLEAR_VARIABLE living_shield,attacking_weapon_index,defending_weapon_index}
    [/event]
    [event]
        priority=-10000
        name=attack_end
        first_time_only=no
        {VARIABLE attack_was_cancelled no}
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            ability=adaptive_armor
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.adaptive_armor = wml.variables["second_weapon"].type
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=mark
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.marked_unit = wml.variables["second_unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        priority=900
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            ability=disengage
            [not]
                [filter_wml]
                    moves=$this_unit.max_moves
                [/filter_wml]
            [/not]
        [/filter]
        {VARIABLE unit.moves 0}
        [unstore_unit]
            variable=unit
            find_vacant=no
        [/unstore_unit]
    [/event]
    [event]
        id=ability_desperate_dodge_event_1
        name=attack, attacker_misses, attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second]
            ability=desperate_dodge
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_2
        name=attack, defender_misses, attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            ability=desperate_dodge
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_3
        name=attacker_hits
        first_time_only=no
        [filter_second]
            ability=desperate_dodge
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = (20 + variables.desperate_dodge)
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        id=ability_desperate_dodge_event_4
        name=defender_hits
        first_time_only=no
        [filter]
            ability=desperate_dodge
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.desperate_dodge = (20 + variables.desperate_dodge)
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=die
        priority=-1000
        first_time_only=no
        [filter]
            [not]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
            [/not]
            [not]
                formula="self.undead"
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=plague
        [/filter_second_attack]
        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=reanimated_unit
        [/store_unit]
        [kill]
            x,y=$x1,$y1
        [/kill]
        [unit]
            type=BfBH Walking Corpse
            x,y=$x1,$y1
            side=$second_unit.side
            variation=$reanimated_unit.undead_variation
            animate=yes
            attacks_left=0
            moves=0
            [variables]
                reanimated_unit_type=$reanimated_unit.type
            [/variables]
        [/unit]
    [/event]
    [event]
        name=unit_placed
        first_time_only=no
        [filter]
            type=BfBH Walking Corpse, BfBH Soulless
            [filter_condition]
                [not]
                    [variable]
                        name=this_unit.variables.reanimated_gained_as
                        contains=$this_unit.type
                    [/variable]
                [/not]
            [/filter_condition]
        [/filter]
        [modify_unit] #just so one can see the ability in the unit_type and also checks if unit got this already
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object]
                id=hide_reanimated
                take_only_once=no
                silent=yes
                [effect]
                    apply_to=remove_ability
                    [experimental_filter_ability]
                        [reanimated]
                        [/reanimated]
                    [/experimental_filter_ability]
                [/effect]
            [/object]
        [/modify_unit]
        [lua]
            code = <<
local ecx = wesnoth.current.event_context
local unit = wesnoth.units.get(ecx.x1, ecx.y1)
if unit.type == "BfBH Soulless" then --this relies to the fact I have two zombies, needs brush off if more are going to be added (or more these units)
    BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", "BfBH Walking Corpse")
    BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units["BfBH Walking Corpse"]))](unit)
end
BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", unit.type)
BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
            >>
        [/lua]
    [/event]
    [event]
        name=post_advance
        first_time_only=no
        [filter]
            type=BfBH Walking Corpse, BfBH Soulless
            [filter_condition]
                [not]
                    [variable]
                        name=this_unit.variables.reanimated_gained_as
                        contains=$this_unit.type
                    [/variable]
                [/not]
            [/filter_condition]
        [/filter]
        [lua]
            code = <<
local ecx = wesnoth.current.event_context
local unit = wesnoth.units.get(ecx.x1, ecx.y1)
BfBH.unit.variables.add_to_list(unit, "reanimated_gained_as", unit.type)
BfBH.reanimated.base_unit_functions[BfBH.reanimated.get_random_element(BfBH.reanimated.get_base_units_bfs(unit.variables.reanimated_unit_type, BfBH.reanimated.base_units[unit.type]))](unit)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_1
        name=attack,defender_hits,defender_misses
        first_time_only=no
        priority=-1000
        [filter]
            ability=flee
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_1")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if defender_stats.damage >= attacker.hitpoints then
    attacker.variables.flee = true
else
    attacker.variables.flee = false
end
std_print(attacker.variables.flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_2
        name=attacker_hits,attacker_misses
        first_time_only=no
        priority=-1000
        [filter]
            ability=flee
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_2")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if defender_stats.damage >= attacker.hitpoints then
    attacker.variables.flee = true
else
    attacker.variables.flee = false
end
std_print(attacker.variables.flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_3
        name=attack,attacker_hits,attacker_misses
        first_time_only=no
        priority=-1000
        [filter]
        [/filter]
        [filter_second]
            ability=flee
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_3")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if attacker_stats.damage >= defender.hitpoints then
    defender.variables.flee = true
else
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_4
        name=defender_hits,defender_misses
        first_time_only=no
        priority=-1000
        [filter]
        [/filter]
        [filter_second]
            ability=flee
        [/filter_second]
        [lua]
            code=<<
std_print("ability_flee_event_4")
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local weapon = wml.variables["weapon"]
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)

if attacker_stats.damage >= defender.hitpoints then
    defender.variables.flee = true
else
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_5
        name=defender_misses
        first_time_only=no
        priority=-500
        [filter]
            ability=flee
            [filter_wml]
                [variables]
                    flee=yes
                [/variables]
            [/filter_wml]
        [/filter]
        [filter_second]
        [/filter_second]
        [lua]
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = attacker
local second_unit = defender
local unit_cfg = attacker.__cfg
local second_unit_cfg = defender.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)
local right_weight = if_tile_passable(unit,right, 0.1)
local back_weight = if_tile_passable(unit,back, 0.3)
local left_weight = if_tile_passable(unit,left, 0.1)
local chance_to_flee = (defender_stats.chance_to_hit / (1.0 - (right_weight + back_weight + left_weight))) - defender_stats.chance_to_hit
local total_evaded_or_fleed = 100 - defender_stats.chance_to_hit
local probability_of_flee = (chance_to_flee / total_evaded_or_fleed)*100
local random = mathx.random() * total_evaded_or_fleed
local retreat
if random < probability_of_flee then
    random = mathx.random() * (right_weight + back_weight + left_weight)
    std_print("fleed")
    if random < right_weight then
        retreat=right
    elseif random < right_weight + back_weight then
        retreat=back
    elseif random < right_weight + back_weight + left_weight then
        retreat=left
    else
        std_print("Error in flee ability, unit should flee, but random found no free tile.")
        print("Error in flee ability, unit should flee, but random found no free tile.")
    end
    local loc = unit.loc
    wesnoth.game_events.fire("attack_end", attacker.loc, defender.loc)
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        unit.experience = unit.experience + second_unit_cfg.level
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        if wml.variables["side_number"] == unit.side then
            unit.moves = math.max(0, (unit.moves - wesnoth.units.movement_on(unit, wesnoth.get_terrain(retreat))))
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
    wml.variables["attack_was_cancelled"] = true
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_6
        name=attacker_misses
        first_time_only=no
        priority=-500
        [filter]
        [/filter]
        [filter_second]
            ability=flee
            [filter_wml]
                [variables]
                    flee=yes
                [/variables]
            [/filter_wml]
        [/filter_second]
        [lua]
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = defender
local second_unit = attacker
local unit_cfg = defender.__cfg
local second_unit_cfg = attacker.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
local i = 0
while wml.variables["unit[0].attack["..i.."]"] ~= nil and BfBH.table.deep_compare(wml.variables["unit[0].attack["..i.."]"], wml.variables["weapon"]) == false do
    i = i + 1
end
local attacking_weapon_index = i
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index + 1, defender)
local right_weight = if_tile_passable(unit,right, 0.1)
local back_weight = if_tile_passable(unit,back, 0.3)
local left_weight = if_tile_passable(unit,left, 0.1)
local chance_to_flee = (attacker_stats.chance_to_hit / (1.0 - (right_weight + back_weight + left_weight))) - attacker_stats.chance_to_hit
local total_evaded_or_fleed = 100 - attacker_stats.chance_to_hit
local probability_of_flee = (chance_to_flee / total_evaded_or_fleed)*100
local random = mathx.random() * total_evaded_or_fleed
local retreat
if random < probability_of_flee then
    random = mathx.random() * (right_weight + back_weight + left_weight)
    std_print("fleed")
    if random < right_weight then
        retreat=right
    elseif random < right_weight + back_weight then
        retreat=back
    elseif random < right_weight + back_weight + left_weight then
        retreat=left
    else
        std_print("Error in flee ability, unit should flee, but random found no free tile.")
        print("Error in flee ability, unit should flee, but random found no free tile.")
    end
    local loc = unit.loc
    wesnoth.game_events.fire("attack_end", attacker.loc, defender.loc)
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        unit.experience = unit.experience + second_unit_cfg.level
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        if wml.variables["side_number"] == unit.side then
            unit.moves = math.max(0, (unit.moves - wesnoth.units.movement_on(unit, wesnoth.get_terrain(retreat))))
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
    wml.variables["attack_was_cancelled"] = true
end
std_print(defender_stats.chance_to_hit)
std_print(chance_to_flee)
std_print(probability_of_flee)
>>
        [/lua]
    [/event]
    [event]
        id=ability_flee_event_7
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [lua]
            code=<<
std_print("ability_flee_event_7")
local attacker= wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local defender= wesnoth.units.get(wesnoth.current.event_context.x2, wesnoth.current.event_context.y2)
if attacker ~= nil then
    attacker.variables.flee = false
end
if defender ~= nil then
    defender.variables.flee = false
end
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [lua]
            code=<<
std_print("attack_end")
>>
        [/lua]
        #  [kill]
        #      id=$unit.id
        #  [/kill]
        #  [kill]
        #      id=$second_unit.id
        #  [/kill]
    [/event]
    [event]
        priority=10000
        name=advance
        first_time_only=no
        [lua]
            code=<<
std_print("advance")
>>
        [/lua]
    [/event]
    [event]
    priority=10000
    name=advance
    first_time_only=no
    [lua]
        code=<<
std_print("sighted")
>>
    [/lua]
[/event]
    [event]
        priority=10000
        name=pre_advance
        first_time_only=no
        [lua]
            code=<<
std_print("pre_advance")
>>
        [/lua]
    [/event]
    [event]
        priority=10000
        name=unit_placed
        first_time_only=no
        [lua]
            code=<<
std_print("unit_placed")
>>
        [/lua]
    [/event]
    [event]
        priority=10000
        name=post_advance
        first_time_only=no
        [lua]
            code=<<
std_print("post_advance")
>>
        [/lua]
    [/event]
    [event]
        name=capture
        first_time_only=no
        [lua]
            code=<<
std_print("capture")
>>
        [/lua]
    [/event]
    [event]
        name=moveto
        first_time_only=no
        [lua]
            code=<<
std_print("moveto")
>>
        [/lua]
    [/event]
    [event]
        name=enter_hex
        first_time_only=no
        [lua]
            code=<<
std_print("enter_hex")
>>
        [/lua]
    [/event]
    [event]
        name=exit_hex
        first_time_only=no
        [lua]
            code=<<
std_print("exit_hex")
>>
        [/lua]
    [/event]
    [event]
        name=sighted
        first_time_only=no
        [lua]
            code=<<
std_print("sighted")
>>
        [/lua]
    [/event]
    [event]
        name=attack
        first_time_only=no
        [lua]
            code=<<
std_print("attack")
>>
        [/lua]
    [/event]
    [event]
        name=defender_misses
        first_time_only=no
        [lua]
            code=<<
std_print("defender_misses")
>>
        [/lua]
    [/event]
    [event]
        name=attacker_misses
        first_time_only=no
        [lua]
            code=<<
std_print("attacker_misses")
>>
        [/lua]
    [/event]
    [event]
        id=weapon_special_ink_event_1
        name=attacker_hits
        first_time_only=no
        [filter_second]
            [not]
                [filter_wml]
                    [variables]
                        inked=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter_second]
        [filter_attack]
            special_id=ink
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "yes"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [modify_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            [object]
                id=inked
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_INKED}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        id=weapon_special_ink_event_2
        name=defender_hits
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [variables]
                        inked=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=ink
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "yes"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [modify_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object]
                id=inked
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_INKED}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        id=weapon_special_ink_event_3
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second]
            [filter_wml]
                [variables]
                    inked=yes
                [/variables]
            [/filter_wml]
        [/filter_second]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "no"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [remove_object]
            x,y=$x2,$y2
            object_id=inked
        [/remove_object]
    [/event]
    [event]
        id=weapon_special_ink_event_4
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter]
            [filter_wml]
                [variables]
                    inked=yes
                [/variables]
            [/filter_wml]
        [/filter]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.inked = "no"
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [remove_object]
            x,y=$x1,$y1
            object_id=inked
        [/remove_object]
    [/event]
    [event]
        id=ability_scavenger_event
        name=die
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [status]
                        undrainable="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second]
            ability=scavenger
        [/filter_second]
        [heal_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            amount=$(floor($unit.max_hitpoints / 4))
            animate=yes
            restore_statuses=no
        [/heal_unit]
    [/event]
    [event] #TODO make it status, give it icon
        id=ability_death_shriek_inflict
        name=die
        first_time_only=no
        [filter]
            ability=death_shriek
        [/filter]
        [modify_unit]
            [filter]
                [filter_side]
                    [enemy_of]
                        side=$unit.side
                    [/enemy_of]
                [/filter_side]
                [filter_location]
                    x,y=$x1,$y1
                    radius=2
                [/filter_location]
            [/filter]
            [object]
                id=ringing_ears
                take_only_once=no
                silent=yes
                duration=scenario
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_RINGING_EARS}
                    [/abilities]
                [/effect]
            [/object]
            [variables]
                ringing_ears_remove_turn="$(if($this_unit.side = $side_number,$( $turn_number + 1 ),$turn_number))"
            [/variables]
        [/modify_unit]
    [/event]
    [event]
        id=ability_death_shriek_remove
        name=side turn end
        first_time_only=no
        [remove_object]
            side=$side_number
            #race="$(if($this_unit.variables.ringing_ears_remove_turn <= $turn_number,1,0))"
            #  [filter_wml]
            #      [variables]
            #          ringing_ears_remove_turn=0 - 10
            #      [/variables]
            #  [/filter_wml]
            #formula="debug_print(self.wml_vars.ringing_ears_remove_turn) <= debug_print(turn_number)"
            lua_function=BfBH.filter.death_shriek
            object_id=ringing_ears
        [/remove_object]
    [/event]
    [event]
        name=die
        id=ability_immortal
        priority=3000
        first_time_only=no
        [filter]
            ability=immortal
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
unit:transform("BfBH Lich")
unit:remove_modifications({id="resilient", wml.tag['or']{id="strong"}, wml.tag['or']{id="intelligent"}, wml.tag['or']{id="quick"}},"trait")
unit.hitpoints = unit.max_hitpoints
unit.experience=0
animator = wesnoth.units.create_animator()
animator:add(unit,"recruited","hit",{})
animator:run()
unit:to_map() --this is for the unit_placed to trigger, if you know better way, suggest it / replacce this
>>
        [/lua]
    [/event]
    [event]
        name=die
        id=ability_ardent
        #  priority=-10000
        first_time_only=no
        [filter_second]
            ability=ardent
            side=$side_number
        [/filter_second]
        [lua]
            code=<<
local move_bonus = 2
local attack_bonus = 1 --NOTE if set to higher than two, attack -> attacks in string
local units = wesnoth.units.find_on_map({side=wesnoth.current.side,{"filter_location",{x=wesnoth.current.event_context.x2, y=wesnoth.current.event_context.y2 ,radius=2}},{"not",{ability="ardent"}}})
for _, unit in ipairs(units) do
    unit.moves =unit.moves + move_bonus
    unit.attacks_left=unit.attacks_left + attack_bonus
    wesnoth.interface.float_label(unit.x, unit.y, "<span color='#00FF00'>+"..attack_bonus.." attack</span>") --..move_bonus.." moves\n+"
end
>>
        [/lua]
    [/event]
    #  [event]
    #      name=unit_placed #add more on hand
    #      id=limited_uses_max
    #      first_time_only=no
    #      [filter]
    #          [has_attack]
    #              special_id=limited_uses_max
    #          [/has_attack]
    #      [/filter]
    #      [modify_unit]
    #          [filter]
    #              id=$unit.id
    #          [/filter]
    #          [object]
    #              duration=forever
    #              silent=yes
    #              id=limited_uses
    #              take_only_once=yes
    #              [effect]
    #                  apply_to=attack
    #                  special_id=limited_uses_max
    #                  [not]
    #                      special_id=limited_uses
    #                  [/not]
    #                  [set_specials]
    #                      mode=append
    #                      {WEAPON_SPECIAL_LIMITED_USES 3}
    #                  [/set_specials]
    #              [/effect]
    #          [/object]
    #      [/modify_unit]
    #  [/event]
    [event]
        name=unit_placed #add more on hand
        id=ability_veil_of_the_void_1
        first_time_only=no
        [filter]
            ability=veil_of_the_void
            formula="self.wml_vars.mist_of_the_void_get = false or self.wml_vars.mist_of_the_void_get = 0"
        [/filter]
        [modify_unit]
            [filter]
                id=$unit.id
            [/filter]
            [object]
                duration=scenario
                silent=yes
                id=veil_of_the_void
                take_only_once=no
                [effect]
                    apply_to=status
                    add=invulnerable
                [/effect]
                [effect]
                    apply_to=new_ability
                    [abilities]
                        {ABILITY_NIGHTSTALK}
                    [/abilities]
                [/effect]
            [/object]
        [/modify_unit]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
unit.variables.veil_of_the_void = 4
unit.variables.veil_of_the_void_get = -1 -- -1 means never, 0 means immediatelly
>>
        [/lua]
    [/event]
    [event]
        name=side turn end
        id=ability_veil_of_the_void_2
        first_time_only=no
        #side=$side_number
        #ability=veil_of_the_void
        #formula="self.wml_vars.veil_of_the_void > 0"
        [lua]
            code=<<
local units = wesnoth.units.find({side=wml.variables["side_number"], ability="veil_of_the_void", formula="self.wml_vars.veil_of_the_void > 0"})
for i, unit in ipairs(units) do
    unit.variables.veil_of_the_void = unit.variables.veil_of_the_void - 1
    if unit.variables.veil_of_the_void == 0 then
        unit:remove_modifications({id="veil_of_the_void"})
        unit.status.invulnerable=false
        unit.variables.veil_of_the_void_invulnerable = false --#TODO in case of more invulnerable-granting things
    end
end
>>
        [/lua]#TODO add ability that resets it into next scenario/after some turns, if needed
    [/event]
    [event]
        name=unit_placed,recruit,recall
        id=ability_rested
        first_time_only=no
        [filter]
            ability=rested
            formula="self.wml_vars.rested = false"
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
--if u.variables.rested == nil then end
u.variables.rested = 5*(1+u.level)
local cfg=u.__cfg
local hp_bonus = u.variables.rested
local new_hp_bonus = hp_bonus
if wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}) == nil then
    wesnoth.wml_actions.object({id="hitpoints_bonus",take_only_once=false,{"effect",{apply_to="hitpoints",increase_total=u.variables.rested, increase=u.variables.rested}},{"filter",{id=u.id}}})
end
>>
        [/lua]
    [/event]
    [event]
        name=side turn
        first_time_only=no
        id=ability_rested_side_turn
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="rested",{"filter_location",{{"not",{terrain="*^V*,C*^*,K*^*"}}}}})
for _,u in ipairs(units) do
    local cfg=u.__cfg
    local hp_bonus = u.variables.rested
    local new_hp_bonus = math.max(0,hp_bonus - 1)
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase_total = new_hp_bonus
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase = new_hp_bonus
    --wml.find_child(wml.get_child(cfg,"abilities"),"rested",{id="rested"}).description= "+"..new_hp_bonus.." HP"--sadly not persistent
    wesnoth.units.to_map(cfg)
    local new_u=wesnoth.units.get(cfg.x,cfg.y)
    new_u.variables.rested = new_hp_bonus
    wesnoth.units.transform(new_u,new_u.type)
end
units = wesnoth.units.find_on_map({side=wml.variables["side_number"],ability="rested",{"filter_location",{terrain="*^V*"}}})
for _,u in ipairs(units) do
    local cfg=u.__cfg
    local hp_bonus = u.variables.rested
    local new_hp_bonus = math.min(5*(1+u.level),hp_bonus + 5)
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase_total = new_hp_bonus
    wml.find_child(wml.find_child(wml.get_child(cfg,"modifications"),"object",{id="hitpoints_bonus"}),"effect",{apply_to="hitpoints"}).increase = new_hp_bonus
    --wml.find_child(wml.get_child(cfg,"abilities"),"rested",{id="rested"}).description= "+"..new_hp_bonus.." HP"--sadly not persistent
    wesnoth.units.to_map(cfg)
    local new_u=wesnoth.units.get(cfg.x,cfg.y)
    new_u.variables.rested = new_hp_bonus
    wesnoth.units.transform(new_u,new_u.type)
end
>>
        [/lua]
    [/event]
    [event]
        id=ability_storming_event
        name=die
        first_time_only=no
        [filter]
            [filter_location]
                terrain=*^V*,C*^*,K*^*
            [/filter_location]
        [/filter]
        [filter_second]
            ability=storming
        [/filter_second]
        [kill]
            id=$unit.id
            animate=no
            [secondary_unit]
                id=$second_unit.id
            [/secondary_unit]
        [/kill]
        [lua]
            code=<<
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local unit = defender
local unit_cfg = defender.__cfg
local context = wesnoth.current.event_context
    local retreat=wesnoth.named_tuple({context.x1, context.y1}, {'x', 'y'})
    local loc = unit.loc
    if wml.variables["unit[0].level"] == 0 then
        unit.experience = wesnoth.game_config.kill_experience * 0.5
        unit:advance(true,true)
    else
        unit.experience = unit.experience +(wml.variables["unit[0].level"] * wesnoth.game_config.kill_experience)
        unit:advance(true,true)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) and (wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc)) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
>>
        [/lua]
        {MOVE_UNIT (x,y = $x2,$y2) $x1 $y1}
    [/event]
    [event] #TODO finish slow remove and fast remove events!, deal damage only after healing in villages
        name=attacker hits
        first_time_only=no
        [filter_second]
            [not]
                [filter_wml]
                    [status]
                        not_living="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter_second]
        [filter_attack]
            special_id=bleed
        [/filter_attack]
        [lua]
            code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if variables.bleed == nil or variables.bleed == "" then
variables.bleed = 1
else
variables.bleed = (variables.bleed + 1)
end
variables.bleed_inflicted= wml.variables["unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
wml.variables["second_unit"] = u_table
-- wesnoth.interface.float_label(u_table.x, u_table.y, "Bleeding: " .. variables.bleed)
>>
        [/lua]
        [if]
            [have_unit]
                id=$second_unit.id
                [not]
                    [filter_wml]
                        [status]
                            bleeding=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/have_unit]
            [then]
                {VARIABLE second_unit.status.bleeding yes}
                [unstore_unit]
                    variable=second_unit
                    find_vacant=no
                    text=_ "bleeding"
                    red,green,blue=255,0,0
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        id=$second_unit.id
                    [/filter]
                    {BLEEDING_OBJECT}
                [/modify_unit]
            [/then]
        [/if]
    [/event]
    [event]
        name=defender hits
        id=bleed_event_2
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [status]
                        not_living="yes"
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        [filter_second_attack]
            special_id=bleed
        [/filter_second_attack]
        [lua]
            code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if variables.bleed == nil or variables.bleed == "" then
    variables.bleed = 1
else
    variables.bleed = (variables.bleed + 1)
end
variables.bleed_inflicted= wml.variables["second_unit"].id
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
wml.variables["second_unit"] = u_table
>>
        [/lua]
        [if]
            [have_unit]
                id=$unit.id
                [not]
                    [filter_wml]
                        [status]
                            bleeding=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/have_unit]
            [then]
                {VARIABLE unit.status.bleeding yes}
                [unstore_unit]
                    variable=unit
                    find_vacant=no
                    text=_ "bleeding"
                    red,green,blue=255,0,0
                [/unstore_unit]
                [modify_unit]
                    [filter]
                        id=$unit.id
                    [/filter]
                    {BLEEDING_OBJECT}
                [/modify_unit]
            [/then]
        [/if]
    [/event]
    [event]
        name=side turn
        id=bleed_event_3
        first_time_only=no
        [store_unit]
            [filter]
                side=$side_number
                [filter_wml]
                    [status]
                        bleeding="yes"
                    [/status]
                [/filter_wml]
            [/filter]
            variable=bleeding_units
        [/store_unit]
        [for]
            start=$($bleeding_units.length - 1)
            step=-1
            variable=i
            end=0
            [do]
                [harm_unit]
                    [filter]
                        x,y=$bleeding_units[$i].x,$bleeding_units[$i].y
                    [/filter]
                    [filter_second]
                        id=$bleeding_units[$i].variables.bleed_inflicted
                    [/filter_second]
                    amount=$bleeding_units[$i].variables.bleed
                    fire_event=yes
                    animate=defender
                    kill=yes
                    experience=kill
                [/harm_unit]
#                  [lua]
#                      code=<<
#  local u_table = wml.variables["unit"]
#  local variables = wml.get_child(u_table, "variables")
#  if variables.bleed == nil or variables.bleed == "" then
#      variables.bleed = 1
#  else
#      variables.bleed = (variables.bleed + 1)
#  end
#  variables.bleed_inflicted= wml.variables["second_unit"].id
#  wesnoth.units.erase(u_table.x,u_table.y)
#  wesnoth.units.to_map(u_table)
#  >>
#                  [/lua]
            [/do]
        [/for]
        {CLEAR_VARIABLE bleeding_units}
    [/event]
    [event]
        name=advance
        id=bleed_event_4
        first_time_only=no

        [filter]
            status=bleeding
        [/filter]

        {VARIABLE unit.status.bleeding no}

        [unstore_unit]
            variable=unit
            find_vacant=no
            advance=no
        [/unstore_unit]

        [remove_object]
            x,y=$unit.x,$unit.y
            object_id=bleeding_object
        [/remove_object]
    [/event]

    [event]
        name=victory
        id=bleed_event_5

        [remove_object]
            object_id=bleeding_object
            status=bleeding
        [/remove_object]

        [modify_unit]
            [filter]
                status=bleeding
            [/filter]

            [status]
                bleeding=no
            [/status]
        [/modify_unit]
    [/event]

    [event]
        name=side turn
        id=bleed_event_6
        first_time_only=no

        [remove_object]
            object_id=bleeding_object
            side=$side_number
            status=bleeding
            [and]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
                [or]
                    ability_type_active=regenerate
                [/or]
                [or]
                    [filter_adjacent]
                        is_enemy=no
                        [and]
                            ability_type=heals
                        [/and]
                    [/filter_adjacent]
                [/or]
            [/and]
        [/remove_object]

        [store_unit]
            [filter]
                side=$side_number
                status=bleeding
                [and]
                    [filter_location]
                        terrain=*^V*
                    [/filter_location]
                    [or]
                        ability_type_active=regenerate
                    [/or]
                    [or]
                        [filter_adjacent]
                            is_enemy=no
                            [and]
                                ability_type=heals
                            [/and]
                        [/filter_adjacent]
                    [/or]
                [/and]
            [/filter]
            variable=bleeding_units
        [/store_unit]

        [foreach]
            array=bleeding_units
            [do]
                {VARIABLE this_item.status.bleeding no}
                [unstore_unit]
                    variable=this_item
                    find_vacant=no
                [/unstore_unit]
                [heal_unit]
                    [filter]
                        x,y=$this_item.x,$this_item.y
                    [/filter]
                    amount=0
                    moves=full
                    animate=no
                    restore_statuses=no
                [/heal_unit]
            [/do]
        [/foreach]
        {CLEAR_VARIABLE bleeding_units}
    [/event]



    [event]
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=crippling_blow
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
if variables.crippled == nil or variables.crippled == "" then
    variables.crippled = 5
else
    variables.crippled = (variables.crippled + 5)
end
if variables.crippled > 100 then
    variables.crippled = 100
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [if]
            [have_unit]
                x,y=$x2,$y2
                status=crippled
            [/have_unit]
            [then]
            [/then]
            [else]
                [modify_unit]
                    [filter]
                        x,y=$x2,$y2
                    [/filter]
                    [status]
                        crippled=yes
                    [/status]
                    [object]
                        id=crippled
                        silent=yes
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                [damage]
                                    id=crippled
                                    multiply="((100.0 - self.wml_vars.crippled) / 100.0)"
                                [/damage]
                            [/abilities]
                        [/effect]
                    [/object]
                [/modify_unit]
            [/else]
        [/if]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=crippling_blow
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
if variables.crippled == nil or variables.crippled == "" then
    variables.crippled = 5
else
    variables.crippled = (variables.crippled + 5)
end
if variables.crippled > 100 then
    variables.crippled = 100
end
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
        [if]
            [have_unit]
                x,y=$x1,$y1
                status=crippled
            [/have_unit]
            [then]
            [/then]
            [else]
                [modify_unit]
                    [filter]
                        x,y=$x1,$y1
                    [/filter]
                    [status]
                        crippled=yes
                    [/status]
                    [object]
                        id=crippled
                        silent=yes
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                [damage]
                                    id=crippled
                                    multiply="((100.0 - self.wml_vars.crippled) / 100.0)"
                                [/damage]
                            [/abilities]
                        [/effect]
                    [/object]
                [/modify_unit]
            [/else]
        [/if]
    [/event]
    [event]
        name=post advance
        [if]
            [have_unit]
                x,y=$x1,$y1
                status=crippled
            [/have_unit]
            [then]
                [modify_unit]
                    [filter]
                        x,y=$x1,$y1
                    [/filter]
                    [status]
                        crippled=no
                    [/status]
                [/modify_unit]
                [remove_object]
                    x,y=$x1,$y1
                    object_id=crippled
                [/remove_object]
                [lua]
                    code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.crippled = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
                [/lua]
            [/then]
        [/if]
    [/event]
    [event]
        name=turn refresh
        first_time_only=no
        [modify_unit]
            [filter]
                side=$side_number
                status=crippled
                [and]
                    [filter_location]
                        terrain=*^V*
                    [/filter_location]
                    [or]
                        [experimental_filter_ability]
                            value=8
                            id=regenerates
                        [/experimental_filter_ability]
                    [/or]
                [/and]
                [or]
                    status=crippled
                    [filter_adjacent]
                        side=$side_number
                        is_enemy=no
                        [experimental_filter_ability]
                            value=8
                            id=healing
                            affect_allies=yes
                        [/experimental_filter_ability]
                    [/filter_adjacent]
                [/or]
            [/filter]
            [set_variable]
                name=crippled
                sub=20
            [/set_variable]
        [/modify_unit]
        [remove_object]
            status=crippled
            formula="(self.wml_vars.crippled <= 0)"
            object_id=crippled
        [/remove_object]
        [modify_unit]
            [filter]
                status=crippled
                formula="(self.wml_vars.crippled <= 0)"
            [/filter]
            [set_variable]
                name=crippled
                value=0
            [/set_variable]
            [status]
                crippled=no
            [/status]
        [/modify_unit]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=limited_uses
        [/filter_attack]
        [filter]
        [/filter]
        [lua]
            code="wesnoth.dofile '~add-ons/Bandits_from_Brown_Hills/lua/special_limited_uses.lua'"
        [/lua]
    [/event]
    [event] #TODO FOR FUTURE ME!!!! UPGRADE THIS
        name=unit_placed
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [modifications]
                        [object]
                            id="parry_object"
                        [/object]
                    [/modifications]
                [/filter_wml]
            [/not]
        [/filter]
        [object]
            id=parry_object
            take_only_once=no
            silent=yes
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    [chance_to_hit]
                        id=parry_effect
                        add="(self.wml_vars.parry * 1000)"
                    [/chance_to_hit]
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        [filter_attack]
            special_id=armor_breaking
        [/filter_attack]
        [filter_second]
            [not] #TODO in case of need shift this list
                trait="undead"
            [/not]
        [/filter_second]
        [object]
            id=broken_armor_object
            take_only_once=no
            silent=yes
            duration=turn
            [filter]
                x,y=$x2,$y2
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_BROKEN_ARMOR}
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=armor_breaking
        [/filter_second_attack]
        [filter]
            [not] #TODO in case of need shift this list
                trait="undead"
            [/not]
        [/filter]
        [object]
            id=broken_armor_object
            take_only_once=no
            silent=yes
            duration=turn
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_BROKEN_ARMOR}
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=attacker misses
        first_time_only=no
        [filter_second_attack]
            special_id=parry
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        [filter_attack]
            special_id=parry
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender misses
        first_time_only=no
        [filter_attack]
            special_id=parry
        [/filter_attack]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 1
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=defender hits
        first_time_only=no
        [filter_second_attack]
            special_id=parry
        [/filter_second_attack]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=parry
        [/filter_attack]
        [filter]
        [/filter]
        [lua]
               code=<<
local u_table = wml.variables["unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_second_attack]
            special_id=parry
        [/filter_second_attack]
        [filter_second]
        [/filter_second]
        [lua]
               code=<<
local u_table = wml.variables["second_unit"]
local variables = wml.get_child(u_table, "variables")
variables.parry = 0
wesnoth.units.erase(u_table.x,u_table.y)
wesnoth.units.to_map(u_table)
>>
        [/lua]
    [/event]
    [event]
        name=attack_end
        first_time_only=no
        id=knockback_event
        [filter_condition]
            {CANCELLED_ATTACK_FILTER}
        [/filter_condition]
        [filter_attack]
            special_id=knockback
        [/filter_attack]
        [filter]
        [/filter]
        [filter_second]
            [not]
                [filter_location]
                    terrain=*^V*
                [/filter_location]
            [/not]
        [/filter_second]
        [if]
            [variable]
                name=second_unit.hitpoints
                greater_than=0
            [/variable]
            [and]
                [variable]
                    name=unit.hitpoints
                    greater_than=0
                [/variable]
            [/and]
            [then]
                [store_locations]
                    [not]
                        [filter]
                        [/filter]
                    [/not]
                    #terrain=!,Q*,Q*^*,*^Q*,Mv,X*,X*^*,*^X*,_*^*,*^_*
                    [filter_adjacent_location]
                        x,y=$x2,$y2
                        adjacent="$(relative_dir(loc($x2,$y2), loc($x1,$y1)))"
                    [/filter_adjacent_location]
                    variable=knockback_target_hex
                [/store_locations]
                [store_locations]
                    [not]
                        [filter]
                        [/filter]
                    [/not]
                    #terrain=!,Q*,Q*^*,*^Q*,Mv,X*,X*^*,*^X*,_*^*,*^_*
                    [not]
                        [filter_adjacent_location]
                            x,y=$x2,$y2
                            adjacent="$(relative_dir(loc($x2,$y2), loc($x1,$y1)))"
                        [/filter_adjacent_location]
                    [/not]
                    [not]
                        [filter_adjacent_location]
                            x,y=$x1,$y1
                        [/filter_adjacent_location]
                    [/not]
                    [filter_adjacent_location]
                        x,y=$x2,$y2
                    [/filter_adjacent_location]
                    mode=append
                    variable=knockback_target_hex
                [/store_locations]
                [lua]
                    code=<<
local u = wesnoth.units.get(wml.variables["second_unit.id"])
local t = wml.variables["knockback_target_hex[0].terrain"]
if t then
    local move_cost = wesnoth.units.movement_on(u, t)
    if(move_cost > wml.variables["second_unit.max_moves"]) then
        wml.variables["knockback_target_hex"] = nil
    end
end
>>
                [/lua]
                [if]
                    [variable]
                        name=knockback_target_hex.length
                        greater_than=0
                    [/variable]
                    [then]
                        [lua]
            code=<<
local function if_tile_passable(unit, loc, val)
    if wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc) or wesnoth.units.movement_on(unit,wesnoth.current.map[loc]) == 99 then
        return 0
    else
        return val
    end
end
local attacker= wesnoth.units.get(wml.variables["unit.id"])
local defender= wesnoth.units.get(wml.variables["second_unit.id"])
local attacker_cfg = wesnoth.units.get(wml.variables["unit.id"]).__cfg
local defender_cfg = wesnoth.units.get(wml.variables["second_unit.id"]).__cfg
local unit = defender
local second_unit = attacker
local unit_cfg = defender.__cfg
local second_unit_cfg = attacker.__cfg
local weapon = wml.variables["weapon"]
local right = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,2)
local back = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,3)
local left = wesnoth.map.rotate_right_around_center(second_unit.loc,unit.loc,4)
    local retreat=wesnoth.named_tuple({wml.variables["knockback_target_hex"].x, wml.variables["knockback_target_hex"].y}, {'x', 'y'})
    local loc = unit.loc
    attacker.experience = attacker.experience + defender_cfg.level
    defender.experience = defender.experience + attacker_cfg.level
    attacker:advance(true,true)
    defender:advance(true,true)
    attacker.experience = attacker.experience - defender_cfg.level --attacker isn't moved, so it will get xp
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) then
        wesnoth.game_events.fire("exit_hex", loc, retreat)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, loc) and (wesnoth.units.get(loc) ~= nil or wesnoth.current.map:on_border(loc)) then
        wesnoth.wml_actions.move_unit(
            {
                id=unit.id,
                to_x=retreat.x,
                to_y=retreat.y
            }
        )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("enter_hex", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.wml_actions.redraw(
                {
                    clear_shroud=true,
                    side=unit.side
                }
            )
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        if wesnoth.terrain_types[wesnoth.current.map[retreat]].village then
            wesnoth.map.set_owner(retreat,unit.side)
            wesnoth.game_events.fire("capture", retreat)
        end
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        wesnoth.game_events.fire("moveto", retreat, loc)
    end
    if unit.valid == 'map' and unit.id == unit_cfg.id and BfBH.table.deep_compare(unit.loc, retreat) then
        unit.variables["flee"] = false
    end
>>
                        [/lua]
                        [if]
                            [have_unit]
                                x,y=$knockback_target_hex.x,$knockback_target_hex.y
                            [/have_unit]
                            [then]
                                [sound]
                                    name=fist.ogg
                                [/sound]
                                [store_unit]
                                    [filter]
                                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                                    [/filter]
                                    kill=yes
                                    variable=knockbacked
                                [/store_unit]
                                [unstore_unit]
                                    variable=knockbacked
                                    text= _ "knockback"
                                    {COLOR_HARM}
                                    advance=true
                                [/unstore_unit]
                                {CLEAR_VARIABLE knockbacked}
                            [/then]
                        [/if]
                    [/then]
                [/if]
                {CLEAR_VARIABLE knockback_target_hex}
            [/then]
        [/if]
    [/event]
    [event]
        name=exit_hex
        id=exploitation_event
        first_time_only = no
        [filter]
            [filter_adjacent]
                [has_attack]
                    special_id = exploitation
                [/has_attack]
                is_enemy = yes
            [/filter_adjacent]
        [/filter]
        [store_unit]
            [filter]
                id=$unit.id
            [/filter]
            variable = defender
        [/store_unit]
        [store_unit]
            [filter]
                [has_attack]
                    special_id = exploitation
                [/has_attack]
                [filter_adjacent]
                    x,y=$x1,$y1
                    is_enemy = yes
                [/filter_adjacent]
                [not]
                    [filter_location]
                        [filter_adjacent_location]
                            x,y=$x2,$y2
                        [/filter_adjacent_location]
                    [/filter_location]
                [/not]
            [/filter]
            variable = exploitation_units
        [/store_unit]
        [foreach]
            array=exploitation_units
            variable=current_exploitation_unit
            [do]
                [lua]
                    code=<<
local attacker= wesnoth.units.get(wml.variables["current_exploitation_unit[0].id"])
local defender= wesnoth.units.get(wml.variables["defender[0].id"])
local attacking_weapon_index = 0
local i = 0
while wml.variables["current_exploitation_unit[0].attack["..i.."]"] ~= nil do
    local weapon = wml.find_child(wml.variables["current_exploitation_unit[0].attack["..i.."]"],"specials",{{"dummy",{id="exploitation"}}})
    if weapon ~= nil then
        attacking_weapon_index = i + 1
        break
    end
    i = i + 1
end
defender.attacks[(#defender.attacks + 1)] = {}
local _, _, attacker_stats, defender_stats =wesnoth.simulate_combat(attacker,attacking_weapon_index, defender, #defender.attacks)
defender.attacks[#defender.attacks] = nil
for key, value in pairs(attacker_stats) do
    wml.variables["attacker_stats."..key] = tonumber(value) or tostring(value)
end
for key, value in pairs(defender_stats) do
    wml.variables["defender_stats."..key] = tonumber(value) or tostring(value)
end>>
                [/lua]
                [set_variable]
                    name = hit_roll
                    rand = 1..100
                [/set_variable]
                [if]
                    [variable]
                        name = attacker_stats.chance_to_hit
                        greater_than = $hit_roll
                    [/variable]
                    [then]
#                          [lua]
#                              code=<<
#  local v=wml.variables
#  local animation = wesnoth.units.create_animator()
#  local attacker= wesnoth.units.get(v["current_exploitation_unit[0].id"])
#  local defender= wesnoth.units.get(v["defender[0].id"])
#  local facing = {x = defender.x, y = defender.y}
#  local unit = attacker
#  local facing_loc = wesnoth.map.find(facing)[1]
#  local dir = wesnoth.map.get_relative_dir(unit.x, unit.y, facing_loc[1], facing_loc[2])
#  unit.facing = dir
#  facing = wesnoth.map.get_direction(unit.x, unit.y, dir)
#  animation:add(attacker, "attack", "hit",{with_bars = true, primary = attacker.attacks[v["attacker_stats.name"]], secondary = attacker.attacks[v["attacker_stats.name"]], target = facing})
#  defender.hitpoints=(defender.hitpoints - v["attacker_stats.damage"])
#  if defender.hitpoints <= 0 then
#      animation:add(defender, "die", "hit",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]],text = v["attacker_stats.damage"],color={255,0,0}})
#  else
#      animation:add(defender, "defend", "hit",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]], text = v["attacker_stats.damage"],color={255,0,0}})
#  end
#  animation:run()
#  animation:clear()
#  >>
#                          [/lua]
                        [harm_unit]#TODO doesn't look good
                            [filter]
                                x,y=$x1,$y1
                            [/filter]
                            [filter_second]
                                id=$current_exploitation_unit.id
                            [/filter_second]
                            amount = $attacker_stats.damage
                            kill = yes
                            experience = kill
                            fire_event = yes
                            animate = yes
                            [primary_attack]
                                special_id = exploitation
                            [/primary_attack]
                        [/harm_unit]
                    [/then]
                    [else]
                        [lua]
                            code=<<
local v=wml.variables
local animation = wesnoth.units.create_animator()
local attacker= wesnoth.units.get(v["current_exploitation_unit[0].id"])
local defender= wesnoth.units.get(v["defender[0].id"])
local facing = {x = defender.x, y = defender.y}
local unit = attacker
local facing_loc = wesnoth.map.find(facing)[1]
local dir = wesnoth.map.get_relative_dir(unit.x, unit.y, facing_loc[1], facing_loc[2])
unit.facing = dir
facing = wesnoth.map.get_direction(unit.x, unit.y, dir)
animation:add(attacker, "attack", "miss",{with_bars = true, primary = attacker.attacks[v["attacker_stats.name"]], secondary = attacker.attacks[v["attacker_stats.name"]], target = facing})
animation:add(defender, "defend", "miss",{with_bars = true, primary = defender.attacks[v["defender_stats.name"]], secondary = defender.attacks[v["defender_stats.name"]]})
animation:run()
animation:clear()
                            >>
                        [/lua]
                    [/else]
                [/if]
            [/do]
        [/foreach]
        #  {CLEAR_VARIABLE exploitation_units,defender,attacker_stats,defender_stats,hit_roll}
    [/event]
    [event]
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=zoc_stun, all_round
        [/filter_attack]
        [filter_condition]
        [/filter_condition]
        [modify_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x1,$y1
                    is_enemy=yes
                [/filter_adjacent]
                [not]
                    status=stunned
                [/not]
            [/filter]
            [object]
                silent=yes
                duration=turn end
                [effect]
                    apply_to=image_mod
                    replace="CS(50,50,0)"
                [/effect]
                [effect]
                    apply_to=zoc
                    value=no
                [/effect]
                [effect]
                    apply_to=movement
                    increase=-50%
                [/effect]
                [effect]
                    apply_to=status
                    add=stunned
                [/effect]
            [/object]
        [/modify_unit]
    [/event]
    [event]
        name=side turn end
        first_time_only=no
        [modify_unit]
            [filter]
                side=$side_number
                status=stunned
            [/filter]
            [status]
                stunned=no
            [/status]
        [/modify_unit]
    [/event]
#enddef

#define SPEAKING TAGS MESSAGE
    [narration]
        {TAGS}
        message = {MESSAGE}
    [/narration]
#enddef

#define NARRATION TAGS MESSAGE
    [narration]
        {TAGS}
        speaker_unit = no
        message = {MESSAGE}
    [/narration]
#enddef

#define DELAY TIME ACCELERATE
    [delay]
        time={TIME}
        accelerate={ACCELERATE}
    [/delay]
#enddef

#define AMLA_LEVEL_INCREASE
#doesnt work
    [event]
        name=post_advance
        id=amla_level_increase_event
        first_time_only=no
#         [filter_condition]
#             {AWW_TEST_WAS_AMLA}
#         [/filter_condition]
#cant find
        [modify_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            [object] ###############################################MAYBE DOESN'T work becouse of ID, which shouldn't be there
                id=amla_level_increase
                duration=forever
                silent=yes
                [effect]
                    apply_to=level
                    increase=1
                [/effect]
            [/object]
#             [set_variable]
#                 name=aww_level_count
#                 value=$unit.level
#             [/set_variable]
#TODO number of AMLAS past, then move into AMLA
        [/modify_unit]
    [/event]
#enddef

##############Scenario 1 MACROS####################

#define BUILD_CAMP UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Cyk
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_CAMP_KEEP UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Kyt
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_TENT_VILLAGE UNIT X Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    [terrain]
        x,y={X},{Y}
        terrain=^Vct
        layer=overlay
    [/terrain]
    [redraw]
        side=1
    [/redraw]
    [sound]
        name=mace-miss.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define BUILD_TORCH_UP UNIT X Y TIME_X TIME_Y
    {MOVE_UNIT {UNIT} {X} {Y}}
    {PLACE_TORCHES "{X}" "$({Y}-1)"}
    [sound]
        name=torch.ogg
    [/sound]
    [delay]
        time=500
        accelerate=yes
    [/delay]
#enddef
#define PLACE_TORCHES X Y
    {VARIABLE torch.x {X}}
    {VARIABLE torch.y {Y}}
    {VARIABLE torch_array ""}
    [lua]
        code=<<
local i = 0
if tostring(wml.variables["torch.x"]):find(",") then
    for num in wml.variables["torch.x"]:gmatch("[^,%s]+") do
        wml.variables["torch_array["..i.."].x"] = tonumber(num)
        i = i + 1
    end
else
    wml.variables["torch_array[0].x"] = tonumber(wml.variables["torch.x"])
end
        >>
    [/lua]
    [lua]
        code=<<
local i = 0
if tostring(wml.variables["torch.y"]):find(",") then
    for num in wml.variables["torch.y"]:gmatch("[^,%s]+") do
        wml.variables["torch_array["..i.."].y"] = tonumber(num)
        i = i + 1
    end
else
    wml.variables["torch_array[0].y"] = tonumber(wml.variables["torch.y"])
end
        >>
    [/lua]
    [foreach]
        array=torch_array
        [do]
            [if]
                [have_location]
                    x,y=$torch_array[$i].x,$torch_array[$i].y
                    terrain=X*^*
                    include_borders=yes
                [/have_location]
                [then]
                    [time_area]
                        id="torch_$torch_array[$i].x|_$torch_array[$i].y"
                        x,y=$torch_array[$i].x,$torch_array[$i].y
                        include_borders=yes
                        [or]
                            [filter_adjacent_location]
                                x,y=$torch_array[$i].x,$torch_array[$i].y
                                adjacent=ne,n,nw
                                include_borders=yes
                            [/filter_adjacent_location]
                            [not]
                                terrain=X*^*
                            [/not]
                        [/or]
                        [time]
                            name= _ "Torchlight"
                            image=time/schedule-indoors-dark.png
                            red=0
                            green=-20
                            blue=-35
                        [/time]
                    [/time_area]
                [/then]
                [else]
                    [time_area]
                        id="torch_$torch_array[$i].x|_$torch_array[$i].y"
                        x,y=$torch_array[$i].x,$torch_array[$i].y
                        include_borders=yes
                        [or]
                            [filter_adjacent_location]
                                x,y=$torch_array[$i].x,$torch_array[$i].y
                                adjacent=se,s,sw
                                include_borders=yes
                            [/filter_adjacent_location]
                            [not]
                                terrain=X*^*
                            [/not]
                        [/or]
                        [time]
                            name= _ "Torchlight"
                            image=time/schedule-indoors-dark.png
                            red=0
                            green=-20
                            blue=-35
                        [/time]
                    [/time_area]
                [/else]
            [/if]
            [terrain]
                x,y=$torch_array[$i].x,$torch_array[$i].y
                terrain=^Efs
                layer=overlay
                include_borders=yes
            [/terrain]
            [redraw]
                side=1
            [/redraw]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE torch_array}
    {CLEAR_VARIABLE torch}
#enddef
#define RANDOM_AROUND_PLACEMENT X Y
    [store_locations]
        [filter_adjacent_location]
            x,y={X},{Y}
        [/filter_adjacent_location]
        [not]
            [filter]
            [/filter]
            [filter_location]
                terrain=X*^*
            [/filter_location]
        [/not]
        variable=adjecent_hexes
    [/store_locations]
    {VARIABLE_OP i rand "0..$($adjecent_hexes.length - 1)"}
#enddef
#define VILLAGE_RAID X Y ID
    [event]
        id={ID}
        name=moveto
        first_time_only=yes
        [filter]
            side=1
            x,y={X},{Y}
        [/filter]
        [scroll_to]
            x,y={X},{Y}
        [/scroll_to]
        [terrain]
            x,y={X},{Y}
            terrain=Gd^Vhr
        [/terrain]
        [sound]
            name=torch.ogg
        [/sound]
        [redraw]
            side=1
        [/redraw]
        [delay]
            time=500
            accelerate=yes
        [/delay]
        {VARIABLE {ID} 1}
        {VARIABLE_OP farmers rand "1..100"}
        {VARIABLE_OP type_of_farmer rand "1..100"}
        {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 11 13 15}"}
        {RANDOM_AROUND_PLACEMENT {X} {Y} }
        [if]
            [variable]
                name=type_of_farmer
                less_than_equal_to=50
            [/variable]
            [then]
                [move_unit_fake]
                    type=BfBH Peasant
                    x={X},$adjecent_hexes[$i].x
                    y={Y},$adjecent_hexes[$i].y
                    side=2
                [/move_unit_fake]
                [unit]
                    type="BfBH Peasant"
                    side=2
                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                    experience=$units_experience
                    placement=map
                    passable=yes
                [/unit]
            [/then]
            [else]
                [move_unit_fake]
                    type=BfBH Woodsman
                    x={X},$adjecent_hexes[$i].x
                    y={Y},$adjecent_hexes[$i].y
                    side=2
                [/move_unit_fake]
                [unit]
                    type="BfBH Woodsman"
                    side=2
                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                    experience=$units_experience
                    placement=map
                    passable=yes
                [/unit]
            [/else]
        [/if]
        [if]
            [variable]
                name=farmers
                less_than_equal_to={ON_DIFFICULTY 30 50 70}
            [/variable]
            [then]
                {VARIABLE_OP type_of_farmer rand "1..100"}
                {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 11 13 15}"}
                {RANDOM_AROUND_PLACEMENT {X} {Y} }
                [if]
                    [variable]
                        name=type_of_farmer
                        less_than_equal_to=50
                    [/variable]
                    [then]
                        [move_unit_fake]
                            type=BfBH Peasant
                            x={X},$adjecent_hexes[$i].x
                            y={Y},$adjecent_hexes[$i].y
                            side=2
                        [/move_unit_fake]
                        [unit]
                            type="BfBH Peasant"
                            side=2
                            x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                            experience=$units_experience
                            placement=map
                            passable=yes
                        [/unit]
                    [/then]
                    [else]
                        [move_unit_fake]
                            type=BfBH Woodsman
                            x={X},$adjecent_hexes[$i].x
                            y={Y},$adjecent_hexes[$i].y
                            side=2
                        [/move_unit_fake]
                        [unit]
                            type="BfBH Woodsman"
                            side=2
                            x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                            experience=$units_experience
                            placement=map
                            passable=yes
                        [/unit]
                    [/else]
                [/if]
                [if]
                    [variable]
                        name=farmers
                        less_than_equal_to={ON_DIFFICULTY 0 10 20}
                    [/variable]
                    [then]
                        {VARIABLE_OP type_of_farmer rand "1..100"}
                        {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 9 10 11}"}
                        {RANDOM_AROUND_PLACEMENT {X} {Y} }
                        [if]
                            [variable]
                                name=type_of_farmer
                                less_than_equal_to=50
                            [/variable]
                            [then]
                                [move_unit_fake]
                                    type=BfBH Peasant
                                    x={X},$adjecent_hexes[$i].x
                                    y={Y},$adjecent_hexes[$i].y
                                    side=2
                                [/move_unit_fake]
                                [unit]
                                    type="BfBH Peasant"
                                    side=2
                                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                                    experience=$units_experience
                                    placement=map
                                    passable=yes
                                [/unit]
                            [/then]
                            [else]
                                [move_unit_fake]
                                    type=BfBH Ruffian
                                    x={X},$adjecent_hexes[$i].x
                                    y={Y},$adjecent_hexes[$i].y
                                    side=2
                                [/move_unit_fake]
                                [unit]
                                    type="BfBH Ruffian"
                                    side=2
                                    x,y=$adjecent_hexes[$i].x, $adjecent_hexes[$i].y
                                    experience=$units_experience
                                    placement=map
                                    passable=yes
                                [/unit]
                            [/else]
                        [/if]
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
#enddef
#define VILLAGERS_FLEEING X Y ID
    [if]
        [variable]
            name={ID}
            greater_than=0
        [/variable]
        [then]
        [/then]
        [else]
            {VARIABLE_OP type_of_farmer rand "1..100"}
            {VARIABLE_OP units_experience rand "0..{ON_DIFFICULTY 9 10 11}"}
            [if]
                [variable]
                    name=type_of_farmer
                    less_than_equal_to=50
                [/variable]
                [then]
                    [unit]
                        type="BfBH Peasant"
                        side=2
                        x,y={X},{Y}
                        animate=yes
                        placement=map
                        passable=yes
                        experience=$units_experience
                        role=villager_fleeing
                    [/unit]
                [/then]
                [else]
                    [unit]
                        type="BfBH Woodsman"
                        side=2
                        x,y={X},{Y}
                        animate=yes
                        placement=map
                        passable=yes
                        experience=$units_experience
                        role=villager_fleeing
                    [/unit]
                [/else]
            [/if]
            [capture_village]
                x,y={X},{Y}
            [/capture_village]
            [if]
                [variable]
                    name=villager_talked
                    less_than_equal_to=0
                [/variable]
                [then]
                    [store_unit]
                        [filter]
                            role=villager_fleeing
                        [/filter]
                    [/store_unit]
                    {SPEAKING (id=$unit.id) "Sir Rillon was defeated, it's not safe in there anymore!"}
                    [set_variable]
                        name=villager_talked
                        value=1
                    [/set_variable]
                [/then]
            [/if]
        [/else]
    [/if]
#enddef
#define VILLAGE_REPLACE X Y ID
    [if]
        [variable]
            name={ID}
            greater_than=0
        [/variable]
        [then]
            [terrain]
                x,y={X},{Y}
                terrain=Gd^Vhr
            [/terrain]
        [/then]
    [/if]
#enddef
#define UNIVERSAL_RECALL SIDE X Y RECALL_UNIT NEW_UNIT MAX_XP
    [if]
        [have_unit]
            x,y=recall,recall
            side={SIDE}
            type={RECALL_UNIT}
            search_recall_list=yes
        [/have_unit]
        [then]
            [recall]
                side={SIDE}
                type={RECALL_UNIT}
                x,y={X},{Y}
            [/recall]
        [/then]
        [else]
            {VARIABLE_OP units_experience rand "0..{MAX_XP}"}
            [unit]
                type={NEW_UNIT}
                side={SIDE}
                animate=yes
                x,y={X},{Y}
                experience=$units_experience
            [/unit]
        [/else]
    [/if]
#enddef
#define THREE_TRAITS_LOYAL_UNIT SIDE UNIT_TYPE X Y
    [unit]
        side={SIDE}
        type={UNIT_TYPE}
        x={X}
        y={Y}
        generate_name=yes
        random_traits=yes
        random_gender=yes
        role=needs_loyal_trait
    [/unit]
    [modify_unit]
        [filter]
            role=needs_loyal_trait
        [/filter]
        role=
        {TRAIT_LOYAL}
    [/modify_unit]
#enddef
#define ABILITY_EQUIPPED
    [dummy]
        id=equipped
        name= _ "equipped"
        female_name= _ "female^equipped"
        description=_ "This unit has equipped item and it can't get another one."
        special_note=_ "This unit has equipped item and it can't get another one."
    [/dummy]
#enddef
#define ABILITY_LIVING_SHIELD
    [dummy]
        id=living_shield
        name= _ "living shield"
        female_name= _ "female^living shield"
        description= _ "Driven by a mix of fanatical loyalty and primal fear, this unit instinctively throws itself in harm's way. When an enemy attacks an allied unit adjacent to this one, this expendable warrior will intercept the blow, taking the full brunt of the assault upon its own flesh."
        special_note=_ "This unit can intercept attacks meant for adjacent allies. When an enemy attacks an allied unit adjacent to this one, this unit will take the attack instead."
    [/dummy]
#enddef
#define ABILITY_REANIMATED
    [reanimated]
        id=reanimated
        name= _ "reanimated"
        female_name= _ "female^reanimated"
        description= _ "A nightmarish fusion of past and present, this corpse writhes with unnatural vitality. Fragments of its former self claw their way through decaying flesh, manifesting as twisted echoes of abilities long dead. Those who face it must contend not just with the monster before them, but with the grotesque remnants of the person it once was."
        special_note=_ "Twisted echoes of past life writhe within this rotting flesh, granting unpredictable and horrifying abilities."
    [/reanimated]
#enddef
#define ABILITY_FORAGE
    [regenerate]
        id=forage
        name=_"forage"
        female_name= _ "female^forage"
        description=_"#TODO"
        special_note=_ "When on forest/fungus/farm/village tile, this unit heals 4 HP per turn."
        affect_self=yes
        value=4
        poison=slowed
        [filter_self]
            [filter_location]
                #forest, fungus, farm
                terrain=*^F*,*^Uf,*^Ufi,*^Gvs,*^Tf
            [/filter_location]
        [/filter_self]
    [/regenerate]
#enddef
#define ABILITY_RINGING_EARS
    [chance_to_hit]
        id=ringing_ears
        sub=10
    [/chance_to_hit]
#enddef
#define ABILITY_INKED
    [chance_to_hit]
        id=inked
        name= _ "inked"
        female_name= _ "female^inked"
        description=_ "This unit's accuracy is decreased by 10% until the end of the fight."
        special_note=_ "YOU REALLY SHOULDN'T SEE THIS! (unless special note's appearance has been changed)"
        sub=10
    [/chance_to_hit]
#enddef
#define ABILITY_TENACITY
    [resistance]
        id=tenacity
        divide=2
        max_value=0
        [filter_base_value]
            greater_than=-100
            less_than=0
        [/filter_base_value]
        name= _ "tenacity"
        female_name= _ "female^tenacity"
        description=_ "#TODO"
        special_note=_ "This unit's vulnerabilities are halved when defending."
        affect_self=yes
        active_on=defence
    [/resistance]
#enddef
#define ABILITY_BOLD
    [resistance]
        id=bold
        divide=2
        max_value=0
        [filter_base_value]
            greater_than=-100
            less_than=0
        [/filter_base_value]
        name= _ "bold"
        female_name= _ "female^bold"
        description=_ "#TODO"
        special_note=_ "This unit's vulnerabilities are halved when attacking."
        affect_self=yes
        active_on=offense
    [/resistance]
#enddef
#define ABILITY_CASTLE_GUARD
    [resistance]
        id=castle_guard
        name= _ "castle guard"
        female_name= _ "female^castle guard"
        description= _ "#TODO"
        special_note= _ "While in a castle or village, this unit gives 10% physical protection increase to adjacent units in castle or village, up to the total of 50% protection."
        add=10
        max_value=50
        apply_to=blade,pierce,impact
        affect_self=no
        affect_allies=yes
        cumulative=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [filter_location]
                    terrain=C*^*,K*^*,*^V*
                [/filter_location]
            [/filter]
        [/affect_adjacent]
        [filter_base_value]
            less_than=50
        [/filter_base_value]
        [filter]
            [filter_location]
                terrain=C*^*,K*^*,*^V*
            [/filter_location]
        [/filter]
    [/resistance]
#enddef
#define ABILITY_SKILLED
    [chance_to_hit]
        id=skilled
        name= _ "skilled"
        female_name= _ "female^skilled"
        description=_"#TODO"
        special_note= _ "This unit always has a minimum 50% chance to hit"
        value=50
        cumulative=yes
    [/chance_to_hit]
#enddef
#define ABILITY_VERY_SKILLED
    [chance_to_hit]
        id=very_skilled
        name= _ "very skilled"
        female_name= _ "female^very skilled"
        description=_"#TODO"
        special_note= _ "This unit always has a minimum 60% chance to hit"
        value=60
        cumulative=yes
    [/chance_to_hit]
#enddef
#define BATTLE_FRENZY COUNT ADDITION
    [damage]
        id=battle_frenzy_{COUNT}
        add="({ADDITION} * level)"
        cumulative=no
        apply_to=self
        [filter_self]
            [filter_adjacent]
                is_enemy=yes
                count={COUNT}
            [/filter_adjacent]
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_BATTLE_FRENZY
    [damage]
        id=battle_frenzy
        name= _ "battle frenzy"
        female_name= _ "female^battle frenzy"
        description=_ "When in the heat of battle, this unit enters a state of frenzy, significantly increasing its attack power.

+level damage per every adjecent enemy, except first one."
        special_note=_ "This unit deals more damage for every adjecent enemy"
        [filter_self] # So you see something in attack menu
            [filter_adjacent]
                is_enemy=yes
                count=2-6
            [/filter_adjacent]
        [/filter_self]
    [/damage]
    {BATTLE_FRENZY 2 1}
    {BATTLE_FRENZY 3 2}
    {BATTLE_FRENZY 4 3}
    {BATTLE_FRENZY 5 4}
    {BATTLE_FRENZY 6 5}
#enddef

#define ABILITY_BERSERKERS_RAGE
    [damage]
        id=berserkers_rage
        name= _ "berserkers rage"
        female_name= _ "female^berserkers rage"
        description="This unit enters a frenzied state when is about to strike for the last time.

In this state, the unit's damage doubles, unleashing its full berserker rage on its enemies."
        special_note=_ "This unit deals great damage when it's about to die."
        multiply=2
        [filter_self]
            formula="if((self.hitpoints * 4) < self.max_hitpoints, 1, 0)"
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_DAUNTLESS
    [resistance]
        id=dauntless
        name= _ "dauntless"
        female_name= _ "female^dauntless"
        description= _ "When attacking, this unit's unwavering courage and determination bolster its defenses, significantly increasing its resistances."
        special_note=_ "This unit's resistances are doubled, up to a maximum of 50%, when attacking. Vulnerabilities are not affected."
        multiply=2
        max_value=50
        [filter_base_value]
            greater_than=0
            less_than=50
        [/filter_base_value]
        affect_self=yes
        active_on=offense
    [/resistance]
#enddef
#define ABILITY_AWE
    [leadership]
        id=awe
        cumulative=yes
        name=_"awe"
        female_name= _ "female^awe"
        description=_"The menacing presence of this unit strikes fear into the hearts of nearby enemies. Enemies adjacent to this unit deal 15% less damage, with an additional 15% reduction per level difference.
This ability does not affect non-living or fearless units, as they are immune to such intimidation."
        special_note=_ "Enemies adjacent to this unit deal 15% less damage, and another 15% less damage per level difference. Does not affect non-living or fearless units."
        sub="(if(level > other.level, (15 * (level + 1 - other.level)), 15))"
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            [filter]
                [not]
                    trait=undead
                    [or]
                        trait=fearless
                    [/or]
                [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef
#define ABILITY_FLEE
    [chance_to_hit]
        id=flee
        name= _ "flee"
        female_name= _ "female^flee"
        description=_ "When faced with imminent defeat, the unit can execute a strategic retreat, swiftly disengaging from combat to avoid certain death.

The more space this unit has behind, the more likely it can evade."
        special_note=_ "This unit can flee combat, to fight another day."
        apply_to=opponent
        multiply="(1
        - if(unit_at(back) or movement_cost(self, back) = 99 or movement_cost(self, back) = null(),0,0.3)
        - if(unit_at(back_left) or movement_cost(self, back_left) = 99 or movement_cost(self, back_left) = null(),0,0.1)
        - if(unit_at(back_right) or movement_cost(self, back_right) = 99 or movement_cost(self, back_right) = null(),0,0.1)
        where
            back_left = direction_from(loc, dirs[back_left_index]),
            back = direction_from(loc, dirs[back_index]),
            back_right = direction_from(loc, dirs[back_right_index])
        where
            back_left_index = (index + 4) % 6,
            back_index = (index + 3) % 6,
            back_right_index = (index + 2) % 6
        where
            index = index_of(relative_dir(loc, other.loc), dirs)
        where
            dirs = ['n', 'ne', 'se', 's', 'sw', 'nw']
        )"#My most complex formula so far :D
        [filter_self]
            formula="(wml_vars.flee)"
        [/filter_self]
    [/chance_to_hit]
#enddef
#define ABILITY_IMMORTAL
    [dummy]
        id=immortal
        name= _ "immortal"
        female_name= _ "female^immortal"
        description= _ "When thy mortal coil fails, embrace not the peace of death, but the curse of unlife. Thy soul, bound to bone by eldritch magicks, shall defy the reaper's scythe. In shadows deep and time unending, thy form shall walk the earth, a wraith of bygone days. The warmth of life shall flee thy touch, and mortal men shall tremble at thy passing. Whispers of thy name shall chill the blood, and nightmares of thy visage shall plague the living. In realms of dust and forgotten lore, thy power shall wax eternal, fed by the fear of those who dare not speak thy dreaded title. But hark! The price of such power is steep, for in cheating death, thou shalt become its master and its slave forevermore."
        special_note=_"When thy mortal coil fails, embrace not the peace of death, but the curse of unlife. Thy soul, bound to bone by eldritch magicks, shall defy the reaper's scythe. In shadows deep and time unending, thy form shall walk the earth, a wraith of bygone days. The warmth of life shall flee thy touch, and mortal men shall tremble at thy passing. Whispers of thy name shall chill the blood, and nightmares of thy visage shall plague the living. In realms of dust and forgotten lore, thy power shall wax eternal, fed by the fear of those who dare not speak thy dreaded title. But hark! The price of such power is steep, for in cheating death, thou shalt become its master and its slave forevermore."
    [/dummy]
#enddef
#define ABILITY_VEIL_OF_THE_VOID
    [veil_of_the_void]
        id=veil_of_the_void
        name= _ "veil of the void"
        female_name= _ "female^veil of the void"
        description= _ "When thy unholy form manifests anew, thy essence shall fade to mist, untouchable by mortal hands or mundane steel. Pass through solid stone as if 'twere but air, and let arrows whistle harmlessly through thy spectral form. But mark well, wielder of dark arts - this reprieve is fleeting. As the third sand falls, corporeality shall claim thee once more, returning thy bones to the realm of flesh and blood."
        special_note=_"When thy unholy form manifests anew, thy essence shall fade to mist, untouchable by mortal hands or mundane steel. Pass through solid stone as if 'twere but air, and let arrows whistle harmlessly through thy spectral form. But mark well, wielder of dark arts - this reprieve is fleeting. As the third sand falls, corporeality shall claim thee once more, returning thy bones to the realm of flesh and blood."
    [/veil_of_the_void]
#enddef
#define ABILITY_DISENGAGE
    [dummy]
        id=disengage
        name= _ "disengage"
        female_name= _ "female^disengage"
        description= _ "Upon invoking the esteemed maneuver, the adept tactician deftly extricates themselves from the tumultuous fray of battle.

This unit can move after attack, if it haven't moved yet."
        special_note=_"If this unit doesn't move before attacking, it will retain its movement points after the attack."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_ARSON
    [damage]
        id=arson_1
        name= _ "arson"
        female_name= _ "female^arson"
        description= _ "#TODO"
        special_note=_ "This unit uses the terrain against the enemy by lighting it on fire, its damage increases by 25% when the enemy is on forest, castle, or a village tile, or other manmade structure (farms and windmills) but decreases by 25% if the enemy is in water. ::Note:: Villages or castles with water or swamp are considered water."
        apply_to=self
        multiply="1.25"
        [filter_opponent]
            [filter_location]
                terrain=C*^*,K*^*,*^F*,*^Gvs,*^Wm,*^Eff,*^Uf*,*^V*,*^Bw*,*^Bh*,*^Bp*
                [not]
                    terrain=W*^*,S*^*,Chw*^*,Chs*^*,Cm*^*,Khw*^*,Khs*^*,Km*^*,*^Vm*,*^Vaa
                [/not]
            [/filter_location]
        [/filter_opponent]
    [/damage]
    [damage]
        id=arson_2
        apply_to=self
        multiply="0.75"
        [filter_opponent]
            [filter_location]
                terrain=W*^*,S*^*,Chw*^*,Chs*^*,Cm*^*,Khw*^*,Khs*^*,Km*^*
                [not]
                    terrain=*^Bw*,*^Bs*,*^Bh*,*^Bc*,*^Bp* # not on Bridges
                [/not]
            [/filter_location]
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_AGGRESSIVE
    [attacks]
        id=aggressive
        name= _ "aggressive"
        female_name= _ "female^aggressive"
        description=_ "Lo, when this warrior doth press the attack, a fell madness takes hold. In the frenzy of the charge, both attacker and defender are seized by battle-lust, their blows raining down with terrible fury. Verily, the clashing of arms increaseth by half again its normal measure."
        special_note=_ "When attacking, incites a frenzy in both combatants. All strike counts dealt and received increase by 50%."
        active_on=offense
        apply_to=both
        multiply=1.5
    [/attacks]
#enddef
#define ABILITY_CONCENTRATED
    [attacks] #TODO #NOW
        id=concentrated
        name= _ "concentrated"
        female_name= _ "female^concentrated"
        description= _ "#TODO"
        special_note=_ "#TODO"
        active_on=offense
        apply_to=self
        sub=1
    [/attacks]
    [chance_to_hit]
        id=concentrated_2 #TODO how is it used elsewhere?
        active_on=offense
        apply_to=self
        add="$($weapon.number * 5)"
    [/chance_to_hit]
#enddef
#define ABILITY_LONE_WOLF
    [damage]
        id=lone_wolf
        name= _ "lone wolf"
        female_name= _ "female^lone wolf"
        description=_ "When this unit finds itself isolated, without nearby allies, it undergoes a remarkable transformation.
Enhanced by solitude, its senses sharpen, reflexes quicken, and strength surges."
        special_note=_ "When isolated, the unit's skills peak."
        multiply=1.25
        [filter_self]
            [filter_adjacent]
                is_enemy=no
                count=0
            [/filter_adjacent]
        [/filter_self]
    [/damage]
    [chance_to_hit]
        id=lone_wolf
        add=10
        cumulative=yes
        apply_to=self
        [filter_self]
            [filter_adjacent]
                is_enemy=no
                count=0
            [/filter_adjacent]
        [/filter_self]
    [/chance_to_hit]
#enddef
#define ABILITY_RIGHTEOUS
    [damage]
        id=righteous
        name=_"righteous"
        female_name= _ "female^righteous"
        description= _ "#TODO"
        special_note=_ "This unit deals 25% more damage against chaotic enemies."
        multiply=1.25
        [filter_opponent]
            [filter_wml]
                alignment=chaotic
            [/filter_wml]
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_STORMING
    [damage]
        id=storming
        name=_"storming"
        female_name= _ "female^storming"
        description= _ "This unit excels in breaching fortified positions. When attacking enemies occupying a castle or village, this unit gains increased strength, allowing it to deal extra damage and break through defenses more effectively.
The overwhelming force of the storming unit's assault can demoralize and weaken entrenched enemies, making it a powerful asset in capturing strategic locations.

Upon defeating an enemy on castle or village this units takes it's ground."
        special_note=_ "This unit deals extra damage agains fortified foes and recaptures those positions."
        active_on=offense
        multiply=2
        [filter_opponent]
            [filter_location]
                terrain=*^V*,C*^*,K*^*
            [/filter_location]
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_WOLF_PACK
    [skirmisher]
        id=wolf_pack
        name=_"wolf pack"
        female_name= _ "female^wolf pack"
        description=_"#TODO"
        special_note=_ "This unit negates enemy Zones of Control around itself for allied wolf units."
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
    [/skirmisher]
#enddef
#define ABILITY_PACK_LEADER
    [damage]
        id=pack_leader
        name=_"pack leader"
        female_name= _ "female^pack leader"
        description=_"#TODO"
        special_note=_ "#TODO Adjacent allied wolves deal 50% more backstab-like damage."
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
        multiply=1.5
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_TANGLED_SLAUGHTER
    [damage] #TODO#TODO#TODO
        id=tangled_slaughter
        name=_"tangled slaughter"
        female_name= _ "female^tangled slaughter"
        description=_"#TODO"
        special_note=_ "#TODO"
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=wolf_pack
                [/or]
            [/filter]
        [/affect_adjacent]
        multiply=1.5
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef
#define ABILITY_DESPERATE_DODGE
    [chance_to_hit]
        id=desperate_dodge
        name= _ "desperate dodge"
        female_name= _ "female^desperate dodge"
        description= _ "The Desperation Dodging effect represents the unit's survival instincts kicking in when nearing a critically injured state. As it takes more damage, its reflexes are heightened by adrenaline, allowing it to twist, duck and dive to narrowly avoid what would otherwise be lethal blows.
The effect ends once the unit evades an attack, simulating how after that harrowing near-miss experience, the surge of desperation fades and the unit's evasion returns to its base chance."
        special_note=_ "This unit's chance to evade grows as it takes damage, resets when evades."
        apply_to=opponent
        sub="(other.wml_vars.desperate_dodge)"
        cumulative=no
    [/chance_to_hit]
#enddef
#define ABILITY_SCAVENGER
    [scavenger]
        id=scavenger
        name=_"scavenger"
        female_name= _ "female^scavenger"
        description=_"Scavenger feeds on the remains of its fallen enemies, absorbing their vitality to heal itself. When the unit kills an enemy, it restores health equal to 25% of the enemy's maximum HP, allowing it to sustain itself in the midst of battle.
This gruesome ability ensures scavenger remains a persistent threat on the battlefield."
        special_note= _ "Whenever this unit kills a living enemy, it heals itself by 25% of the enemy's max health."
    [/scavenger]
#enddef
#define ABILITY_DRUMBEAT
    [leadership]
        id=drumbeat
        name= _ "drumbeat"
        female_name= _ "female^drumbeat"
        description= _ "#TODO"
        special_note= _ "This unit can offer reassurance to allies, counteracting a time-of-day penalty."
        value="(if('fearless' in other.traits,
            0,
            switch(
                other.alignment,
                'chaotic',max(tod_bonus(loc(other.x,other.y)),0),
                'lawful',max((-tod_bonus(loc(other.x,other.y))),0),
                0
            )
        ))" # This is a comment (for WFL) #
        cumulative=no
        affect_self=no
        [affect_adjacent]
        [/affect_adjacent]
    [/leadership]
#enddef
#define ABILITY_STONEFOOT
    [damage]
        id=stonefoot
        name=_"stonefoot"
        female_name= _ "stonefoot"
        description=_"Hearken, ye who seek the wisdom of the ancients! Know ye that the children of the deep places, the venerable dwarven race, possess a might born of stone and forged in the fires of creation itself. When a warrior of our kind plants his feet upon the earth, becoming as immovable as the very mountains we call home, a fearsome power awakens within.
In those moments when a dwarven warrior chooses to stand his ground, neither advancing nor retreating, he channels the unyielding spirit of our ancestors. His arms become as mighty as the great pillars that hold aloft our subterranean halls, and his blows fall with the force of a thousand years of tradition and strength.
Verily, I say unto thee, that should a dwarf remain steadfast in his position during the tumult of battle, eschewing movement in favor of stalwart defense, his strikes shall bear the blessing of the mountain itself. Each swing of his axe, each thrust of his spear, each bolt loosed from his crossbow shall carry with it a fifth part more of its usual might.
This is the way of our people, as it has been since the first dwarf emerged from the heart of the world. We are the immovable objects, the unbreakable shields, and when we choose to stand our ground, all foes shall tremble before our enhanced fury."
        special_note= _ "When this warrior holds it's ground, blows clinging on armor of enemy shall be severe."
        multiply=1.3
        [filter_self]
            formula="(self.wml_vars.side_turn_loc[0].x = self.x) and (self.wml_vars.side_turn_loc[0].y = self.y)" #TODO not perfect if moves there and back... not the case now
        [/filter_self]
    [/damage]
#enddef
#define ABILITY_ADAPTIVE_ARMOR
    [resistance] #TODO
        id=adaptive_armor
        name= _ "adaptive armor"
        female_name= _ "female^adaptive armor"
        description=_"#TODO"
        special_note= _ "#TODO"
        add=50
        #  [filter_self]
        #      type="$(if($this_unit.side = $unit.side,'impact','fire')"
        #      #"$(debug_print(10))"               #
        #  [/filter_self]
        [filter_second_weapon]
            damage="$(if($unit.side = $side_number,$( $turn_number + 1 ),$turn_number))"
        [/filter_second_weapon]
    [/resistance]
#enddef
#define ABILITY_DEATH_SHRIEK
    [dummy]
        id=death_shriek
        name= _ "death shriek"
        female_name= _ "female^death shriek"
        description=_"As this creature perishes, it unleashes a piercing ultrasonic cry. Enemies within 2 tiles are disoriented, suffering 10% reduced accuracy on their next turn. Even in death, the creature's echolocation serves a final purpose."
        special_note= _ "Upon death accuracy of nearby enemies is disrupted temorary."
    [/dummy]
#enddef
#define ABILITY_ENDURANCE
    [dummy]
        id=endurance
        name= _ "endurance"
        female_name= _ "female^endurance"
        description=_"If this unit begins combat with its full measure of life, it cannot be felled in one engagement, always emerging with a flicker of vitality intact."
        special_note= _ "Should a combatant enter the fray with their life force unblemished, the threads of fate shall not be severed in a single clash of arms."
    [/dummy]
#enddef
#define ABILITY_RESTED
    [rested]
        id=rested
        name= _ "rested"
        female_name= _ "female^rested"
        description=_"#TODO"
        special_note= _ "#TODO"
    [/rested]
#enddef
#define ABILITY_ARDENT
    [ardent]
        id=ardent
        name= _ "ardent"
        female_name= _ "female^ardent"
        description=_"Woe unto those who would stand against the ardent lord and his invigorated host, for they shalt be swept away like leaves before the tempest. The elder chroniclers speak in awed tones of the devastation wrought by these sudden, savage assaults - a testament to the inspiring power of a leader who hath tasted victory and shown his warriors the true meaning of courage."
        special_note= _ "When the battle-hardened lord doth vanquish his foes, a righteous fire doth instantly ignite within the hearts of his loyal warriors. For the lord, unafraid to cast himself into the heart of the fierce battle, sets an example of peerless valor that his men cannot help but emulate with fervor."
    [/ardent]
#enddef
#define ABILITY_PROTECTION
    [resistance] #TODO only if attacker adjacent to this unit ### CANNOT BE DONE!!!
        id=protection
        name= _ "protection"
        female_name= _ "female^protection"
        description=_"#TODO"
        special_note= _ "#TODO"
        add=20
        max_value=50
        affect_self=no
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                formula="(hitpoints/max_hitpoints) < (other.hitpoints/other.max_hitpoints)"
            [/filter]
        [/affect_adjacent]
        #  [filter_opponent]
        #      [filter_location]
        #          [filter_adjacent_location]
        #              [filter]
        #                  id="meow"
        #              [/filter]
        #          [/filter_adjacent_location]
        #      [/filter_location]
        #  [/filter_opponent]
        #  [filter_adjacent]
        #      [not]
        #          id="(other.id)"
        #      [/not]
        #  [/filter_adjacent]
        #  [filter_self]
        #      [filter_adjacent]
        #          id=(other.id)
        #      [/filter_adjacent]
        #  [/filter_self]
        #  [filter_second]
        #      [filter_adjacent]
        #          id="meow"
        #      [/filter_adjacent]
        #  [/filter_second]
        [filter_base_value]
            less_than=50
        [/filter_base_value]
        cumulative=yes
    [/resistance]
#enddef
#define WEAPON_SPECIAL_SHIELDSTRIKE
    [damage]
        id=shieldstrike
        name= _ "shieldstrike"
        female_name= _ "female^shieldstrike"
        description= _ "#TODO"
        special_note= _ "When this attack is used offensively, this unit takes 2 damage less on every strike."
        active_on=offense
        apply_to=opponent
        sub=2
    [/damage]
#enddef
#define WEAPON_SPECIAL_REVENGE
    [chance_to_hit]
        id=revenge
        name= _ "revenge"
        female_name= _ "female^revenge"
        description=_"#TODO"
        special_note= _ "The unit has at least 60% chance to hit during retaliation."
        value=60
        cumulative=yes
        active_on=defense
        apply_to=self
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_INK
    [dummy]
        id=ink
        name=_"ink"
        female_name= _ "female^ink"
        description= _ "#TODO"
        special_note= _ "Ink reduces opponents chance to hit by 10% upon hitting, until the end of the combat."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_RAPIDFIRE
    [chance_to_hit]
        id=rapidfire
        name= _ "rapidfire"
        female_name= _ "female^rapidfire"
        description= _ "The Rapidfire ability allows the wielder to unleash a blistering hail of attacks by rapidly firing or striking with the weapon. However, this drastic rise in attack speed comes at the cost of reduced accuracy and precision.
While Rapidfire is active, each individual attack has a higher chance to miss the intended target as the wielder sacrifices careful aim for sheer volume of fire. Shots go awry more frequently, blows glance off-target, and it becomes much harder to land clean hits."
        special_note= _ "Units attack releases shots in fast succession, which increases strikes by 90%, but cuts accuracy in half."
        sub=20
        active_on=offense
        cumulative=no
    [/chance_to_hit]
    [attacks]
        id=rapidfire
        name= _ ""
        description= ""
        multiply=1.9
        active_on=offense
        cumulative=no
    [/attacks]
#enddef
#define WEAPON_SPECIAL_TEMPO_SURGE
    [attacks]
        id=tempo_surge
        name= _ "tempo surge"
        female_name= _ "female^tempo surge"
        description= _ "In the crucible of combat, time bends to the sword's will. Blades clash in a furious dance, each warrior's strikes multiplied as if caught in a whirlwind of steel. Both attacker and defender find their blows increased by half again, locked in a duel that pushes the very limits of mortal speed and skill."
        special_note= _ "A frenzied exchange of blows pushes both combatants to their limits. Increases strikes by 1.5x for both attacker and defender."
        multiply=1.5
        apply_to=both
        active_on=offense
        cumulative=no
    [/attacks]
#enddef
#define WEAPON_SPECIAL_KNOCKBACK
    [knockback]
        id=knockback
        name= _ "knockback"
        female_name= _ "female^knockback"
        description=_ "#TODO"
        special_note= _"#TODO"
    [/knockback]
#enddef
#define WEAPON_SPECIAL_ARMOR_BREAKING
    [dummy]
        id=armor_breaking
        name=_"armor breaking"
        female_name= _ "female^armor breaking"
        description=_"With a thunderous blow that shakes the very earth, this weapon finds the flaw in foe's defenses. Their vaunted armor is temporarily compromised by 20%, its protective layers rent asunder by the sheer ferocity of attack. For but a fleeting moment, their stalwart guard is grievously weakened, leaving them vulnerable to further onslaught. Strike true while their aegis falters, for soon their battered shield shall regain its potency, denying this opportune breach. Seize chance to exploit their failing guard before the armor's integrity is restored."
        special_note= _ "Attacks of this unit can temporarily break foes armor."
    [/dummy]
#enddef
#define ABILITY_BROKEN_ARMOR
    [resistance]
        id=broken_armor_1
        cumulative=no
        sub=20
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=20
            less_than=100
        [/filter_base_value]
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/resistance]
    [resistance]
        id=broken_armor_2
        cumulative=no
        value=0
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=0
            less_than=21
        [/filter_base_value]
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/resistance]
#enddef
#define WEAPON_SPECIAL_ARMOR_PENETRATING
    [dummy]
        id = armor_penetrating
        name = _"armor penetrating"
        female_name= _ "female^armor penetrating"
        description= _ "A well-aimed attack that defies conventional defenses. With lethal precision, blow finds the chinks and weak points in foe's armor. No matter how stalwart their protective layering, a full thirty percent of its shielding value is rendered utterly moot. Such is the penetrating might of this focused assault that it simply punches through, shearing the armored plates asunder as if they were made of parchment."
        special_note= _ "This unit's attack can ignore portion of enemy armor."
    [/dummy]
#enddef
#define ABILITY_ARMOR_PENETRATING
    [resistance]
        id=armor_penetrating_ability_1
        cumulative=no
        sub=30
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=30
            less_than=100
        [/filter_base_value]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=armor_penetrating
        [/filter_second_weapon]
    [/resistance]
    [resistance]
        id=armor_penetrating_ability_2
        cumulative=no
        value=0
        min_value=0
        max_value=100
        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=0
            less_than=31
        [/filter_base_value]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=armor_penetrating
        [/filter_second_weapon]
    [/resistance]
#enddef
#define WEAPON_SPECIAL_PARRY
    [dummy]
        id = parry
        name = _"parry"
        female_name= _ "female^parry"
        description= _ "When an enemy attack misses, the unit expertly parries the failed strike, creating an opening for a precise counterattack.

This ability ensures that the unit lands a retaliatory hit, turning the foe's failure into an immediate advantage."
        special_note= _ "This unit hits enemy, when it misses it's strike."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_EXPLOITATION
    [dummy]
        id = exploitation
        name = _"exploitation"
        female_name= _ "female^exploitation"
        description= _ "Seizing the perfect moment, the opportunist unleashes a devastating strike on retreating enemies, exploiting their vulnerability, ensuring no escape for the weak and the cowardly

This unit attacks enemies with strike of the weapon, when a foe leaves it's zone of control."
        special_note= _ "This unit can deal extra damage to retreating enemy."
    [/dummy]
#enddef
#define ABILITY_MARK
    [resistance] #TODO#TOD#TODO UPDATE DESCRIPTION
        id=mark
        sub=30
        [filter_self]
            formula="(other.id = self.wml_vars.marked_unit)"
        [/filter_self]
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [not] #TODO in case of need shift this list
                    trait="undead"
                [/not]
            [/filter]
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=mark
        [/filter_second_weapon]
    [/resistance]
#enddef
#define ABILITY_CORRODED
    [resistance]
        id=corroded
        name= _ "corroded"
        female_name=_"female^corrode"
        description= _ "This unit's armor is corroded and can not withstand physical damage as well. This status can be removed in a village." #TODO
        special_note= _ "This unit's armor is corroded and can not withstand physical damage as well. This status can be removed in a village."
        sub=10
        max_value=90
        apply_to=blade,pierce,impact
        affect_self=yes
    [/resistance]
#enddef
#define WEAPON_SPECIAL_CORRODE
    [dummy]
        id=corrode
        name= _ "corrode"
        female_name=_"female^corrode"
        description= _ "This attack can corrode the armor of hit units. Its physical resistance it lowered by 10% until the armor gets repaired in a village." #TODO
        special_note= _ "This attack can corrode the armor of hit units. Its physical resistance it lowered by 10% until the armor gets repaired in a village."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_MARK
    [dummy]
        id=mark
        name= _ "mark"
        female_name= _ "female^mark"
        description=_ "After attacking an enemy, this unit learns foes personal weakness allowing further strikes to be critical hits, dealing 50% more damage.
However this unit can mark only one enemy at the time."
        special_note=_ "Attacks of this unit can deal great damage if opponent doesn't change too often."
        [filter_self]
            formula="(other.id = self.wml_vars.marked_unit)"
        [/filter_self]
    [/dummy]
#enddef
#define WEAPON_SPECIAL_EXECUTIONERS_CHOP
    [damage]
        id=executioners_chop
        name= _ "executioner's chop"
        female_name= _ "female^executioner's chop"
        description=_ "With a decisive and brutal swing, the executioner unleashes a devastating blow that can seal the fate of any foe teetering on the edge of oblivion."
        special_note=_ "This unit can deal great damage to criticaly wounded units."
        multiply=2
        apply_to=self
        [filter_opponent]
        [/filter_opponent]
        [filter_self] #TODO, DOESN'T WORK #TODO
            #  formula="if((other.hitpoints * 4) < other.max_hitpoints, 1, 0)"
            formula="(other.hitpoints <= (self.attacks[0].damage * 2))"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_BLEED
    [dummy]
        id=bleed
        name= _ "bleed"
        female_name= _ "female^bleed"
        description=_"#TODO"
        special_note=_ "#TODO"
    [/dummy]
#enddef
#define WEAPON_SPECIAL_COUNTER
    [chance_to_hit]
        id=counter
        name= _ "counter"
        female_name= _ "female^counter"
        description= _ "#TODO"
        special_note= _ "When used defensively, this attack always has at least a 60% chance to hit."
        value=60
        cumulative=yes
        active_on=defense
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_CRIPPLING_BLOW
    [dummy] #CURED ONLY IN VILLAGES, HEAL 8 HEALERS AND REGENERATION (20% PER HEALING)
        id=crippling_blow
        name= _ "crippling blow"
        female_name= _ "female^crippling blow"
        description=_ "This weapon makes the enemy unable to fight effectively, decreasing it's damage for 5% until healed." #TODO #TODO
        special_note=_ "This unit can hit so hard, it makes the enemy unable to fight effectively."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_LIMITED_USES ATTACKS TRAIT MENU_ITEM
    [limited_uses]
        id=limited_uses
        name= _ "limited uses {ATTACKS}"
        description=_ "This weapon can be used {ATTACKS} more times."
        special_note=_ "One of units weapon can be used only {ATTACKS} times."
        uses={ATTACKS}
        trait={TRAIT}
        menu_item={MENU_ITEM}
    [/limited_uses]
#enddef
#  #define WEAPON_SPECIAL_LIMITED_USES_MAX ATTACKS TRAIT MENU_ITEM
#      [limited_uses]
#          id=limited_uses_max
#          uses={ATTACKS}
#          trait={TRAIT}
#          menu_item={MENU_ITEM}
#      [/limited_uses]
#  #enddef
#define WEAPON_SPECIAL_ALL_ROUND
    [dummy]
        id=all_round
        name= _ "all round"
        description=_ "This attack damages all surrounding enemies."
        special_note=_ "This unit can damage all surrounding enemies."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_CLUSTER_SHOT
    [dummy]
        id=cluster_shot
        name= _ "cluster shot"
        description=_ "This attack damages all units adjacent to primary target."
        special_note=_ "Attacks of this unit can damage multiple units at once."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_LONG_RANGED RANGE
    [dummy]
        id=long_ranged_{RANGE}
        name= _ "long ranged {RANGE}"
        description=_ "This attack can attack to hexes up to {RANGE} tiles away"
        special_note=_ "Attacks of this unit can damage enemies up to {RANGE} tiles away"
        # set attack_weight and defense_weight to 0 if it's long ranged only
    [/dummy]
#enddef
#define WEAPON_SPECIAL_HIT_AND_RUN
    [dummy]
        id=hit_and_run
        name= _ "hit and run"
        description=_ "Attacker restores movement and gains skirmisher ability for rest of the turn when attacking with this weapon."
        special_note=_ "This unit can attack and then move again."
    [/dummy]
#enddef
#define WEAPON_SPECIAL_CRITICAL
    [damage]
        id=critical
        name= _ "critical"
        female_name=_"female^critical"
        description=_ "Imbued with lethal precision, this weapon harbors a latent power that occasionally manifests in devastating strikes, doubling its destructive force."
        special_note=_ "Weapon(s) of this unit have 10% chance to strike a vital point, inflicting twofold carnage."
        multiply=2
        [filter_self]
            formula="(self.wml_vars.critical = 1)"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_BULLSEYE
    [chance_to_hit]
        id=bullseye
        name= _ "bullseye"
        description = _ "When striking offensively, this weapon channels its wielder's focus, piercing through the chaos of battle. Attacks gain unerring accuracy, ensuring at least a 70% chance to hit."
        special_note= _ "Some weapons of the unit have at least a 70% chance to hit when used offensively."
        value=70
        cumulative=yes
        active_on=offense
    [/chance_to_hit]
#enddef
#define ABILITY_UNEXPERIENCED
    [chance_to_hit]
        id=unexperienced
        name= _ "unexperienced"
        description = _ "#TODO"
        special_note= _ "#TODO"
        sub=10
        cumulative=yes
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_STUN
    [damage]
        id=zoc_stun
        name= _ "stun"
        description= _ "This attack hits so hard that the opponent is dazed and can no longer enforce a zone of control and looses half of movement points. The effect wears off on the opponents next turn."
        special_note=_ "This unit is able to stun its enemies, disrupting their zones of control and slowing them down."
        multiply=1
    [/damage]
#enddef
#define WEAPON_SPECIAL_SURPRISE
    [damage]
        id=surprise
        name= _ "surprise"
        description= _ "This attack deals 25% extra damage to enemies that are 5 or more tiles away at the beginning of its turn. Skilled at striking from afar, it catches distant foes off guard."
        special_note=_ "Solider, skilled at striking from afar, catches distant foes off guard, dealing some extra casualties."
        multiply=1.25
        active_on=offense
        [filter_self]
            formula="(if(self.wml_vars.side_turn_loc[0].x != null(),5 < distance_between(loc(self.wml_vars.side_turn_loc[0].x, self.wml_vars.side_turn_loc[0].y),loc(other.x,other.y)),1))"
        [/filter_self]
    [/damage]
#enddef
#define WEAPON_SPECIAL_ALWAYS_HITS
    [chance_to_hit]
        id=always_hits
        name= _ "always hits"
        description= _ "This attack is always successful."
        special_note=_ "Some attacks of this unit never misses."
        value=100
        cumulative=no
    [/chance_to_hit]
#enddef
#define WEAPON_SPECIAL_KAMIKAZE
    [dummy]
        id=kamikaze
        name= _ "kamikaze"
        description=_"Unit dies while performing this attack."
        special_note=_"This unit can deliver critical blow, dying in the process."
    [/dummy]
#enddef
#define UNIT_SKIRIMSHER UNIT_FILTER
    [modify_unit]
        [filter]
            {UNIT_FILTER}
        [/filter]
        [object]
            silent=yes
            duration=turn end
            [effect]
                apply_to=new_ability
                [abilities]
                    [skirmisher]
                        id=skirmisher
                        name= _ "skirmisher"
                        female_name= _ "female^skirmisher"
                        description= _ "This unit is skilled in moving past enemies quickly, and ignores all enemy Zones of Control."
                        special_note={INTERNAL:SPECIAL_NOTES_SKIRMISHER}
                        affect_self=yes
                    [/skirmisher]
                [/abilities]
            [/effect]
        [/object]
        moves=$unit.max_moves
    [/modify_unit]
#enddef
#define ABILITY_ALCHEMIST
    [dummy]
        id=alchemist
        name= _ "alchemist"
        female_name= _ "female^alchemist"
        description=_ "This unit can create potions."
        special_note=_ "This unit can create potions."
    [/dummy]
#enddef
#define ABILITY_POTION_OF_HEALING
    [heals]
        value=8
        id=potion_of_healing
        affect_allies=yes
        name= _ "potion_of_healing +8"
        female_name= _ "female^potion_of_healing +8"
        description= _ "heals +8"
        affect_self=no
        poison=slowed
        [affect_adjacent]
        [/affect_adjacent]
    [/heals]
#enddef
#define ABILITY_POTION_OF_LEADING
    [leadership]
        id=potion_of_leading
        value="(25 * (level - other.level))"
        cumulative=no
        name= _ "potion_of_leading"
        female_name= _ "female^potion_of_leading"
        description= _ "This unit can lead other troops in battle.

All adjacent lower-level units from the same side deal 25% more damage for each difference in level."
        affect_self=no
        [affect_adjacent]
            [filter]
                formula="level < other.level"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef
#define IMPLEMENT_TITLES_FOR_CERTAIN_UNITS
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [filter]
            type=BfBH Skeleton Archer,BfBH Bone Shooter,BfBH Banebow,BfBH Skeleton,BfBH Revenant,BfBH Deathblade,BfBH Draug
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
skeleton_name = {}
skeleton_name["BfBH Skeleton Archer"] = "     "
skeleton_name["BfBH Bone Shooter"] = "     "
skeleton_name["BfBH Banebow"] = "     "
skeleton_name["BfBH Skeleton"] = ""
skeleton_name["BfBH Revenant"] = ""
skeleton_name["BfBH Deathblade"] = ""
skeleton_name["BfBH Draug"] = ""
unit.name=skeleton_name[unit.type]
>>
        [/lua]
    [/event]
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [variables]
                        necromancer_name=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
local necromancers_table={"BfBH Dark Adept","BfBH Dark Sorcerer","BfBH Necromancer","BfBH Lich","BfBH Ancient Lich"}
local necromancers={}
--local function assign_titles(title, units)
for _, unit in ipairs(necromancers_table) do
    necromancers[unit] = true
end
--end
if necromancers[unit.type] then
    if tostring(unit.name) == "" then
        if mathx.random() < 0.7 then --becouse males are superior XD
            unit.name = wesnoth.races["human"].male_name_gen()
        else
            unit.name = wesnoth.races["human"].female_name_gen()
        end
    end
local upper_to_lower = {
    -- Basic Latin
    [65] = 97, [66] = 98, [67] = 99, [68] = 100, [69] = 101, [70] = 102, [71] = 103, [72] = 104, [73] = 105, [74] = 106,
    [75] = 107, [76] = 108, [77] = 109, [78] = 110, [79] = 111, [80] = 112, [81] = 113, [82] = 114, [83] = 115, [84] = 116,
    [85] = 117, [86] = 118, [87] = 119, [88] = 120, [89] = 121, [90] = 122,
    -- Latin-1 Supplement
    [192] = 224, [193] = 225, [194] = 226, [195] = 227, [196] = 228, [197] = 229, [198] = 230, [199] = 231,
    [200] = 232, [201] = 233, [202] = 234, [203] = 235, [204] = 236, [205] = 237, [206] = 238, [207] = 239,
    [208] = 240, [209] = 241, [210] = 242, [211] = 243, [212] = 244, [213] = 245, [214] = 246, [216] = 248,
    [217] = 249, [218] = 250, [219] = 251, [220] = 252, [221] = 253, [222] = 254,
    -- Latin Extended-A
    [256] = 257, [258] = 259, [260] = 261, [262] = 263, [264] = 265, [266] = 267, [268] = 269, [270] = 271,
    [272] = 273, [274] = 275, [276] = 277, [278] = 279, [280] = 281, [282] = 283, [284] = 285, [286] = 287,
    [288] = 289, [290] = 291, [292] = 293, [294] = 295, [296] = 297, [298] = 299, [300] = 301, [302] = 303,
    [304] = 105, [306] = 307, [308] = 309, [310] = 311, [313] = 314, [315] = 316, [317] = 318, [319] = 320,
    [321] = 322, [323] = 324, [325] = 326, [327] = 328, [330] = 331, [332] = 333, [334] = 335, [336] = 337,
    [338] = 339, [340] = 341, [342] = 343, [344] = 345, [346] = 347, [348] = 349, [350] = 351, [352] = 353,
    [354] = 355, [356] = 357, [358] = 359, [360] = 361, [362] = 363, [364] = 365, [366] = 367, [368] = 369,
    [370] = 371, [372] = 373, [374] = 375, [376] = 255, [377] = 378, [379] = 380, [381] = 382, [383] = 115,
    -- Latin Extended-B (full)
    [384] = 579, [385] = 595, [386] = 387, [388] = 389, [390] = 596, [391] = 392, [393] = 598, [394] = 599, [395] = 396,
    [398] = 477, [399] = 601, [400] = 603, [401] = 402, [403] = 608, [404] = 611, [406] = 617, [407] = 616, [408] = 409,
    [412] = 623, [413] = 626, [415] = 629, [416] = 417, [418] = 419, [420] = 421, [422] = 640, [423] = 424, [425] = 643,
    [428] = 429, [430] = 648, [431] = 432, [433] = 650, [434] = 651, [435] = 436, [437] = 438, [439] = 658, [440] = 441,
    [444] = 445, [452] = 454, [453] = 454, [455] = 457, [456] = 457, [458] = 460, [459] = 460, [461] = 462, [463] = 464,
    [465] = 466, [467] = 468, [469] = 470, [471] = 472, [473] = 474, [475] = 476, [478] = 479, [480] = 481, [482] = 483,
    [484] = 485, [486] = 487, [488] = 489, [490] = 491, [492] = 493, [494] = 495, [496] = 447, [497] = 499, [498] = 499,
    [500] = 501, [502] = 405, [503] = 447, [504] = 505, [506] = 507, [508] = 509, [510] = 511, [512] = 513, [514] = 515,
    [516] = 517, [518] = 519, [520] = 521, [522] = 523, [524] = 525, [526] = 527, [528] = 529, [530] = 531, [532] = 533,
    [534] = 535, [536] = 537, [538] = 539, [540] = 541, [542] = 543, [544] = 414, [546] = 547, [548] = 549, [550] = 551,
    [552] = 553, [554] = 555, [556] = 557, [558] = 559, [560] = 561, [562] = 563, [570] = 11365, [571] = 572, [573] = 410,
    [574] = 11366, [577] = 578, [580] = 649, [581] = 652, [582] = 583, [584] = 585, [586] = 587, [588] = 589, [590] = 591,
    -- Greek and Coptic
    [913] = 945, [914] = 946, [915] = 947, [916] = 948, [917] = 949, [918] = 950, [919] = 951, [920] = 952,
    [921] = 953, [922] = 954, [923] = 955, [924] = 956, [925] = 957, [926] = 958, [927] = 959, [928] = 960,
    [929] = 961, [931] = 963, [932] = 964, [933] = 965, [934] = 966, [935] = 967, [936] = 968, [937] = 969,
    [938] = 970, [939] = 971,
    -- Cyrillic
    [1040] = 1072, [1041] = 1073, [1042] = 1074, [1043] = 1075, [1044] = 1076, [1045] = 1077, [1046] = 1078, [1047] = 1079,
    [1048] = 1080, [1049] = 1081, [1050] = 1082, [1051] = 1083, [1052] = 1084, [1053] = 1085, [1054] = 1086, [1055] = 1087,
    [1056] = 1088, [1057] = 1089, [1058] = 1090, [1059] = 1091, [1060] = 1092, [1061] = 1093, [1062] = 1094, [1063] = 1095,
    [1064] = 1096, [1065] = 1097, [1066] = 1098, [1067] = 1099, [1068] = 1100, [1069] = 1101, [1070] = 1102, [1071] = 1103,
}

local lower_to_upper = {}
for upper, lower in pairs(upper_to_lower) do
    lower_to_upper[lower] = upper
end

local function custom_lower(s)
    return (s:gsub(utf8.charpattern, function(c)
        local codepoint = utf8.codepoint(c)
        return utf8.char(upper_to_lower[codepoint] or codepoint)
    end))
end

local function custom_upper(s)
    return (s:gsub(utf8.charpattern, function(c)
        local codepoint = utf8.codepoint(c)
        return utf8.char(lower_to_upper[codepoint] or codepoint)
    end))
end

local function transform_letters(name)
    name = custom_lower(name)
    local transformations = {
        {pattern = "a", replacement = "ae"},
        {pattern = "e", replacement = "y"},
        {pattern = "i", replacement = "y"},
        {pattern = "o", replacement = "ou"},
        {pattern = "u", replacement = "uu"},
        {pattern = "c", replacement = "k"},
        {pattern = "s", replacement = "z"},
        {pattern = "th", replacement = "tz"},
        {pattern = "w", replacement = "v"},
    }

    for i = #transformations, 2, -1 do
        local j = mathx.random(i)
        transformations[i], transformations[j] = transformations[j], transformations[i]
    end

    for i = 1, math.ceil(#transformations / 2) do
        local t = transformations[i]
        name = name:gsub(t.pattern, function(match)
            if mathx.random() < 0.5 then
                return t.replacement
            else
                return match
            end
        end)
    end

    return custom_upper(name:sub(1,1)) .. name:sub(2)
end

local function add_special_characters(name)
    name = custom_lower(name)
    local specialChars = {
        {char = "", replace = "oe"},
        {char = "", replace = "ae"},
        {char = "", replace = "o"},
        {char = "", replace = "n"},
        {char = "", replace = "i"},
        {char = "", replace = "c"}
    }
    local numToAdd = mathx.random(0, 2)
    for i = 1, numToAdd do
        local try = 1
        ::try_again::
        local charIndex = mathx.random(#specialChars)
        local charInfo = specialChars[charIndex]
        local success = false
        name = name:gsub(charInfo.replace, function(match)
            if not success and mathx.random() < 0.5 then
                success = true
                return charInfo.char
            else
                return match
            end
        end)
        table.remove(specialChars, charIndex)
        if not success and try < 3 then
            try = try + 1
            goto try_again
        end
        if #specialChars == 0 then break end
    end
    return custom_upper(string.sub(name, 1, utf8.offset(name, 2) - 1)) .. string.sub(name, utf8.offset(name, 2))
end

local function split_name(name)
    local length = utf8.len(name)
    if length <= 4 then
        return name
    end

    local cutStart = mathx.random(4, length - 1)
    local cutEnd = mathx.random(cutStart, length - 1)

    local firstPartEnd = utf8.offset(name, cutStart) - 1
    local lastPartStart = utf8.offset(name, cutEnd + 1)

    local firstPart = name:sub(1, firstPartEnd)
    local lastPart = name:sub(lastPartStart)

    local firstCharLastPart = utf8.char(utf8.codepoint(lastPart, 1))
    return firstPart .. "-" .. custom_upper(firstCharLastPart) .. lastPart:sub(utf8.offset(lastPart, 2) or #lastPart + 1)
end

local function add_suffix(name)
    local suffixes = {"'x", "'th", "'yr", "'zh", "'q"}
    name = name .. suffixes[mathx.random(#suffixes)]
    return name
end

local function generate_necromancer_name(name)
    name = transform_letters(name)
    name = add_special_characters(name)

    if mathx.random() < 0.5 then
        name = split_name(name)
    end

    if mathx.random() < 0.5 then
        name = add_suffix(name)
    end
    return name
end
    unit.variables.necromancer_name = true
    unit.name = generate_necromancer_name(tostring(unit.name))
end
>>
        [/lua]
    [/event]
    [event]
        name=unit placed, post_advance
        first_time_only=no
        [filter]
            [not]
                [filter_wml]
                    [variables]
                        title_gained=yes
                    [/variables]
                [/filter_wml]
            [/not]
        [/filter]
        [lua]
            code=<<
local unit = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
-- table containing list of prefix+suffix Axewielder?, add more
-- #TODO change types to BfBH, add much more titles, chor royal human gurad too
local high_naga = {{'Serpent ',''},{'Asp Assassin ',''},{'',' Coiled'},{'Venom Figter ',''},{'',' Scaled'},{'',' Slither'},{'Cobra Fury ',''},{'Vortex Fury ',''},
{'',' Dead Hiss'},{'',' Sharptail'},{'Fanged ',''},{'',' Swift'}}
local titles = {
    high_human_leader = {{'Duke ',''},{'Sir ',''},{'Baron ',''},{'Lord ',''},{'Constable ',''},{'Knight ',''},{'Count ',''},{'Earl',''},{'Marquis ',''},{'Viscount ',''}},
    high_human_foot = {{'',' the Stern'},{'Armor breaker ',''},{'',' Staunch'},{'',' Unyielding'},{'Implacable ',''},{'',' the Seasoned'},{'Master ',''},{'',' Resolute'},
    {'',' Vigilant'},{'',' the Unyielding'},{'',' Loyal'},{'Dauntless ',''},{'Valiant ',''}},
    high_human_paladin = {{'Saint ',''},{'','-Saint'},{'Divine ',''},{'Pious ',''},{'',' the Rider'},{'Mounted ',''},{'',' the Vanguard'},{'Holy ',''},{'','-Holy'},
    {'Lancelot ',''},{'Crusader ',''},{'',' Lionheart'},{'Sunrider ',''}},
    high_human_cavalery = {{'',' the Rider'},{'Mounted ',''},{'',' Flawless'},{'',' Nevermiss'},{'Zealous ',''},{'',' the Zealous'},{'Lancemaster ',''},{'',' Lancemaster'},
    {'Fearless ',''},{'',' Warhorse'},{'Deadly ',''}},
    high_human_javelineer = {{'Lithe-',''},{'',' the Unerring'},{'',' Skilled'},{'Swift ',''},{'',' the Quick'},{'Nimble ',''},{'',' Nimble'},{'Skirmisher ',''}},
    high_dwarf_melee = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Stone','Iron','Deep','Forge','Mountain','Beard','Gold','Rune','Clan','Cave','Anvil','Gem','Rock','Mithril','Ale','Battle','Earth','Tunnel','Shield','Ore','Crystal'}
                local second_part = {'heart','fist','beard','forge','delver','smith','miner','thane','kin','master','lord','breaker','carver','seeker','bane','keeper','guard','born','wise','hand','sworn'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then
            --      return {{'',' Beardlord'},{'',' Gemstone Sovereign'},{'',' the Voluminous'}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_dwarf_ranged = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Boom','Bang','Gun','Fire','Lead','Shot','Blast','Sling','Spark'}
                local second_part = {'eye','shot','arm','bolt','hand','fuse','bang','blast'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then
            --      return {{'',''}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_dwarf_scout = setmetatable({}, {
        __index = function(t, k)
            if k == 1 then
                local first_part = {'Swift','Keen','Track','Sneak','Spy','Stalk','Scout','Far'}
                local second_part = {'foot','eye','ear','nose','step','run','hide'}
                local title=first_part[mathx.random(#first_part)]..second_part[mathx.random(#second_part)]
                local formation = {{'',' '..title},{title..' ',''}}
                return {formation[mathx.random(#formation)]}
            --  elseif k == 2 then
            --      return {{'',''}}
            end
        end,
        __len = function(t)
            return 1  -- IMPORTANT Explicitly define the length
        end
    }),
    high_lich = {{'Lightbane ',''},{'Mercykiller ',''},{'Embalmer ',''},{'Gravedigger ',''},{'',''},{'',''}}, --TODO
    high_bandit = {
{'Black ',''},{'Grim ',''},{'One-eyed ',''},{'Ruthless ',''},{'Bloody ',''},{'Silent ',''},{'Cutthroat ',''},{'Raven ',''},{'Shadow ',''},{'Red ',''},
{'Scarred ',''},{'Savage ',''},{'Bonebreaker ',''},{'Stormcrow ',''},
{'Wolf-',''},{'Hawk-',''},{'Fox-',''},{'Night-',''},{'Rook-',''},{'Flint-',''},{'Claw-',''},
{'',' the Merciless'},{'',' Blackheart'},{'',' the Cunning'},{'',' Bloodfist'},{'',' the Shadowwalker'},{'',' Skullcrusher'},{'',' Ghostwalker'},{'',' the Dread'},
{'',' the Relentless'},{'',' Wolfsbane'},{'',' Blackheart'},{'',' Ravager'},{'',' the Unforgiving'},
{'','-Spite'},{'','-Thorn'}
    },
    high_naga_sword = {unpack(high_naga),{'Twin Fang ',''},{'Slicer ',''},{'',' Whirlwind'},{'',' Fang Master'},{'Reaper ',''},{'',' Reaper'},{'Swordmaster ',''},
    {'',' Swiftblade'},{'',' Forked Cutter'}},
    high_naga_chakram = {unpack(high_naga),{'Halo-',''},{'',' Ringwrath'},{'',' Orbweaver'},{'Discus-',''},{'',' Gyrator'},{'Chakra-',''},{'Circlet-',''},{'','Ringmaster'},
    {'',' Spiraler'},{'',' Gyroclaw'},{'Ringcoil-',''},{'Flyblade-',''},{'','Flyblade'}},
    high_naga_jarid = {unpack(high_naga),{'',' Skewer'},{'',' Master Javelineer'},{'Master Hurler ',''},{'Spike-',''},{'',' Swiftstriker'},{'Barb-',''},{'',' Piercer'},
    {'',' Whistler'},{'',' Supreme Flinger'},{'Quill-',''},{'',' Sharpquill'},{'Spire-',''},{'',' the Skirmisher'}},
    high_goblin_wolf_pillager = {{'',' the Marauder'},{'Plunderer ',''},{'Ravager ',''},{'Reaver ',''},{'',' the Reaver'},{'Pillager ',''},{'',' the Pillager'},{'Raider ',''},
    {'Snarer ',''},{'',' Snarer'},{'',' Goblin Scourger'},{'',' Embersnout'}},
    high_goblin_wolf_rider = {{'Razerwolf ',''},{'',' the Razerwolf'},{'Havocbringer ',''},{'',' the Havocbringer'},{'',' Dreadclaw'},{'',' Wailing'},{'',' Terrorhowl'},
    {'Howlheart ',''},{'',' Fangflinger'},{'',' the Fangflinger'},{'Barkbiter ',''},{'','-Barkbiter'},{'Growlgutter ',''},{'',' Scruffscourge'}},
    high_spider = {{'Monster',''},{'Widowmaker',''},{'Mindtwister',''},{'Heartpiercer',''},{'Venom Hunter',''},{'Shadowstitcher',''},{'Quiet Death',''},{'Death',''},
    {'Reaper',''},{'Corpse-Wrapper',''},{'Tapestry of Terror',''},{'Venom\'s Embrace',''},{'Dark Dead',''},{'Abomination',''},{'Hairy Horror',''},{'Widow\'s Embrace',''},
    {'Eyes in the Dark',''},{'Thousand Legs',''},{'Blood Demon',''},{'Nightmare\'s Messenger',''},{'Shadowcreeper',''}}
}
local title_assignments = {}
local function assign_titles(title, units)
    for _, unit in ipairs(units) do
        title_assignments[unit] = title
    end
end
assign_titles("high_human_leader", {"BfBH Lieutenant","BfBH General","BfBH Grand Marshal","BfBH Grand Knight"})
assign_titles("high_human_foot", {"BfBH Master Bowman","BfBH Royal Guard","BfBH Halberdier"})
assign_titles("high_human_cavalery", {"BfBH Lancer","BfBH Cavalier"})
assign_titles("high_human_paladin", {"BfBH Paladin"})
assign_titles("high_human_javelineer", {"BfBH Javelineer"})
assign_titles("high_dwarf_melee", {"BfBH Dwarvish Lord","BfBH Dwarvish Runemaster","BfBH Dwarvish Arcanister","BfBH Dwarvish Sentinel"})
assign_titles("high_dwarf_ranged", {"BfBH Dwarvish Dragonguard"})
assign_titles("high_dwarf_scout", {"BfBH Dwarvish Explorer"})
assign_titles("high_lich", {"BfBH Ancient Lich"})
assign_titles("high_bandit", {"BfBH Highwayman","BfBH Ranger","BfBH Huntsman","BfBH Fugitive"})
assign_titles("high_naga_sword", {"BfBH Naga Myrmidon"})
assign_titles("high_naga_chakram", {"BfBH Naga Zephyr"})
assign_titles("high_naga_jarid", {"BfBH Naga Sicarius"})
assign_titles("high_goblin_wolf_pillager", {"BfBH Goblin Pillager"})
assign_titles("high_goblin_wolf_rider", {"BfBH Direwolf Rider"})
assign_titles("high_spider", {"BfBH Giant Spider"})
local function get_unit_title(type)
    return titles[title_assignments[type]] or false
end
title_table = get_unit_title(unit.type)
if title_table then
    local title = title_table[mathx.random(#title_table)]
    ::move_layer_deeper::
    if type(title[1]) == "table" then
        title=title[mathx.random(#title)]
        goto move_layer_deeper
    end
    unit.variables.title_gained = true
    unit.name = title[1] .. unit.name .. title[2]
end
>>
        [/lua]
    [/event]
#enddef
#define IMPLEMENT_ALCHEMIST
    [set_menu_item]
        id=potion_choose
        description= _ "potion selection"
        #[show_if]
            #[true]
            #[/true]
        #[/show_if]
        [filter_location]
            [filter]
                ability=alchemist
            [/filter]
        [/filter_location]
        [command]
            [message]
                speaker=$unit.id
                message= _ "What potion should I make?"
                [option]
                    label= _ "Potion of healing"
                    [command]
                        [modify_unit]
                            [filter]
                                id=$unit.id
                            [/filter]
                            role=going_to_make_potion_of_healing
                        [/modify_unit]
                    [/command]
                [/option]
                [option]
                    label= _ "Potion of leadership"
                    [command]
                        [modify_unit]
                            [filter]
                                id=$unit.id
                            [/filter]
                            role=going_to_make_potion_of_leading
                        [/modify_unit]
                    [/command]
                [/option]
            [/message]
        [/command]
    [/set_menu_item]
    [event]
        name=turn refresh
        first_time_only=no
        [modify_unit]
            [filter]
                #side=$side_number
                #ability=alchemist
            [/filter]
            [effect]
                apply_to=remove_ability
                [abilities]
                    id=potion_of_healing, potion_of_leading
                [/abilities]
            [/effect]
        [/modify_unit]
        [modify_unit]
            [filter]
                side=$side_number
                role=going_to_make_potion_of_healing
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_POTION_OF_HEALING}
                [/abilities]
            [/effect]
        [/modify_unit]
        [modify_unit]
            [filter]
                side=$side_number
                role=going_to_make_potion_of_leading
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_POTION_OF_LEADING}
                [/abilities]
            [/effect]
        [/modify_unit]
    [/event]
#enddef
#define IMPLEMENT_LOAD_COUNTER
    [event]
        name=new turn
        first_time_only=no
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=$turn_number
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
    [/event]
    [event]
        name=preload
        first_time_only=no
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable] ### MEANS IT'S NOT SCENARIO ONE FIRST EVER LOAD
                name=game_number
                not_equals=""
            [/variable]
            [and]
                [variable]
                    name=is_variable_created
                    not_equals=""
                [/variable]
            [/and]
            [then]
                [get_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_global=$turn_number
                    to_local=turn_load_count
                    side=1
                [/get_global_variable]
                [set_variable]
                    name=turn_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=turn_load_count
                    to_global=$turn_number
                    side=1
                    immediate=yes
                [/set_global_variable]
                {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number total_load_count total_load_count}
                [set_variable]
                    name=total_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number
                    from_local=total_load_count
                    to_global=total_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
                {GET_GLOBAL_VARIABLE Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number scenario_load_count scenario_load_count}
                [set_variable]
                    name=scenario_load_count
                    add=1
                [/set_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=scenario_load_count
                    to_global=scenario_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
                [if]
                    [variable]
                        name=show_load_counter_pop_ups
                        equals=yes
                    [/variable]
                    [then]
{SAVESCUM_MESSAGE savescum_2 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 2} _"Leave no man behind!" help/bandits_to_ghost.png _"Abandon timeline"
_"
Each reset abandons your crew to a
forgotten timeline.
Can you face the ghosts of
all companions you've erased?"}
{SAVESCUM_MESSAGE savescum_4 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 4} _"Harvest of Lost Futures" help/great_dark.png _"Reap the consequences"
_"
Every discarded path,
every erased moment,
feeds the hunger of
something unspeakable.

The dead grow restless."}
{SAVESCUM_MESSAGE savescum_6 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 6} _"The land remembers" help/wose_and_merman.png _"Face its wrath"
_"
Feel that chill?
The very earth growls with each retry.
Ancient forces stir,
and they're not looking to negotiate.

Fate's comming!"}
{SAVESCUM_MESSAGE savescum_8 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 8} _"Requiem of the Rewritten" help/skeletons.png _"Conduct the unmaking"
_"
Reality's cracks echo,
with forbidden knowledge.
Something ancient drinks deep,
from the abyss."}
{SAVESCUM_MESSAGE savescum_10 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 10} _"Echoes" help/dwarves_to_undead.png _"Listen to the void"
_"
Inhuman laughter resonates,
across timelines.
How many times have you heard it?
How many times will you,

untill it consumes you?"}
{SAVESCUM_MESSAGE savescum_12 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 12} _"Reflection of Entropy" help/broken_hourglass.png _"Shatter reality"
_"
Time bleeds through reality's wounds.
Every reset fractures the mirror of existence.

Something terrifying grows stronger with each drop."}

#  "The night holds many secrets. Some are best left undiscovered by meddling with time."

                        [event]
                            name=side turn,moveto,sighted,recruit,recall,attacker hits,attacker misses,defender hits,defender misses,last breath,die,side turn end,attack
                            first_time_only=no
                            id=savescum_load_messages
                            [if]
                                [variable]
                                    name=show_load_counter_pop_ups
                                    equals=yes
                                [/variable]
                                [then]
{SAVESCUM_MESSAGE savescum_1 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 1} _"Time's revenge" help/farm_ambush.png _"Pay the debt"
_"
With each manipulation,
you borrow from a debt,
you can't repay.
And time, friend,

is a most unforgiving collector."}
{SAVESCUM_MESSAGE savescum_3 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 3} _"Echoes of the forsaken" help/battle_for_castle.png _"Embrace oblivion"
_"
The men whisper of phantom pains,
memories of deaths undone.
How many times can you,
ask them to die,

for you?"}
{SAVESCUM_MESSAGE savescum_5 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 5} _"The Watching Dark" help/cave_march.png _"Step into shadows"
_"
Shadows flicker oddly in the torchlight.
Your men's eyes dart nervously.
The darkness remembers every time,
you've tried to cheat it.

It's patient.
It's hungry."}
{SAVESCUM_MESSAGE savescum_7 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 7} _"Glitter of Lost Futures" help/gold_hoard.png _"Count the cost"
_"
Your men cheer,
but the gold feels too heavy.
It pulls at you,
a gravitational mass of every reset,
every do-over.

The universe demands balance.
And you're in debt."}
{SAVESCUM_MESSAGE savescum_9 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 9} _"Ripples of Unmaking" help/hidden_in_village.png _"Drown in possibility"
_"
As your foes pass by,
reality shimmers.

You've lived this moment too many times.
The fabric of existence wears thin here.

Pray it doesn't tear..."}
{SAVESCUM_MESSAGE savescum_11 {VARIABLE_CONDITIONAL total_load_count greater_than_equal_to 11} _"Sacrifice to Chaos" help/spider_fight.png _"Feed the madness"
_"
Your men flee as you battle the beast.
But in how many abandoned timelines
did they die here?

Their ghosts watch,
judging your cowardice across realities."}

#  "The night holds many secrets. Some are best left undiscovered by meddling with time."
#  Extended text:
#  The shadows that cloak your misdeeds are the same shadows that guard the mysteries of the world. As a bandit, you've learned to use the night as your ally, but have you considered that time itself might not be so forgiving of manipulation? Each attempt to rewrite your story sends ripples through the fabric of reality. The coins you steal today might be the ones that would have funded your future ally. The guard you avoid might have become a valuable informant. The failure you erase might have been the key to a greater success. The world of a bandit is one of delicate balance  between risk and reward, trust and betrayal, fate and free will. By constantly seeking to unveil the 'what ifs', you risk unraveling the very threads of your destiny. Some doors, once opened, can never be closed. Some knowledge, once gained, can never be unlearned. In your quest for the perfect heist, be wary of the price you might pay for peeking behind the curtain of time.

#  "True legends are forged in the fires of adversity, not in the shadows of forgotten timelines."
#  Extended text:
#  In the crucible of challenge, legends are born. Every great bandit tale, every whispered story of impossible heists and daring escapes, is built on a foundation of trials overcome and lessons hard-won. When you choose to rewrite your story, to hide from the consequences of your choices, you rob yourself of the very experiences that would temper your skills and sharpen your wit. Think of the greatest outlaws in history  they didn't achieve renown by playing it safe or always making the right choice. They became legends by facing impossible odds, by turning crushing defeats into unlikely victories, by learning from every misstep until they could dance through danger as easily as others walk down a street. The path of a true legend is not a straight line to glory, but a winding road of triumph and tribulation. Each time you erase a failure, you erase an opportunity to grow, to adapt, to become the stuff of legend. Will you hide in the shadows of 'what might have been', or will you stride boldly into the fires of adversity, ready to be forged into a legend that will echo through the ages?

#  "The best disguise is one of authenticity. Accept your path, twists and all."
#  Extended text:
#  In the world of subterfuge and deception that you inhabit, the concept of a 'perfect disguise' is alluring. But consider this  the most impenetrable faade is not one built on careful construction, but on genuine experience. Every scar, every callus, every hard-learned lesson etches itself into your very being, creating a persona that no amount of acting could replicate. When you constantly seek to erase your missteps, you're not perfecting your disguise  you're making it more hollow, more likely to crack under scrutiny. The guard who's faced real danger can spot a pretender. The merchant who's weathered true hardship can sense a fabricated tale. But the bandit who wears their full history, who has known both the dizzying heights of a perfect heist and the crushing lows of a plan gone awry? They can slip into any role because they've lived it all. Your path, with all its unexpected turns and harsh lessons, is what makes you unique, unpredictable, and ultimately, unstoppable. Will you embrace the rich tapestry of your experiences, allowing them to shape you into a master of adaptation? Or will you pursue a flawless but flat persona, always at risk of being seen for what you are  a counterfeit trying to pass as the genuine article?
                                [/then]
                            [/if]
                        [/event]
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
    [event]
        name=start
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
            from_global=$turn_number
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=1
                    side=1
                    immediate=yes
                [/set_global_variable]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number|.$scenario_number
                    from_local=variable_with_zero
                    to_global=scenario_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
        [get_global_variable]
            namespace=Bandits_from_Brown_Hills.loads.$game_number
            from_global=total_load_count
            to_local=is_variable_created
            side=1
        [/get_global_variable]
        [if]
            [variable]
                name=is_variable_created
                equals=""
            [/variable]
            [then]
                [set_global_variable]
                    namespace=Bandits_from_Brown_Hills.loads.$game_number
                    from_local=variable_with_zero
                    to_global=total_load_count
                    side=1
                    immediate=yes
                [/set_global_variable]
            [/then]
        [/if]
    [/event]
#enddef
##define ABILITY_GOING_TO_MAKE_POTION_OF_HEALING
    #[dummy]
        #id=going_to_make_potion_of_healing
        #name=""
        #female_name=""
        #description=""
        #special_note=""
    #[/dummy]
##/enddef
##define ABILITY_GOING_TO_MAKE_POTION_OF_LEADING
    #[dummy]
        #id=going_to_make_potion_of_leading
        #name=""
        #female_name=""
        #description=""
        #special_note=""
    #[/dummy]
##/enddef
##define ABILITY_POTION_OF_LEADING
    #[leadership]
        #id=potion_of_leading
        #value="(25 * (level - other.level))"
        #cumulative=no
        #name= _ "potion_of_leading"
        #female_name= _ "female^potion_of_leading"
        #description= _ "This unit can lead other troops in battle.

#All adjacent lower-level units from the same side deal 25% more damage for each difference in level."
        #affect_self=no
        #[affect_adjacent]
            #[filter]
                #formula="level < other.level"
            #[/filter]
        #[/affect_adjacent]
    #[/leadership]
##/enddef
##define IMPLEMENT_ALCHEMIST
    #[set_menu_item]
        #id=potion_choose
        #description= _ "potion selection"
        ##[show_if]
            ##[true]
            ##[/true]
        ##[/show_if]
        #[filter_location]
            #[filter]
                #ability=alchemist
            #[/filter]
        #[/filter_location]
        #[command]
            #[message]
                #speaker=$unit.id
                #message= _ "What potion should I make?"
                #[option]
                    #label= _ "Potion of healing"
                    #[command]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=remove_ability
                                #[abilities]
                                    #id=going_to_make_potion_of_leading
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=new_ability
                                #[abilities]
                                    #{ABILITY_GOING_TO_MAKE_POTION_OF_HEALING}
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                    #[/command]
                #[/option]
                #[option]
                    #label= _ "Potion of leadership"
                    #[command]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=remove_ability
                                #[abilities]
                                    #id=going_to_make_potion_of_healing
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                        #[modify_unit]
                            #[filter]
                                #id=$unit.id
                            #[/filter]
                            #[effect]
                                #apply_to=new_ability
                                #[abilities]
                                    #{ABILITY_GOING_TO_MAKE_POTION_OF_LEADING}
                                #[/abilities]
                            #[/effect]
                        #[/modify_unit]
                    #[/command]
                #[/option]
            #[/message]
        #[/command]
    #[/set_menu_item]
    #[event]
        #name=turn refresh
        #first_time_only=no
        #[modify_unit]
            #[filter]
                #ability=alchemist
            #[/filter]
            #[effect]
                #apply_to=remove_ability
                #[abilities]
                    #id=potion_of_healing,potion_of_leading
                #[/abilities]
            #[/effect]
        #[/modify_unit]
        #[modify_unit]
            #[filter]
                #ability=going_to_make_potion_of_healing
            #[/filter]
            #[effect]
                #apply_to=new_ability
                #[abilities]
                    #{ABILITY_POTION_OF_HEALING}
                #[/abilities]
            #[/effect]
        #[/modify_unit]
        #[modify_unit]
            #[filter]
                #ability=going_to_make_potion_of_leading
            #[/filter]
            #[effect]
                #apply_to=new_ability
                #[abilities]
                    #{ABILITY_POTION_OF_LEADING}
                #[/abilities]
            #[/effect]
        #[/modify_unit]
    #[/event]
##/enddef

#### FINDS CLOSEST ENEMY

#{VARIABLE max_radius 50}
                #{VARIABLE radius 0}
                #{VARIABLE bombard_targets 0}
                #[while]
                    #[variable]
                        #name=bombard_targets
                        #equals=0
                    #[/variable]
                    #[and]
                        #[variable]
                            #name=radius
                            #less_than_equal_to=$max_radius
                        #[/variable]
                    #[/and]
                    #[do]
                        #[if]
                            #[have_unit]
                                #side=1
                                #[filter_location]
                                    #x=$dwarvish_cannoner[$i].x
                                    #y=$dwarvish_cannoner[$i].y
                                    #radius=$radius
                                #[/filter_location]
                            #[/have_unit]
                            #[then]
                                #[store_unit]
                                    #[filter]
                                        #side=1
                                        #[filter_location]
                                            #x=$dwarvish_cannoner[$i].x
                                            #y=$dwarvish_cannoner[$i].y
                                            #radius=$radius
                                        #[/filter_location]
                                    #[/filter]
                                    #variable=bombard_targets
                                #[/store_unit]
                            #[/then]
                        #[/if]
                        #{VARIABLE_OP radius add 1}
                    #[/do]
                #[/while]
